%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english,openany,oneside]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional
  \DeclareUnicodeCharacter{"00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{"2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{"2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{"2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{"251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{"2572}{\textbackslash}
 \else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{2572}{\textbackslash}
 \fi
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Sonny]{fncychap}
\usepackage[dontkeepoldnames]{sphinx}

\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{5}
\setcounter{secnumdepth}{5}


\title{Database Compability for Oracle® Developers Built-in Package Guide}
\date{Mar 17, 2020}
\release{12}
\author{EDB Postgres™ Advanced Server 12}
\newcommand{\sphinxlogo}{\sphinxincludegraphics{edblogo.png}\par}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}



\chapter{\index{Introduction}Introduction}
\label{\detokenize{introduction:database-compatibility-for-oracle-developers-built-in-packages-guide}}\label{\detokenize{introduction::doc}}\label{\detokenize{introduction:introduction}}
Database Compatibility for Oracle means that an application runs in an
Oracle environment as well as in the EDB Postgres Advanced Server
(Advanced Server) environment with minimal or no changes to the
application code. This guide focuses solely on the features that are
related to the package support provided by Advanced Server.

For more information about using other compatibility features offered by
Advanced Server, please see the complete set of Advanced Server guides,
available at:

\sphinxurl{https://www.enterprisedb.com/edb-docs/}

\newpage


\section{\index{What’s New}What’s New}
\label{\detokenize{introduction:whats-new}}
The following database compatibility for Oracle features have been added
to Advanced Server 11 to create Advanced Server 12:
\begin{itemize}
\item {} 
Advanced Server introduces \sphinxcode{COMPOUND TRIGGERS}, which are stored as a
PL block that executes in response to a specified triggering event.
For information, see the \sphinxstyleemphasis{Database Compatibility for Oracle
Developer’s Guide}.

\item {} 
Advanced Server now supports new \sphinxcode{DATA DICTIONARY VIEWS} that provide
information compatible with the Oracle data dictionary views. For
information, see the \sphinxstyleemphasis{Database Compatibility for Oracle Developer’s
Reference Guide}.

\item {} 
Advanced Server has added the \sphinxcode{LISTAGG} function to support string
aggregation that concatenates data from multiple rows into a single
row in an ordered manner. For information, see the \sphinxstyleemphasis{Database
Compatibility for Oracle Developer’s Reference Guide}.

\item {} 
Advanced Server now supports \sphinxcode{CAST(MULTISET)} function, allowing
subquery output to be \sphinxcode{CAST} to a nested table type. For information,
see the \sphinxstyleemphasis{Database Compatibility for Oracle Developer’s Reference
Guide}.

\item {} 
Advanced Server has added the \sphinxcode{MEDIAN} function to calculate a median
value from the set of provided values. For information, see the
\sphinxstyleemphasis{Database Compatibility for Oracle Developer’s Reference Guide}.

\item {} 
Advanced Server has added the \sphinxcode{SYS\_GUID} function to generate and
return a globally unique identifier in the form of 16-bytes of \sphinxcode{RAW}
data. For information, see the \sphinxstyleemphasis{Database Compatibility for Oracle
Developer’s Reference Guide}.

\item {} 
Advanced Server now supports an Oracle-compatible \sphinxcode{SELECT UNIQUE}
clause in addition to an existing \sphinxcode{SELECT DISTINCT} clause. For
information, see the \sphinxstyleemphasis{Database Compatibility for Oracle Developer’s
Reference Guide}.

\item {} 
Advanced Server has re-implemented \sphinxcode{default\_with\_rowids} to create a
table that includes a \sphinxcode{ROWID} column in the newly created table. For
information, see the \sphinxstyleemphasis{EDB Postgres Advanced Server Guide}.

\item {} 
Advanced Server now supports logical decoding on the standby server,
which allows creating a logical replication slot on a standby,
independently of a primary server. For information, see the \sphinxstyleemphasis{EDB
Postgres Advanced Server Guide}.

\item {} 
Advanced Server introduces \sphinxcode{INTERVAL PARTITIONING}, which allows a
database to automatically create partitions of a specified interval
as new data is inserted into a table. For information, see the
\sphinxstyleemphasis{Database Compatibility for Oracle Developer’s Guide.}

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
Database Compatibility for Oracle Developer’s Guide, Database Compatibility for Oracle Developer’s Reference Guide, and EDB Postgres Advanced Server Guides are available at:

\sphinxurl{https://www.enterprisedb.com/edb-docs/}
\end{sphinxadmonition}


\chapter{\index{Packages}Packages}
\label{\detokenize{packages::doc}}\label{\detokenize{packages:packages}}
This chapter discusses the concept of packages in Advanced Server. A
\sphinxstyleemphasis{package} is a named collection of functions, procedures, variables,
cursors, user-defined record types, and records that are referenced
using a common qualifier \textendash{} the package identifier. Packages have the
following characteristics:
\begin{itemize}
\item {} 
Packages provide a convenient means of organizing the functions and
procedures that perform a related purpose. Permission to use the
package functions and procedures is dependent upon one privilege
granted to the entire package. All of the package programs must be
referenced with a common name.

\item {} 
Certain functions, procedures, variables, types, etc. in the package
can be declared as \sphinxstyleemphasis{public}. Public entities are visible and can be
referenced by other programs that are given \sphinxcode{EXECUTE} privilege on the
package. For public functions and procedures, only their signatures
are visible - the program names, parameters if any, and return types
of functions. The SPL code of these functions and procedures is not
accessible to others, therefore applications that utilize a package
are dependent only upon the information available in the signature \textendash{}
not in the procedural logic itself.

\item {} 
Other functions, procedures, variables, types, etc. in the package
can be declared as \sphinxstyleemphasis{private}. Private entities can be referenced and
used by function and procedures within the package, but not by other
external applications. Private entities are for use only by programs
within the package.

\item {} 
Function and procedure names can be overloaded within a package. One
or more functions/procedures can be defined with the same name, but
with different signatures. This provides the capability to create
identically named programs that perform the same job, but on
different types of input.

\end{itemize}

\newpage


\section{\index{Package Components}Package Components}
\label{\detokenize{package_components:package-components}}\label{\detokenize{package_components::doc}}
Packages consist of two main components:
\begin{itemize}
\item {} 
The \sphinxstyleemphasis{package specification}: This is the public interface, (these are
the elements which can be referenced outside the package). We declare
all database objects that are to be a part of our package within the
specification.

\item {} 
The \sphinxstyleemphasis{package body}: This contains the actual implementation of all
the database objects declared within the package specification.

\end{itemize}

The package body implements the specifications in the package
specification. It contains implementation details and private
declarations which are invisible to the application. You can debug,
enhance or replace a package body without changing the specifications.
Similarly, you can change the body without recompiling the calling
programs because the implementation details are invisible to the
application.


\subsection{\index{Package Specification Syntax}Package Specification Syntax}
\label{\detokenize{package_components:package-specification-syntax}}
The package specification defines the user interface for a package (the
API). The specification lists the functions, procedures, types,
exceptions and cursors that are visible to a user of the package.

The syntax used to define the interface for a package is:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
CREATE [ OR REPLACE ] PACKAGE \PYGZlt{}package\PYGZus{}name\PYGZgt{}
[ \PYGZlt{}authorization\PYGZus{}clause\PYGZgt{} ]
\PYGZob{} IS \textbar{} AS \PYGZcb{}
[ \PYGZlt{}declaration\PYGZgt{}; ] ...
[ \PYGZlt{}procedure\PYGZus{}or\PYGZus{}function\PYGZus{}declaration\PYGZgt{} ] ...
END [ \PYGZlt{}package\PYGZus{}name\PYGZgt{} ] ;
\end{sphinxVerbatim}

Where \sphinxcode{\textless{}authorization\_clause\textgreater{}} :=
\begin{quote}

\{ \sphinxcode{AUTHID DEFINER \} \textbar{} \{ AUTHID CURRENT\_USER} \}
\end{quote}

Where \sphinxcode{\textless{}procedure\_or\_function\_declaration\textgreater{}} :=
\begin{quote}

\sphinxcode{\textless{}procedure\_declaration\textgreater{} \textbar{} \textless{}function\_declaration\textgreater{}}
\end{quote}

Where \sphinxcode{\textless{}procedure\_declaration\textgreater{}} :=
\begin{quote}

\sphinxcode{PROCEDURE \textless{}proc\_name\textgreater{} {[} \textless{}argument\_list\textgreater{} {]}};
\sphinxcode{{[} \textless{}restriction\_pragma\textgreater{}; {]}}
\end{quote}

Where \sphinxcode{\textless{}function\_declaration\textgreater{}} :=
\begin{quote}

\sphinxcode{FUNCTION \textless{}func\_name\textgreater{} {[} \textless{}argument\_list\textgreater{} {]}}

\sphinxcode{RETURN \textless{}rettype\textgreater{} {[} DETERMINISTIC {]}};
{[} \sphinxcode{\textless{}restriction\_pragma\textgreater{}}; {]}
\end{quote}

Where \sphinxcode{\textless{}argument\_list\textgreater{}} :=
\begin{quote}

( \sphinxcode{\textless{}argument\_declaration\textgreater{}} {[}, …{]} )
\end{quote}

Where \sphinxcode{\textless{}argument\_declaration\textgreater{}} :=
\begin{quote}

\sphinxcode{\textless{}argname\textgreater{} {[} IN \textbar{} IN OUT \textbar{} OUT {]} \textless{}argtype\textgreater{} {[} DEFAULT \textless{}value\textgreater{} {]}}
\end{quote}

Where \sphinxcode{\textless{}restriction\_pragma\textgreater{}} :=
\begin{quote}

\sphinxcode{PRAGMA RESTRICT\_REFERENCES ( \textless{}name\textgreater{}, \textless{}restrictions\textgreater{})}
\end{quote}

Where \sphinxcode{\textless{}restrictions\textgreater{}} :=
\begin{quote}

\sphinxcode{\textless{}restriction\textgreater{}} {[}, … {]}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}package\_name\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}package\_name\textgreater{}} is an identifier assigned to the package - each
package must have a name unique within the schema.
\end{quote}

\sphinxcode{AUTHID DEFINER}
\begin{quote}

If you omit the \sphinxcode{AUTHID} clause or specify \sphinxcode{AUTHID DEFINER}, the
privileges of the package owner are used to determine access
privileges to database objects.
\end{quote}

\sphinxcode{AUTHID CURRENT\_USER}
\begin{quote}

If you specify \sphinxcode{AUTHID CURRENT\_USER}, the privileges of the current
user executing a program in the package are used to determine access
privileges.
\end{quote}

\sphinxcode{\textless{}declaration\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}declaration\textgreater{}} is an identifier of a public variable. A public
variable can be accessed from outside of the package using the
syntax \sphinxcode{\textless{}package\_name.variable\textgreater{}}. There can be zero, one, or more
public variables. Public variable definitions must come before
procedure or function declarations.

\sphinxcode{\textless{}declaration\textgreater{}} can be any of the following:
\end{quote}
\begin{itemize}
\item {} 
Variable Declaration

\item {} 
Record Declaration

\item {} 
Collection Declaration

\item {} 
\sphinxcode{REF CURSOR} and Cursor Variable Declaration

\item {} 
\sphinxcode{TYPE} Definitions for Records, Collections, and \sphinxcode{REF CURSORs}

\item {} 
Exception

\item {} 
Object Variable Declaration

\end{itemize}

\sphinxcode{\textless{}proc\_name\textgreater{}}

The name of a public procedure.

\sphinxcode{\textless{}argname\textgreater{}}

The name of an argument. The argument is referenced by this name within
the function or procedure body.

\sphinxcode{IN \textbar{} IN OUT \textbar{} OUT}

The argument mode. \sphinxcode{IN} declares the argument for input only. This is the
default. \sphinxcode{IN OUT} allows the argument to receive a value as well as return
a value. \sphinxcode{OUT} specifies the argument is for output only.

\sphinxcode{\textless{}argtype\textgreater{}}

The data type(s) of an argument. An argument type may be a base data
type, a copy of the type of an existing column using \sphinxcode{\%TYPE}, or a
user-defined type such as a nested table or an object type. A length
must not be specified for any base type - for example, specify \sphinxcode{VARCHAR2},
not \sphinxcode{VARCHAR2(10}).

The type of a column is referenced by writing \sphinxcode{\textless{}tablename.columnname\textgreater{}} \sphinxcode{\%TYPE};
using this can sometimes help make a procedure independent from changes to the definition of a table.

\sphinxcode{DEFAULT \textless{}value\textgreater{}}

The \sphinxcode{DEFAULT} clause supplies a default value for an input argument if one
is not supplied in the invocation. \sphinxcode{DEFAULT} may not be specified for
arguments with modes \sphinxcode{IN OUT} or \sphinxcode{OUT}.

\newpage

\sphinxcode{\textless{}func\_name\textgreater{}}

The name of a public function.

\sphinxcode{\textless{}rettype\textgreater{}}

The return data type.

\sphinxcode{DETERMINISTIC}

\sphinxcode{DETERMINISTIC} is a synonym for \sphinxcode{IMMUTABLE}. A \sphinxcode{DETERMINISTIC} function
cannot modify the database and always reaches the same result when given
the same argument values; it does not do database lookups or otherwise
use information not directly present in its argument list. If you
include this clause, any call of the function with all-constant
arguments can be immediately replaced with the function value.

\sphinxcode{\textless{}restriction\textgreater{}}
\begin{quote}

The following keywords are accepted for compatibility and ignored:

\sphinxcode{RNDS}

\sphinxcode{RNPS}

\sphinxcode{TRUST}

\sphinxcode{WNDS}

\sphinxcode{WNPS}
\end{quote}

\newpage


\subsection{\index{Package Body Syntax}Package Body Syntax}
\label{\detokenize{package_components:package-body-syntax}}
Package implementation details reside in the package body; the package
body may contain objects that are not visible to the package user.
Advanced Server supports the following syntax for the package body:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
CREATE [ OR REPLACE ] PACKAGE BODY \PYGZlt{}package\PYGZus{}name\PYGZgt{}
  \PYGZob{} IS \textbar{} AS \PYGZcb{}
  [ \PYGZlt{}private\PYGZus{}declaration\PYGZgt{}; ] ...
  [ \PYGZlt{}procedure\PYGZus{}or\PYGZus{}function\PYGZus{}definition\PYGZgt{} ] ...
  [ \PYGZlt{}package\PYGZus{}initializer\PYGZgt{} ]
  END [ \PYGZlt{}package\PYGZus{}name\PYGZgt{} ] ;
\end{sphinxVerbatim}

Where \sphinxcode{\textless{}procedure\_or\_function\_definition\textgreater{}} :=
\begin{quote}

\sphinxcode{\textless{}procedure\_definition\textgreater{} \textbar{} \textless{}function\_definition\textgreater{}}
\end{quote}

Where \sphinxcode{\textless{}procedure\_definition\textgreater{}} :=
\begin{quote}

\sphinxcode{PROCEDURE \textless{}proc\_name\textgreater{} {[} \textless{}argument\_list\textgreater{} {]}}
\begin{quote}

\sphinxcode{{[} \textless{}options\_list\textgreater{} {]}}

\sphinxcode{\{ IS \textbar{} AS \}}
\begin{quote}

\sphinxcode{\textless{}procedure\_body\textgreater{}}
\end{quote}

\sphinxcode{END {[} \textless{}proc\_name\textgreater{}} {]} ;
\end{quote}
\end{quote}

Where \sphinxcode{\textless{}procedure\_body\textgreater{}} :=
\begin{quote}

\sphinxcode{{[} PRAGMA AUTONOMOUS\_TRANSACTION; {]}}

{[} \sphinxcode{\textless{}declaration\textgreater{}}; {]} {[}, …{]}

\sphinxcode{BEGIN}
\begin{quote}

\sphinxcode{\textless{}statement\textgreater{}}; {[}…{]}

\sphinxcode{{[} EXCEPTION}
\begin{quote}

\sphinxcode{\{WHEN \textless{}exception\textgreater{} {[}OR \textless{}exception\textgreater{}{]} {[}...{]}{]} THEN \textless{}statement\textgreater{}; \}}
\end{quote}

{[}…{]}
\end{quote}

{]}
\end{quote}

Where \sphinxcode{\textless{}function\_definition\textgreater{}} :=
\begin{quote}

\sphinxcode{FUNCTION \textless{}func\_name\textgreater{} {[} \textless{}argument\_list\textgreater{} {]}}
\begin{quote}

\sphinxcode{RETURN \textless{}rettype\textgreater{} {[} DETERMINISTIC {]}}

\sphinxcode{{[} \textless{}options\_list\textgreater{} {]}}

\sphinxcode{\{ IS \textbar{} AS \}}

\sphinxcode{\textless{}function\_body\textgreater{}}

\sphinxcode{END {[} \textless{}func\_name\textgreater{}} {]} ;
\end{quote}
\end{quote}

Where \sphinxcode{\textless{}function\_body\textgreater{}} :=
\begin{quote}

\sphinxcode{{[} PRAGMA AUTONOMOUS\_TRANSACTION; {]}}

{[} \sphinxcode{\textless{}declaration\textgreater{}}; {]} {[}, …{]}

\sphinxcode{BEGIN}
\begin{quote}

\sphinxcode{\textless{}statement\textgreater{}}; {[}…{]}
\end{quote}

{[} \sphinxcode{EXCEPTION}
\begin{quote}

\{ \sphinxcode{WHEN \textless{}exception\textgreater{} {[} OR \textless{}exception\textgreater{} {]} {[}...{]} THEN \textless{}statement\textgreater{}; \}}

{[}…{]}
\end{quote}

{]}
\end{quote}

Where \sphinxcode{\textless{}argument\_list\textgreater{}} :=
\begin{quote}

( \sphinxcode{\textless{}argument\_declaration\textgreater{}} {[}, …{]} )
\end{quote}

Where \sphinxcode{\textless{}argument\_declaration\textgreater{}} :=
\begin{quote}

\sphinxcode{\textless{}argname\textgreater{}} {[} \sphinxcode{IN \textbar{} IN OUT \textbar{} OUT} {]} \sphinxcode{\textless{}argtype\textgreater{} {[} DEFAULT \textless{}value\textgreater{} {]}}
\end{quote}

Where \sphinxcode{\textless{}options\_list\textgreater{}} :=
\begin{quote}

\sphinxcode{\textless{}option\textgreater{}} {[} … {]}
\end{quote}

Where \sphinxcode{\textless{}option\textgreater{}} :=
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{STRICT}
\item[] \sphinxcode{LEAKPROOF}
\end{DUlineblock}

\sphinxcode{PARALLEL \{ UNSAFE \textbar{} RESTRICTED \textbar{} SAFE \}}

\sphinxcode{COST \textless{}execution\_cost\textgreater{}}

\sphinxcode{ROWS \textless{}result\_rows\textgreater{}}

\sphinxcode{SET \textless{}config\_param\textgreater{} \{ TO \textless{}value\textgreater{} \textbar{} = \textless{}value\textgreater{} \textbar{} FROM CURRENT} \}
\end{quote}

Where \sphinxcode{\textless{}package\_initializer\textgreater{}} :=
\begin{quote}

\sphinxcode{BEGIN}
\begin{quote}

\sphinxcode{\textless{}statement;\textgreater{}} {[}…{]}
\end{quote}

\sphinxcode{END;}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}package\_name\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}package\_name\textgreater{}} is the name of the package for which this is the
package body. There must be an existing package specification with
this name.
\end{quote}

\sphinxcode{\textless{}private\_declaration\textgreater{}}
\begin{quote}
\begin{quote}

\sphinxcode{\textless{}private\_declaration\textgreater{}} is an identifier of a private variable that
can be accessed by any procedure or function within the package.
There can be zero, one, or more private variables.
\sphinxcode{\textless{}private\_declaration\textgreater{}} can be any of the following:
\end{quote}
\begin{itemize}
\item {} 
Variable Declaration

\item {} 
Record Declaration

\item {} 
Collection Declaration

\item {} 
\sphinxcode{REF CURSOR} and Cursor Variable Declaration

\item {} 
\sphinxcode{TYPE} Definitions for Records, Collections, and \sphinxcode{REF CURSORs}

\item {} 
Exception

\item {} 
Object Variable Declaration

\end{itemize}
\end{quote}

\sphinxcode{\textless{}proc\_name\textgreater{}}
\begin{quote}

The name of the procedure being created.
\end{quote}

\sphinxcode{PRAGMA AUTONOMOUS\_TRANSACTION}
\begin{quote}

\sphinxcode{PRAGMA AUTONOMOUS\_TRANSACTION} is the directive that sets the procedure
as an autonomous transaction.
\end{quote}

\sphinxcode{\textless{}declaration\textgreater{}}
\begin{quote}

A variable, type, \sphinxcode{REF CURSOR}, or subprogram declaration. If subprogram
declarations are included, they must be declared after all other
variable, type, and \sphinxcode{REF CURSOR} declarations.
\end{quote}

\sphinxcode{\textless{}statement\textgreater{}}
\begin{quote}

An SPL program statement. Note that a \sphinxcode{DECLARE - BEGIN - END} block is
considered an SPL statement unto itself. Thus, the function body may
contain nested blocks.
\end{quote}

\sphinxcode{\textless{}exception\textgreater{}}
\begin{quote}

An exception condition name such as \sphinxcode{NO\_DATA\_FOUND, OTHERS}, etc.
\end{quote}

\sphinxcode{\textless{}func\_name\textgreater{}}
\begin{quote}

The name of the function being created.
\end{quote}

\sphinxcode{\textless{}rettype\textgreater{}}
\begin{quote}

The return data type, which may be any of the types listed for
\sphinxcode{\textless{}argtype\textgreater{}}. As for \sphinxcode{\textless{}argtype\textgreater{}}, a length must not be specified for
\sphinxcode{\textless{}rettype\textgreater{}}.
\end{quote}

\sphinxcode{DETERMINISTIC}
\begin{quote}

Include \sphinxcode{DETERMINISTIC} to specify that the function will always return
the same result when given the same argument values. A \sphinxcode{DETERMINISTIC}
function must not modify the database.

\begin{sphinxadmonition}{note}{Note:}
The \sphinxcode{DETERMINISTIC} keyword is equivalent to the PostgreSQL \sphinxcode{IMMUTABLE} option.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
If \sphinxcode{DETERMINISTIC} is specified for a public function in the package body, it must also be specified for the function declaration in the package specification. (For private functions, there is no function declaration in the package specification.)
\end{sphinxadmonition}
\end{quote}

\sphinxcode{PRAGMA AUTONOMOUS\_TRANSACTION}
\begin{quote}

\sphinxcode{PRAGMA AUTONOMOUS\_TRANSACTION} is the directive that sets the function as an autonomous transaction.
\end{quote}

\sphinxcode{\textless{}declaration\textgreater{}}
\begin{quote}

A variable, type, \sphinxcode{REF CURSOR}, or subprogram declaration. If subprogram
declarations are included, they must be declared after all other
variable, type, and \sphinxcode{REF CURSOR} declarations.
\end{quote}

\sphinxcode{\textless{}argname\textgreater{}}
\begin{quote}

The name of a formal argument. The argument is referenced by this name
within the procedure body.
\end{quote}

\sphinxcode{IN \textbar{} IN OUT \textbar{} OUT}
\begin{quote}

The argument mode. IN declares the argument for input only. This is the
default. IN OUT allows the argument to receive a value as well as return
a value. OUT specifies the argument is for output only.
\end{quote}

\newpage

\sphinxcode{\textless{}argtype\textgreater{}}
\begin{quote}

The data type(s) of an argument. An argument type may be a base data
type, a copy of the type of an existing column using \sphinxcode{\%TYPE}, or a
user-defined type such as a nested table or an object type. A length
must not be specified for any base type - for example, specify \sphinxcode{VARCHAR2},
not \sphinxcode{VARCHAR2(10)}.

The type of a column is referenced by writing
\sphinxcode{\textless{}tablename\textgreater{}. \textless{}columnname\textgreater{}{}`\%TYPE}; using this can sometimes help make a
procedure independent from changes to the definition of a table.
\end{quote}

\sphinxcode{DEFAULT \textless{}value\textgreater{}}
\begin{quote}

The \sphinxcode{DEFAULT} clause supplies a default value for an input argument if one
is not supplied in the procedure call. \sphinxcode{DEFAULT} may not be specified for
arguments with modes \sphinxcode{IN OUT} or \sphinxcode{OUT}.

Please note: the following options are not compatible with Oracle
databases; they are extensions to Oracle package syntax provided by
Advanced Server only.
\end{quote}

\sphinxcode{STRICT}
\begin{quote}

The \sphinxcode{STRICT} keyword specifies that the function will not be executed
if called with a \sphinxcode{NULL} argument; instead the function will return
\sphinxcode{NULL}.
\end{quote}

\sphinxcode{LEAKPROOF}
\begin{quote}

The \sphinxcode{LEAKPROOF} keyword specifies that the function will not reveal
any information about arguments, other than through a return value.
\end{quote}

\sphinxcode{PARALLEL \{ UNSAFE \textbar{} RESTRICTED \textbar{} SAFE \}}
\begin{quote}

The \sphinxcode{PARALLEL} clause enables the use of parallel sequential scans
(parallel mode). A parallel sequential scan uses multiple workers to
scan a relation in parallel during a query in contrast to a serial
sequential scan.

When set to \sphinxcode{UNSAFE}, the procedure or function cannot be executed in
parallel mode. The presence of such a procedure or function forces a
serial execution plan. This is the default setting if the \sphinxcode{PARALLEL}
clause is omitted.

When set to \sphinxcode{RESTRICTED}, the procedure or function can be executed in
parallel mode, but the execution is restricted to the parallel group
leader. If the qualification for any particular relation has
anything that is parallel restricted, that relation won’t be chosen
for parallelism.

When set to \sphinxcode{SAFE}, the procedure or function can be executed in
parallel mode with no restriction.
\end{quote}

\sphinxcode{\textless{}execution\_cost\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}execution\_cost\textgreater{}} specifies a positive number giving the estimated
execution cost for the function, in units of \sphinxcode{cpu\_operator\_cost}. If
the function returns a set, this is the cost per returned row. The
default is \sphinxcode{0.0025}.
\end{quote}

\sphinxcode{{}`\textless{}result\_rows\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}result\_rows\textgreater{}} is the estimated number of rows that the query
planner should expect the function to return. The default is \sphinxcode{1000}.
\end{quote}

\sphinxcode{SET}
\begin{quote}

Use the \sphinxcode{SET} clause to specify a parameter value for the duration of
the function:

\sphinxcode{\textless{}config\_param\textgreater{}} specifies the parameter name.

\sphinxcode{\textless{}value\textgreater{}} specifies the parameter value.

\sphinxcode{FROM CURRENT} guarantees that the parameter value is restored when
the function ends.
\end{quote}

\newpage

\sphinxcode{\textless{}package\_initializer\textgreater{}}
\begin{quote}
\begin{quote}

The statements in the \sphinxcode{\textless{}package\_initializer\textgreater{}} are executed once per
user’s session when the package is first referenced.
\end{quote}

\begin{sphinxadmonition}{note}{Note:}
The \sphinxcode{STRICT, LEAKPROOF, PARALLEL, COST, ROWS} and \sphinxcode{SET} keywords provide extended functionality for Advanced Server and are not supported by Oracle.
\end{sphinxadmonition}
\end{quote}

\newpage


\section{\index{Creating Packages}Creating Packages}
\label{\detokenize{creating_packages::doc}}\label{\detokenize{creating_packages:creating-packages}}
A package is not an executable piece of code; rather it is a repository
of code. When you use a package, you actually execute or make reference
to an element within a package.


\subsection{\index{Creating the Package Specification}Creating the Package Specification}
\label{\detokenize{creating_packages:creating-the-package-specification}}
The package specification contains the definition of all the elements in
the package that can be referenced from outside of the package. These
are called the public elements of the package, and they act as the
package interface. The following code sample is a package specification:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZhy{}\PYGZhy{}
\PYGZhy{}\PYGZhy{} Package specification for the \PYGZsq{}emp\PYGZus{}admin\PYGZsq{} package.
\PYGZhy{}\PYGZhy{}
CREATE OR REPLACE PACKAGE emp\PYGZus{}admin
IS
   FUNCTION get\PYGZus{}dept\PYGZus{}name (
     p\PYGZus{}deptno NUMBER DEFAULT 10
)
   RETURN VARCHAR2;
   FUNCTION update\PYGZus{}emp\PYGZus{}sal (
     p\PYGZus{}empno NUMBER,
     p\PYGZus{}raise NUMBER
)
   RETURN NUMBER;
   PROCEDURE hire\PYGZus{}emp (
     p\PYGZus{}empno           NUMBER,
     p\PYGZus{}ename           VARCHAR2,
     p\PYGZus{}job             VARCHAR2,
     p\PYGZus{}sal             NUMBER,
     p\PYGZus{}hiredate        DATE      DEFAULT   sysdate,
     p\PYGZus{}comm            NUMBER    DEFAULT   0,
     p\PYGZus{}mgr             NUMBER,
     p\PYGZus{}deptno          NUMBER    DEFAULT   10
    );
   PROCEDURE fire\PYGZus{}emp (
     p\PYGZus{}empno NUMBER
);
END emp\PYGZus{}admin;
\end{sphinxVerbatim}

This code sample creates the \sphinxcode{emp\_admin} package specification. This
package specification consists of two functions and two stored
procedures. We can also add the \sphinxcode{OR REPLACE} clause to the \sphinxcode{CREATE PACKAGE}
statement for convenience.

\newpage


\subsection{\index{Creating the Package Body}Creating the Package Body}
\label{\detokenize{creating_packages:creating-the-package-body}}
The body of the package contains the actual implementation behind the
package specification. For the above \sphinxcode{emp\_admin} package specification,
we shall now create a package body which will implement the
specifications. The body will contain the implementation of the
functions and stored procedures in the specification.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZhy{}\PYGZhy{}
\PYGZhy{}\PYGZhy{} Package body for the \PYGZsq{}emp\PYGZus{}admin\PYGZsq{} package.
\PYGZhy{}\PYGZhy{}
CREATE OR REPLACE PACKAGE BODY emp\PYGZus{}admin
IS
\PYGZhy{}\PYGZhy{}
    \PYGZhy{}\PYGZhy{} Function that queries the \PYGZsq{}dept\PYGZsq{} table based on the department
    \PYGZhy{}\PYGZhy{} number and returns the corresponding department name.
    \PYGZhy{}\PYGZhy{}
    FUNCTION get\PYGZus{}dept\PYGZus{}name (
        p\PYGZus{}deptno IN NUMBER DEFAULT 10
    )
    RETURN VARCHAR2
    IS
        v\PYGZus{}dname VARCHAR2(14);
    BEGIN
        SELECT dname INTO v\PYGZus{}dname FROM dept WHERE deptno = p\PYGZus{}deptno;
        RETURN v\PYGZus{}dname;
    EXCEPTION
        WHEN NO\PYGZus{}DATA\PYGZus{}FOUND THEN
            DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Invalid department number \PYGZsq{} \textbar{}\textbar{} p\PYGZus{}deptno);
            RETURN \PYGZsq{}\PYGZsq{};
    END;
    \PYGZhy{}\PYGZhy{}
    \PYGZhy{}\PYGZhy{} Function that updates an employee\PYGZsq{}s salary based on the
    \PYGZhy{}\PYGZhy{} employee number and salary increment/decrement passed
    \PYGZhy{}\PYGZhy{} as IN parameters. Upon successful completion the function
    \PYGZhy{}\PYGZhy{} returns the new updated salary.
    \PYGZhy{}\PYGZhy{}
    FUNCTION update\PYGZus{}emp\PYGZus{}sal (
        p\PYGZus{}empno        IN NUMBER,
        p\PYGZus{}raise        IN NUMBER
    )
    RETURN NUMBER
    IS
        v\PYGZus{}sal          NUMBER := 0;
    BEGIN
        SELECT sal INTO v\PYGZus{}sal FROM emp WHERE empno = p\PYGZus{}empno;
        v\PYGZus{}sal := v\PYGZus{}sal + p\PYGZus{}raise;
        UPDATE emp SET sal = v\PYGZus{}sal WHERE empno = p\PYGZus{}empno;
        RETURN v\PYGZus{}sal;
    EXCEPTION
      WHEN NO\PYGZus{}DATA\PYGZus{}FOUND THEN
          DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Employee \PYGZsq{} \textbar{}\textbar{} p\PYGZus{}empno \textbar{}\textbar{} \PYGZsq{} not found\PYGZsq{});
          RETURN \PYGZhy{}1;
      WHEN OTHERS THEN
          DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}The following is SQLERRM:\PYGZsq{});
          DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(SQLERRM);
          DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}The following is SQLCODE:\PYGZsq{});
          DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(SQLCODE);
          RETURN \PYGZhy{}1;
    END;
    \PYGZhy{}\PYGZhy{}
    \PYGZhy{}\PYGZhy{} Procedure that inserts a new employee record into the \PYGZsq{}emp\PYGZsq{} table.
    \PYGZhy{}\PYGZhy{}
       PROCEDURE hire\PYGZus{}emp (
       p\PYGZus{}empno            NUMBER,
       p\PYGZus{}ename            VARCHAR2,
       p\PYGZus{}job              VARCHAR2,
       p\PYGZus{}sal              NUMBER,
       p\PYGZus{}hiredate         DATE   DEFAULT sysdate,
       p\PYGZus{}comm             NUMBER DEFAULT 0,
       p\PYGZus{}mgr              NUMBER,
       p\PYGZus{}deptno           NUMBER DEFAULT 10
    )
    AS
    BEGIN
       INSERT INTO emp(empno, ename, job, sal, hiredate, comm, mgr, deptno)
          VALUES(p\PYGZus{}empno, p\PYGZus{}ename, p\PYGZus{}job, p\PYGZus{}sal,
                 p\PYGZus{}hiredate, p\PYGZus{}comm, p\PYGZus{}mgr, p\PYGZus{}deptno);
    END;
    \PYGZhy{}\PYGZhy{}
    \PYGZhy{}\PYGZhy{} Procedure that deletes an employee record from the \PYGZsq{}emp\PYGZsq{} table based
    \PYGZhy{}\PYGZhy{} on the employee number.
    \PYGZhy{}\PYGZhy{}
    PROCEDURE fire\PYGZus{}emp (
        p\PYGZus{}empno NUMBER
    )
    AS
    BEGIN
        DELETE FROM emp WHERE empno = p\PYGZus{}empno;
    END;
  END;
\end{sphinxVerbatim}

\newpage


\section{\index{Referencing a Package}Referencing a Package}
\label{\detokenize{referencing_a_package:referencing-a-package}}\label{\detokenize{referencing_a_package::doc}}
To reference the types, items and subprograms that are declared within a
package specification, we use the dot notation. For example:

\sphinxcode{\textless{}package\_name\textgreater{}.\textless{}type\_name\textgreater{}}

\sphinxcode{\textless{}package\_name\textgreater{}.\textless{}item\_name\textgreater{}}

\sphinxcode{\textless{}package\_name.\textless{}subprogram\_name}

To invoke a function from the \sphinxcode{emp\_admin} package specification, we will
execute the following SQL command.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
SELECT emp\PYGZus{}admin.get\PYGZus{}dept\PYGZus{}name(10) FROM DUAL;
\end{sphinxVerbatim}

Here we are invoking the \sphinxcode{get\_dept\_name} function declared within the
package \sphinxcode{emp\_admin}. We are passing the department number as an argument
to the function, which will return the name of the department. Here the
value returned should be \sphinxcode{ACCOUNTING}, which corresponds to department
number \sphinxcode{10}.

\newpage


\section{\index{Using Packages With User Defined Types}Using Packages With User Defined Types}
\label{\detokenize{using_packages_with_user_defined_types:using-packages-with-user-defined-types}}\label{\detokenize{using_packages_with_user_defined_types::doc}}
The following example incorporates the various user-defined types
discussed in earlier chapters within the context of a package.

The package specification of \sphinxcode{emp\_rpt} shows the declaration of a record
type, \sphinxcode{emprec\_typ}, and a weakly-typed \sphinxcode{REF CURSOR, emp\_refcur}, as
publicly accessible along with two functions and two procedures.
Function, \sphinxcode{open\_emp\_by\_dept}, returns the \sphinxcode{REF CURSOR} type, \sphinxcode{EMP\_REFCUR}.
Procedures, \sphinxcode{fetch\_emp} and \sphinxcode{close\_refcur}, both declare a weakly-typed
\sphinxcode{REF CURSOR} as a formal parameter.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
CREATE OR REPLACE PACKAGE emp\PYGZus{}rpt
IS
   TYPE emprec\PYGZus{}typ IS RECORD (
       empno       NUMBER(4),
       ename       VARCHAR(10)
   );
   TYPE emp\PYGZus{}refcur IS REF CURSOR;

   FUNCTION get\PYGZus{}dept\PYGZus{}name (
       p\PYGZus{}deptno    IN NUMBER
   ) RETURN VARCHAR2;
   FUNCTION open\PYGZus{}emp\PYGZus{}by\PYGZus{}dept (
       p\PYGZus{}deptno    IN emp.deptno\PYGZpc{}TYPE
   ) RETURN EMP\PYGZus{}REFCUR;
   PROCEDURE fetch\PYGZus{}emp (
       p\PYGZus{}refcur    IN OUT SYS\PYGZus{}REFCURSOR
   );
   PROCEDURE close\PYGZus{}refcur (
       p\PYGZus{}refcur    IN OUT SYS\PYGZus{}REFCURSOR
   );
   END emp\PYGZus{}rpt;
\end{sphinxVerbatim}

The package body shows the declaration of several private variables - a
static cursor, \sphinxcode{dept\_cur}, a table type, \sphinxcode{depttab\_typ}, a table variable,
\sphinxcode{t\_dept}, an integer variable, \sphinxcode{t\_dept\_max}, and a record variable,
\sphinxcode{r\_emp}.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
CREATE OR REPLACE PACKAGE BODY emp\PYGZus{}rpt
IS
    CURSOR dept\PYGZus{}cur IS SELECT * FROM dept;
    TYPE depttab\PYGZus{}typ IS TABLE of dept\PYGZpc{}ROWTYPE
        INDEX BY BINARY\PYGZus{}INTEGER;
    t\PYGZus{}dept          DEPTTAB\PYGZus{}TYP;
    t\PYGZus{}dept\PYGZus{}max      INTEGER := 1;
    r\PYGZus{}emp           EMPREC\PYGZus{}TYP;

    FUNCTION get\PYGZus{}dept\PYGZus{}name (
        p\PYGZus{}deptno    IN NUMBER
    ) RETURN VARCHAR2
    IS
    BEGIN
        FOR i IN 1..t\PYGZus{}dept\PYGZus{}max LOOP
            IF p\PYGZus{}deptno = t\PYGZus{}dept(i).deptno THEN
                RETURN t\PYGZus{}dept(i).dname;
            END IF;
        END LOOP;
        RETURN \PYGZsq{}Unknown\PYGZsq{};
  END;
  FUNCTION open\PYGZus{}emp\PYGZus{}by\PYGZus{}dept(
    p\PYGZus{}deptno        IN emp.deptno\PYGZpc{}TYPE
  ) RETURN EMP\PYGZus{}REFCUR
  IS
    emp\PYGZus{}by\PYGZus{}dept EMP\PYGZus{}REFCUR;
  BEGIN
    OPEN emp\PYGZus{}by\PYGZus{}dept FOR SELECT empno, ename FROM emp
        WHERE deptno = p\PYGZus{}deptno;
    RETURN emp\PYGZus{}by\PYGZus{}dept;
  END;

  PROCEDURE fetch\PYGZus{}emp (
      p\PYGZus{}refcur      IN OUT SYS\PYGZus{}REFCURSOR
  )
  IS
  BEGIN
      DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}EMPNO ENAME\PYGZsq{});
      DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZsq{});
      LOOP
          FETCH p\PYGZus{}refcur INTO r\PYGZus{}emp;
          EXIT WHEN p\PYGZus{}refcur\PYGZpc{}NOTFOUND;
          DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(r\PYGZus{}emp.empno \textbar{}\textbar{} \PYGZsq{} \PYGZsq{} \textbar{}\textbar{} r\PYGZus{}emp.ename);
      END LOOP;
  END;

  PROCEDURE close\PYGZus{}refcur (
      p\PYGZus{}refcur      IN OUT SYS\PYGZus{}REFCURSOR
  )
  IS
  BEGIN
      CLOSE p\PYGZus{}refcur;
  END;
BEGIN
  OPEN dept\PYGZus{}cur;
  LOOP
      FETCH dept\PYGZus{}cur INTO t\PYGZus{}dept(t\PYGZus{}dept\PYGZus{}max);
      EXIT WHEN dept\PYGZus{}cur\PYGZpc{}NOTFOUND;
      t\PYGZus{}dept\PYGZus{}max := t\PYGZus{}dept\PYGZus{}max + 1;
  END LOOP;
  CLOSE dept\PYGZus{}cur;
  t\PYGZus{}dept\PYGZus{}max := t\PYGZus{}dept\PYGZus{}max \PYGZhy{} 1;
END emp\PYGZus{}rpt;
\end{sphinxVerbatim}

This package contains an initialization section that loads the private
table variable, \sphinxcode{t\_dept}, using the private static cursor, \sphinxcode{dept\_cur.t\_dept} serves as a department name lookup table in function,
\sphinxcode{get\_dept\_name}.

Function, \sphinxcode{open\_emp\_by\_dept} returns a \sphinxcode{REF CURSOR} variable for a result
set of employee numbers and names for a given department. This \sphinxcode{REF
CURSOR} variable can then be passed to procedure, \sphinxcode{fetch\_emp}, to retrieve
and list the individual rows of the result set. Finally, procedure,
\sphinxcode{close\_refcur}, can be used to close the \sphinxcode{REF CURSOR} variable associated
with this result set.

The following anonymous block runs the package function and procedures.
In the anonymous block’s declaration section, note the declaration of
cursor variable, \sphinxcode{v\_emp\_cur}, using the package’s public \sphinxcode{REF CURSOR}
type, \sphinxcode{EMP\_REFCUR. v\_emp\_cur} contains the pointer to the result set
that is passed between the package function and procedures.

\newpage

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
   v\PYGZus{}deptno dept.deptno\PYGZpc{}TYPE DEFAULT 30;
   v\PYGZus{}emp\PYGZus{}cur emp\PYGZus{}rpt.EMP\PYGZus{}REFCUR;
BEGIN
   v\PYGZus{}emp\PYGZus{}cur := emp\PYGZus{}rpt.open\PYGZus{}emp\PYGZus{}by\PYGZus{}dept(v\PYGZus{}deptno);
   DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}EMPLOYEES IN DEPT \PYGZsh{}\PYGZsq{} \textbar{}\textbar{} v\PYGZus{}deptno \textbar{}\textbar{}
       \PYGZsq{}: \PYGZsq{} \textbar{}\textbar{} emp\PYGZus{}rpt.get\PYGZus{}dept\PYGZus{}name(v\PYGZus{}deptno));
   emp\PYGZus{}rpt.fetch\PYGZus{}emp(v\PYGZus{}emp\PYGZus{}cur);
   DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}**********************\PYGZsq{});
   DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(v\PYGZus{}emp\PYGZus{}cur\PYGZpc{}ROWCOUNT \textbar{}\textbar{} \PYGZsq{} rows were
   retrieved\PYGZsq{});
   emp\PYGZus{}rpt.close\PYGZus{}refcur(v\PYGZus{}emp\PYGZus{}cur);
END;
\end{sphinxVerbatim}

The following is the result of this anonymous block.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
EMPLOYEES IN DEPT \PYGZsh{}30: SALES
EMPNO ENAME
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
7499 ALLEN
7521 WARD
7654 MARTIN
7698 BLAKE
7844 TURNER
7900 JAMES
**********************
6 rows were retrieved
\end{sphinxVerbatim}

The following anonymous block illustrates another means of achieving the
same result. Instead of using the package procedures, \sphinxcode{fetch\_emp} and
\sphinxcode{close\_refcur}, the logic of these programs is coded directly into the
anonymous block. In the anonymous block’s declaration section, note the
addition of record variable, \sphinxcode{r\_emp}, declared using the package’s public
record type, \sphinxcode{EMPREC\_TYP}.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    v\PYGZus{}deptno     dept.deptno\PYGZpc{}TYPE DEFAULT 30;
    v\PYGZus{}emp\PYGZus{}cur    emp\PYGZus{}rpt.EMP\PYGZus{}REFCUR;
    r\PYGZus{}emp        emp\PYGZus{}rpt.EMPREC\PYGZus{}TYP;
BEGIN
   v\PYGZus{}emp\PYGZus{}cur := emp\PYGZus{}rpt.open\PYGZus{}emp\PYGZus{}by\PYGZus{}dept(v\PYGZus{}deptno);
   DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}EMPLOYEES IN DEPT \PYGZsh{}\PYGZsq{} \textbar{}\textbar{} v\PYGZus{}deptno \textbar{}\textbar{}
       \PYGZsq{}: \PYGZsq{} \textbar{}\textbar{} emp\PYGZus{}rpt.get\PYGZus{}dept\PYGZus{}name(v\PYGZus{}deptno));
   DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}EMPNO ENAME\PYGZsq{});
   DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZsq{});
   LOOP
       FETCH v\PYGZus{}emp\PYGZus{}cur INTO r\PYGZus{}emp;
       EXIT WHEN v\PYGZus{}emp\PYGZus{}cur\PYGZpc{}NOTFOUND;
       DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(r\PYGZus{}emp.empno \textbar{}\textbar{} \PYGZsq{} \PYGZsq{} \textbar{}\textbar{}
       r\PYGZus{}emp.ename);
   END LOOP;
   DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}**********************\PYGZsq{});
   DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(v\PYGZus{}emp\PYGZus{}cur\PYGZpc{}ROWCOUNT \textbar{}\textbar{} \PYGZsq{} rows were retrieved\PYGZsq{});
   CLOSE v\PYGZus{}emp\PYGZus{}cur;
END;
\end{sphinxVerbatim}

\newpage

The following is the result of this anonymous block.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
EMPLOYEES IN DEPT \PYGZsh{}30: SALES
EMPNO ENAME
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
7499 ALLEN
7521 WARD
7654 MARTIN
7698 BLAKE
7844 TURNER
7900 JAMES
**********************
6 rows were retrieved
\end{sphinxVerbatim}

\newpage


\section{\index{Dropping a Package}Dropping a Package}
\label{\detokenize{dropping_a_package::doc}}\label{\detokenize{dropping_a_package:dropping-a-package}}
The syntax for deleting an entire package or just the package body is as
follows:

\sphinxcode{DROP PACKAGE {[} BODY {]} \textless{}package\_name\textgreater{};}

If the keyword, \sphinxcode{BODY}, is omitted, both the package specification and the
package body are deleted - i.e., the entire package is dropped. If the
keyword, \sphinxcode{BODY}, is specified, then only the package body is dropped. The
package specification remains intact. \sphinxcode{\textless{}package\_name\textgreater{}} is the identifier
of the package to be dropped.

Following statement will destroy only the package body of \sphinxcode{\textless{}emp\_admin\textgreater{}}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DROP PACKAGE BODY emp\PYGZus{}admin;
\end{sphinxVerbatim}

The following statement will drop the entire \sphinxcode{\textless{}emp\_admin\textgreater{}} package:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DROP PACKAGE emp\PYGZus{}admin;
\end{sphinxVerbatim}

\newpage


\chapter{\index{Built-In Packages}Built-In Packages}
\label{\detokenize{built-in_packages::doc}}\label{\detokenize{built-in_packages:built-in-packages}}
This chapter describes the built-in packages that are provided with
Advanced Server. For certain packages, non-superusers must be explicitly
granted the \sphinxcode{EXECUTE} privilege on the package before using any of the
package’s functions or procedures. For most of the built-in packages,
\sphinxcode{EXECUTE} privilege has been granted to \sphinxcode{PUBLIC} by default.

For information about using the \sphinxcode{GRANT} command to provide access to a
package, please see the \sphinxstyleemphasis{Database Compatibility for Oracle Developers
Reference Guide}, available at:

\sphinxurl{https://www.enterprisedb.com/edb-docs}

All built-in packages are owned by the special \sphinxcode{sys} user which must be
specified when granting or revoking privileges on built-in packages:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
GRANT EXECUTE ON PACKAGE SYS.UTL\PYGZus{}FILE TO john;
\end{sphinxVerbatim}

\newpage


\section{\index{DBMS\_ALERT}DBMS\_ALERT}
\label{\detokenize{dbms_alert::doc}}\label{\detokenize{dbms_alert:dbms-alert}}
The \sphinxcode{DBMS\_ALERT} package provides the capability to register for, send,
and receive alerts. The following table lists the supported procedures:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

Function/Procedure
&
Return Type
&
Description
\\
\hline
\sphinxcode{REGISTER(\textless{}name\textgreater{})}
&
n/a
&
Register to be able to receive alerts named, \sphinxcode{\textless{}name\textgreater{}}
\\
\hline
\sphinxcode{REMOVE(\textless{}name\textgreater{})}
&
n/a
&
Remove registration for the alert named, \sphinxcode{\textless{}name\textgreater{}}
\\
\hline
\sphinxcode{REMOVEALL}
&
n/a
&
Remove registration for all alerts.
\\
\hline
\sphinxcode{SIGNAL(\textless{}name\textgreater{}, \textless{}message\textgreater{})}
&
n/a
&
Signals the alert named, \sphinxcode{\textless{}name\textgreater{}}, with \sphinxcode{\textless{}message\textgreater{}}
\\
\hline
\sphinxcode{WAITANY(\textless{}name\textgreater{} OUT, \textless{}message\textgreater{} OUT, \textless{}status\textgreater{} OUT, \textless{}timeout\textgreater{})}
&
n/a
&
Wait for any registered alert to occur.
\\
\hline
\sphinxcode{WAITONE(\textless{}name\textgreater{}, \textless{}message. OUT, \textless{}status\textgreater{} OUT, \textless{}timeout\textgreater{})}
&
n/a
&
Wait for the specified alert, \sphinxcode{\textless{}name\textgreater{}}, to occur.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Advanced Server’s implementation of \sphinxcode{DBMS\_ALERT} is a partial
implementation when compared to Oracle’s version. Only those functions
and procedures listed in the table above are supported.

Advanced Server allows a maximum of \sphinxcode{500} concurrent alerts. You can use
the \sphinxcode{dbms\_alert.max\_alerts} GUC variable (located in the \sphinxcode{postgresql.conf}
file) to specify the maximum number of concurrent alerts allowed on a
system.

To set a value for the \sphinxcode{dbms\_alert.max\_alerts} variable, open the
\sphinxcode{postgresql.conf} file (located by default in \sphinxcode{/opt/PostgresPlus/10AS/data})
with your choice of editor, and edit the \sphinxcode{dbms\_alert.max\_alerts}
parameter as shown:
\begin{quote}

\sphinxcode{dbms\_alert.max\_alerts = \textless{}alert\_count\textgreater{}}
\end{quote}

\sphinxcode{\textless{}alert\_count\textgreater{}}

\sphinxcode{alert\_count} specifies the maximum number of concurrent alerts. By
default, the value of \sphinxcode{dbms\_alert.max\_alerts} is \sphinxcode{100}. To disable this
feature, set \sphinxcode{dbms\_alert.max\_alerts} to \sphinxcode{0}.

For the \sphinxcode{dbms\_alert.max\_alerts} GUC to function correctly, the
\sphinxcode{custom\_variable\_classes} parameter must contain \sphinxcode{dbms\_alerts}:
\begin{quote}

\sphinxcode{custom\_variable\_classes = 'dbms\_alert, …'}
\end{quote}

After editing the \sphinxcode{postgresql.conf} file parameters, you must restart the
server for the changes to take effect.

\index{DBMS\_ALERT\_Register}\ignorespaces 

\subsection{REGISTER}
\label{\detokenize{dbms_alert:register}}\label{\detokenize{dbms_alert:index-1}}
The \sphinxcode{REGISTER} procedure enables the current session to be notified of the specified alert.
\begin{quote}

\sphinxcode{REGISTER(\textless{}name\textgreater{} VARCHAR2)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}name\textgreater{}}

Name of the alert to be registered.

\newpage

\sphinxstylestrong{Examples}

The following anonymous block registers for an alert named, \sphinxcode{alert\_test}, then waits for the signal.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
   v\PYGZus{}name           VARCHAR2(30) := \PYGZsq{}alert\PYGZus{}test\PYGZsq{};
   v\PYGZus{}msg            VARCHAR2(80);
   v\PYGZus{}status         INTEGER;
   v\PYGZus{}timeout        NUMBER(3) := 120;
BEGIN
   DBMS\PYGZus{}ALERT.REGISTER(v\PYGZus{}name);
   DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Registered for alert \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}name);
   DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Waiting for signal...\PYGZsq{});
   DBMS\PYGZus{}ALERT.WAITONE(v\PYGZus{}name,v\PYGZus{}msg,v\PYGZus{}status,v\PYGZus{}timeout);
   DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Alert name   : \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}name);
   DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Alert msg    : \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}msg);
   DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Alert status : \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}status);
   DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Alert timeout: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}timeout \textbar{}\textbar{} \PYGZsq{} seconds\PYGZsq{});
   DBMS\PYGZus{}ALERT.REMOVE(v\PYGZus{}name);
END;

Registered for alert alert\PYGZus{}test
Waiting for signal...
\end{sphinxVerbatim}

\index{DBMS\_ALERT\_Remove}\ignorespaces 

\subsection{REMOVE}
\label{\detokenize{dbms_alert:remove}}\label{\detokenize{dbms_alert:index-2}}
The \sphinxcode{REMOVE} procedure unregisters the session for the named alert.

\sphinxcode{REMOVE(\textless{}name\textgreater{} VARCHAR2)}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}name\textgreater{}}

Name of the alert to be unregistered.


\subsection{\index{REMOVEALL}REMOVEALL}
\label{\detokenize{dbms_alert:removeall}}
The \sphinxcode{REMOVEALL} procedure unregisters the session for all alerts.

\sphinxcode{REMOVEALL}


\subsection{\index{SIGNAL}SIGNAL}
\label{\detokenize{dbms_alert:signal}}
The \sphinxcode{SIGNAL} procedure signals the occurrence of the named alert.

\sphinxcode{SIGNAL(\textless{}name\textgreater{} VARCHAR2, \textless{}message\textgreater{} VARCHAR2)}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}name\textgreater{}}

Name of the alert.

\sphinxcode{\textless{}message\textgreater{}}

Information to pass with this alert.

\newpage

\sphinxstylestrong{Examples}

The following anonymous block signals an alert for \sphinxcode{alert\_test}.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    v\PYGZus{}name   VARCHAR2(30) := \PYGZsq{}alert\PYGZus{}test\PYGZsq{};
BEGIN
    DBMS\PYGZus{}ALERT.SIGNAL(v\PYGZus{}name,\PYGZsq{}This is the message from \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}name);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Issued alert for \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}name);
END;
Issued alert for alert\PYGZus{}test
\end{sphinxVerbatim}


\subsection{\index{WAITANY}WAITANY}
\label{\detokenize{dbms_alert:waitany}}
The \sphinxcode{WAITANY} procedure waits for any of the registered alerts to occur.

\sphinxcode{WAITANY(\textless{}name\textgreater{} OUT VARCHAR2, \textless{}message\textgreater{} OUT VARCHAR2},
\begin{quote}

\sphinxcode{\textless{}status\textgreater{} OUT INTEGER, \textless{}timeout\textgreater{} NUMBER)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}name\textgreater{}}

Variable receiving the name of the alert.

\sphinxcode{\textless{}message\textgreater{}}

Variable receiving the message sent by the \sphinxcode{SIGNAL} procedure.

\sphinxcode{\textless{}status\textgreater{}}

Status code returned by the operation. Possible values are: 0 \textendash{} alert occurred; 1 \textendash{} timeout occurred.

\sphinxcode{\textless{}timeout\textgreater{}}

Time to wait for an alert in seconds.

\sphinxstylestrong{Examples}

The following anonymous block uses the \sphinxcode{WAITANY} procedure to receive an alert named, \sphinxcode{alert\_test} or \sphinxcode{any\_alert}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    v\PYGZus{}name           VARCHAR2(30);
    v\PYGZus{}msg            VARCHAR2(80);
    v\PYGZus{}status         INTEGER;
    v\PYGZus{}timeout        NUMBER(3) := 120;
BEGIN
   DBMS\PYGZus{}ALERT.REGISTER(\PYGZsq{}alert\PYGZus{}test\PYGZsq{});
   DBMS\PYGZus{}ALERT.REGISTER(\PYGZsq{}any\PYGZus{}alert\PYGZsq{});
   DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Registered for alert alert\PYGZus{}test and any\PYGZus{}alert\PYGZsq{});
   DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Waiting for signal...\PYGZsq{});
   DBMS\PYGZus{}ALERT.WAITANY(v\PYGZus{}name,v\PYGZus{}msg,v\PYGZus{}status,v\PYGZus{}timeout);
   DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Alert name   : \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}name);
   DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Alert msg    : \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}msg);
   DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Alert status : \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}status);
   DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Alert timeout: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}timeout \textbar{}\textbar{} \PYGZsq{} seconds\PYGZsq{});
   DBMS\PYGZus{}ALERT.REMOVEALL;
END;

Registered for alert alert\PYGZus{}test and any\PYGZus{}alert
Waiting for signal...
\end{sphinxVerbatim}

An anonymous block in a second session issues a signal for \sphinxcode{any\_alert}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    v\PYGZus{}name   VARCHAR2(30) := \PYGZsq{}any\PYGZus{}alert\PYGZsq{};
BEGIN
   DBMS\PYGZus{}ALERT.SIGNAL(v\PYGZus{}name,\PYGZsq{}This is the message from \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}name);
   DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Issued alert for \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}name);
END;

Issued alert for any\PYGZus{}alert
\end{sphinxVerbatim}

Control returns to the first anonymous block and the remainder of the code is executed:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Registered for alert alert\PYGZus{}test and any\PYGZus{}alert
Waiting for signal...
Alert name   : any\PYGZus{}alert
Alert msg    : This is the message from any\PYGZus{}alert
Alert status : 0
Alert timeout: 120 seconds
\end{sphinxVerbatim}


\subsection{\index{WAITONE}WAITONE}
\label{\detokenize{dbms_alert:waitone}}
The \sphinxcode{WAITONE} procedure waits for the specified registered alert to occur.

\sphinxcode{WAITONE(\textless{}name\textgreater{} VARCHAR2, \textless{}message\textgreater{} OUT VARCHAR2},
\begin{quote}

\sphinxcode{\textless{}status\textgreater{} OUT INTEGER, \textless{}timeout\textgreater{} NUMBER})
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}name\textgreater{}}

Name of the alert.

\sphinxcode{\textless{}message\textgreater{}}
\begin{quote}

Variable receiving the message sent by the \sphinxcode{SIGNAL} procedure.
\end{quote}

\sphinxcode{\textless{}status\textgreater{}}
\begin{quote}

Status code returned by the operation. Possible values are: 0 \textendash{} alert
occurred; 1 \textendash{} timeout occurred.
\end{quote}

\sphinxcode{\textless{}timeout\textgreater{}}
\begin{quote}

Time to wait for an alert in seconds.
\end{quote}

\newpage

\sphinxstylestrong{Examples}

The following anonymous block is similar to the one used in the \sphinxcode{WAITANY}
example except the \sphinxcode{WAITONE} procedure is used to receive the alert named,
\sphinxcode{alert\_test}.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    v\PYGZus{}name           VARCHAR2(30) := \PYGZsq{}alert\PYGZus{}test\PYGZsq{};
    v\PYGZus{}msg            VARCHAR2(80);
    v\PYGZus{}status         INTEGER;
    v\PYGZus{}timeout        NUMBER(3) := 120;
BEGIN
   DBMS\PYGZus{}ALERT.REGISTER(v\PYGZus{}name);
   DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}  DBMS\PYGZus{}ALERT.REGISTER(v\PYGZus{}name);
   DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Registered for alert \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}name);
   DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Waiting for signal...\PYGZsq{});
   DBMS\PYGZus{}ALERT.WAITONE(v\PYGZus{}name,v\PYGZus{}msg,v\PYGZus{}status,v\PYGZus{}timeout);
   DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Alert name   : \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}name);
   DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Alert msg    : \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}msg);
   DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Alert status : \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}status);
   DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Alert timeout: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}timeout \textbar{}\textbar{} \PYGZsq{} seconds\PYGZsq{});
   DBMS\PYGZus{}ALERT.REMOVE(v\PYGZus{}name);LINE(\PYGZsq{}Registered for alert \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}name);
   DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Waiting for signal...\PYGZsq{});
   DBMS\PYGZus{}ALERT.WAITONE(v\PYGZus{}name,v\PYGZus{}msg,v\PYGZus{}status,v\PYGZus{}timeout);
   DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Alert name   : \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}name);
   DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Alert msg    : \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}msg);
   DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Alert status : \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}status);
   DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Alert timeout: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}timeout \textbar{}\textbar{} \PYGZsq{} seconds\PYGZsq{});
   DBMS\PYGZus{}ALERT.REMOVE(v\PYGZus{}name);
   END;

   Registered for alert alert\PYGZus{}test
   Waiting for signal...
\end{sphinxVerbatim}

Signal sent for \sphinxcode{alert\_test} sent by an anonymous block in a second session:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    v\PYGZus{}name   VARCHAR2(30) := \PYGZsq{}alert\PYGZus{}test\PYGZsq{};
BEGIN
   DBMS\PYGZus{}ALERT.SIGNAL(v\PYGZus{}name,\PYGZsq{}This is the message from \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}name);
   DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Issued alert for \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}name);
END;

Issued alert for alert\PYGZus{}test
\end{sphinxVerbatim}

First session is alerted, control returns to the anonymous block, and the remainder of the code is executed:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Registered for alert alert\PYGZus{}test
Waiting for signal...
Alert name   : alert\PYGZus{}test
Alert msg    : This is the message from alert\PYGZus{}test
Alert status : 0
Alert timeout: 120 seconds
\end{sphinxVerbatim}

\newpage

\index{DBMS\_ALERT\_Comprehensive\_example}\ignorespaces 

\subsection{Comprehensive Example}
\label{\detokenize{dbms_alert:comprehensive-example}}\label{\detokenize{dbms_alert:index-7}}
The following example uses two triggers to send alerts when the \sphinxcode{dept}
table or the \sphinxcode{emp} table is changed. An anonymous block listens for these
alerts and displays messages when an alert is received.

The following are the triggers on the \sphinxcode{dept} and \sphinxcode{emp} tables:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
CREATE OR REPLACE TRIGGER dept\PYGZus{}alert\PYGZus{}trig
   AFTER INSERT OR UPDATE OR DELETE ON dept
DECLARE
     v\PYGZus{}action        VARCHAR2(25);
BEGIN
   IF INSERTING THEN
       v\PYGZus{}action := \PYGZsq{} added department(s) \PYGZsq{};
   ELSIF UPDATING THEN
       v\PYGZus{}action := \PYGZsq{} updated department(s) \PYGZsq{};
   ELSIF DELETING THEN
       v\PYGZus{}action := \PYGZsq{} deleted department(s) \PYGZsq{};
   END IF;
   DBMS\PYGZus{}ALERT.SIGNAL(\PYGZsq{}dept\PYGZus{}alert\PYGZsq{},USER \textbar{}\textbar{} v\PYGZus{}action \textbar{}\textbar{} \PYGZsq{}on \PYGZsq{} \textbar{}\textbar{}
       SYSDATE);
END;

CREATE OR REPLACE TRIGGER emp\PYGZus{}alert\PYGZus{}trig
     AFTER INSERT OR UPDATE OR DELETE ON emp
DECLARE
     v\PYGZus{}action        VARCHAR2(25);
BEGIN
   IF INSERTING THEN
       v\PYGZus{}action := \PYGZsq{} added employee(s) \PYGZsq{};
   ELSIF UPDATING THEN
       v\PYGZus{}action := \PYGZsq{} updated employee(s) \PYGZsq{};
   ELSIF DELETING THEN
       v\PYGZus{}action := \PYGZsq{} deleted employee(s) \PYGZsq{};
   END IF;
   DBMS\PYGZus{}ALERT.SIGNAL(\PYGZsq{}emp\PYGZus{}alert\PYGZsq{},USER \textbar{}\textbar{} v\PYGZus{}action \textbar{}\textbar{} \PYGZsq{}on \PYGZsq{} \textbar{}\textbar{}
       SYSDATE);
END;
\end{sphinxVerbatim}

The following anonymous block is executed in a session while updates to the \sphinxcode{dept} and \sphinxcode{emp} tables occur in other sessions:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
     v\PYGZus{}dept\PYGZus{}alert     VARCHAR2(30) := \PYGZsq{}dept\PYGZus{}alert\PYGZsq{};
     v\PYGZus{}emp\PYGZus{}alert      VARCHAR2(30) := \PYGZsq{}emp\PYGZus{}alert\PYGZsq{};
     v\PYGZus{}name           VARCHAR2(30);
     v\PYGZus{}msg            VARCHAR2(80);
     v\PYGZus{}status         INTEGER;
     v\PYGZus{}timeout        NUMBER(3) := 60;
BEGIN
     DBMS\PYGZus{}ALERT.REGISTER(v\PYGZus{}dept\PYGZus{}alert);
     DBMS\PYGZus{}ALERT.REGISTER(v\PYGZus{}emp\PYGZus{}alert);
     DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Registered for alerts dept\PYGZus{}alert and emp\PYGZus{}alert\PYGZsq{});
     DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Waiting for signal...\PYGZsq{});
     LOOP
         DBMS\PYGZus{}ALERT.WAITANY(v\PYGZus{}name,v\PYGZus{}msg,v\PYGZus{}status,v\PYGZus{}timeout);
         EXIT WHEN v\PYGZus{}status != 0;
         DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Alert name   : \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}name);
         DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Alert msg    : \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}msg);
         DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Alert status : \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}status);
         DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZsq{} \textbar{}\textbar{}
       \PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZsq{});
     END LOOP;
     DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Alert status : \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}status);
     DBMS\PYGZus{}ALERT.REMOVEALL;
END;
\end{sphinxVerbatim}

Registered for alerts dept\_alert and emp\_alert
Waiting for signal…

The following changes are made by user, mary:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
INSERT INTO dept VALUES (50,\PYGZsq{}FINANCE\PYGZsq{},\PYGZsq{}CHICAGO\PYGZsq{});
INSERT INTO emp (empno,ename,deptno) VALUES (9001,\PYGZsq{}JONES\PYGZsq{},50);
INSERT INTO emp (empno,ename,deptno) VALUES (9002,\PYGZsq{}ALICE\PYGZsq{},50);
\end{sphinxVerbatim}

The following change is made by user, john:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
INSERT INTO dept VALUES (60,\PYGZsq{}HR\PYGZsq{},\PYGZsq{}LOS ANGELES\PYGZsq{});
\end{sphinxVerbatim}

The following is the output displayed by the anonymous block receiving the signals from the triggers:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Registered for alerts dept\PYGZus{}alert and emp\PYGZus{}alert
Waiting for signal...
Alert name   : dept\PYGZus{}alert
Alert msg    : mary added department(s) on 25\PYGZhy{}OCT\PYGZhy{}07 16:41:01
Alert status : 0
 \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
Alert name   : emp\PYGZus{}alert
Alert msg    : mary added employee(s) on 25\PYGZhy{}OCT\PYGZhy{}07 16:41:02
Alert status : 0
 \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
Alert name   : dept\PYGZus{}alert
Alert msg    : john added department(s) on 25\PYGZhy{}OCT\PYGZhy{}07 16:41:22
Alert status : 0
 \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
Alert status : 1
\end{sphinxVerbatim}

\newpage


\section{\index{DBMS\_AQ}DBMS\_AQ}
\label{\detokenize{dbms_aq::doc}}\label{\detokenize{dbms_aq:dbms-aq}}
EDB Postgres Advanced Server Advanced Queueing provides message queueing
and message processing for the Advanced Server database. User-defined
messages are stored in a queue; a collection of queues is stored in a
queue table. Procedures in the DBMS\_AQADM package create and manage
message queues and queue tables. Use the DBMS\_AQ package to add
messages to a queue or remove messages from a queue, or register or
unregister a PL/SQL callback procedure.

Advanced Server also provides extended (non-compatible) functionality
for the DBMS\_AQ package with SQL commands. Please see the \sphinxstyleemphasis{Database
Compatibility for Oracle Developers Reference Guide} for detailed
information about the following SQL commands:
\begin{itemize}
\item {} 
\sphinxcode{ALTER QUEUE}

\item {} 
\sphinxcode{ALTER QUEUE TABLE}

\item {} 
\sphinxcode{CREATE QUEUE}

\item {} 
\sphinxcode{CREATE QUEUE TABLE}

\item {} 
\sphinxcode{DROP QUEUE}

\item {} 
\sphinxcode{DROP QUEUE TABLE}

\end{itemize}

The DBMS\_AQ package provides procedures that allow you to enqueue a
message, dequeue a message, and manage callback procedures. The
supported procedures are:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

Function/Procedure
&
Return Type
&
Description
\\
\hline
\sphinxcode{ENQUEUE}
&
n/a
&
Post a message to a queue.
\\
\hline
\sphinxcode{DEQUEUE}
&
n/a
&
Retrieve a message from a queue if or when a message is available.
\\
\hline
\sphinxcode{REGISTER}
&
n/a
&
Register a callback procedure.
\\
\hline
\sphinxcode{UNREGISTER}
&
n/a
&
Unregister a callback procedure.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Advanced Server’s implementation of DBMS\_AQ is a partial implementation
when compared to Oracle’s version. Only those procedures listed in the
table above are supported.

Advanced Server supports use of the constants listed below:


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}{|\X{5}{12}|\X{3}{12}|\X{4}{12}|}
\hline

\endfirsthead

\multicolumn{3}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{3}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot

Constant
&
Description
&
For Parameters
\\
\hline
DBMS\_AQ.BROWSE (0)
&
Read the message without locking.
&
dequeue\_options\_t.dequeue\_mode
\\
\hline
DBMS\_AQ.LOCKED (1)
&
This constant is defined, but will return an error if used.
&
dequeue\_options\_t.dequeue\_mode
\\
\hline
DBMS\_AQ.REMOVE (2)
&
Delete the message after reading; the default.
&
dequeue\_options\_t.dequeue\_mode
\\
\hline
DBMS\_AQ.REMOVE\_NODATA (3)
&
This constant is defined, but will return an error if used.
&
dequeue\_options\_t.dequeue\_mode
\\
\hline
DBMS\_AQ.FIRST\_MESSAGE (0)
&
Return the first available message that matches the search terms.
&
dequeue\_options\_t.navigation
\\
\hline
DBMS\_AQ.NEXT\_MESSAGE (1)
&
Return the next available message that matches the search terms.
&
dequeue\_options\_t.navigation
\\
\hline
DBMS\_AQ.NEXT\_TRANSACTION (2)
&
This constant is defined, but will return an error if used.
&
dequeue\_options\_t.navigation
\\
\hline
DBMS\_AQ.FOREVER (-1)
&
Wait forever if a message that matches the search term is not found, the default.
&
dequeue\_options\_t.wait
\\
\hline
DBMS\_AQ.NO\_WAIT (0)
&
Do not wait if a message that matches the search term is not found.
&
dequeue\_options\_t.wait
\\
\hline
DBMS\_AQ.ON\_COMMIT (0)
&
The dequeue is part of the current transaction.
&
enqueue\_options\_t.visibility, dequeue\_options\_t.visibility
\\
\hline
DBMS\_AQ.IMMEDIATE (1)
&
This constant is defined, but will return an error if used.
&
enqueue\_options\_t.visibility, dequeue\_options\_t.visibility
\\
\hline
DBMS\_AQ.PERSISTENT (0)
&
The message should be stored in a table.
&
enqueue\_options\_t.delivery\_mode
\\
\hline
DBMS\_AQ.BUFFERED (1)
&
This constant is defined, but will return an error if used.
&
enqueue\_options\_t.delivery\_mode
\\
\hline
DBMS\_AQ.READY (0)
&
Specifies that the message is ready to process.
&
message\_properties\_t.state
\\
\hline
DBMS\_AQ.WAITING (1)
&
Specifies that the message is waiting to be processed.
&
message\_properties\_t.state
\\
\hline
DBMS\_AQ.PROCESSED (2)
&
Specifies that the message has been processed.
&
message\_properties\_t.state
\\
\hline
DBMS\_AQ.EXPIRED (3)
&
Specifies that the message is in the exception queue.
&
message\_properties\_t.state
\\
\hline
DBMS\_AQ.NO\_DELAY (0)
&
This constant is defined, but will return an error if used
&
message\_properties\_t.delay
\\
\hline
DBMS\_AQ.NEVER (NULL)
&
This constant is defined, but will return an error if used
&
message\_properties\_t.expiration
\\
\hline
DBMS\_AQ.NAMESPACE\_AQ (0)
&
Accept notifications from DBMS\_AQ queues.
&
sys.aq\$\_reg\_info.namespace
\\
\hline
DBMS\_AQ.NAMESPACE\_ANONYMOUS (1)
&
This constant is defined, but will return an error if used
&
sys.aq\$\_reg\_info.namespace
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}

\newpage

The DBMS\_AQ configuration parameters listed in the following table can
be defined in the \sphinxcode{postgresql.conf} file. After the configuration
parameters are defined, you can invoke the DBMS\_AQ package to use and
manage messages held in queues and queue tables.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|\Y{0.4}|\Y{0.6}|}
\hline

Parameter
&
Description
\\
\hline
\sphinxcode{dbms\_aq.max\_workers}
&
The maximum number of workers to run.
\\
\hline
\sphinxcode{dbms\_aq.max\_idle\_time}
&
The idle time a worker must wait before exiting.
\\
\hline
\sphinxcode{dbms\_aq.min\_work\_time}
&
The minimum time a worker can run before exiting.
\\
\hline
\sphinxcode{dbms\_aq.launch\_delay}
&
The minimum time between creating workers.
\\
\hline
\sphinxcode{dbms\_aq.batch\_size}
&
The maximum number of messages to process in a single transaction. The default batch size is 10.
\\
\hline
\sphinxcode{dbms\_aq.max\_databases}
&
The size of DBMS\_AQ’s hash table of databases. The default value is 1024.
\\
\hline
\sphinxcode{dbms\_aq.max\_pending\_retries}
&
The size of DBMS\_AQ’s hash table of pending retries. The default value is 1024.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\newpage


\subsection{\index{ENQUEUE}ENQUEUE}
\label{\detokenize{enqueue:enqueue}}\label{\detokenize{enqueue::doc}}
The \sphinxcode{ENQUEUE} procedure adds an entry to a queue. The signature is:
\begin{quote}

\sphinxcode{ENQUEUE(}
\begin{quote}

\sphinxcode{\textless{}queue\_name\textgreater{} IN VARCHAR2},

\sphinxcode{\textless{}enqueue\_options\textgreater{} IN DBMS\_AQ.ENQUEUE\_OPTIONS\_T},

\sphinxcode{\textless{}message\_properties\textgreater{} IN DBMS\_AQ.MESSAGE\_PROPERTIES\_T},

\sphinxcode{\textless{}payload IN \textless{}type\_name\textgreater{}},

\sphinxcode{\textless{}msgid\textgreater{} OUT RAW)}
\end{quote}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}queue\_name\textgreater{}}
\begin{quote}

The name (optionally schema-qualified) of an existing queue. If you
omit the schema name, the server will use the schema specified in
the \sphinxcode{SEARCH\_PATH}. Please note that unlike Oracle, unquoted
identifiers are converted to lower case before storing. To include
special characters or use a case-sensitive name, enclose the name in
double quotes.

For detailed information about creating a queue, please see
\sphinxcode{DBMS\_AQADM.CREATE\_QUEUE}.
\end{quote}

\sphinxcode{\textless{}enqueue\_options\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}enqueue\_options\textgreater{}} is a value of the type, \sphinxcode{enqueue\_options\_t}:
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DBMS\PYGZus{}AQ.ENQUEUE\PYGZus{}OPTIONS\PYGZus{}T IS RECORD(
  visibility BINARY\PYGZus{}INTEGER DEFAULT ON\PYGZus{}COMMIT,
  relative\PYGZus{}msgid RAW(16) DEFAULT NULL,
  sequence\PYGZus{}deviation BINARY INTEGER DEFAULT NULL,
  transformation VARCHAR2(61) DEFAULT NULL,
  delivery\PYGZus{}mode PLS\PYGZus{}INTEGER NOT NULL DEFAULT PERSISTENT);
\end{sphinxVerbatim}
\end{quote}
\end{quote}

Currently, the only supported parameter values for \sphinxcode{enqueue\_options\_t}  are:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
\sphinxcode{visibility}
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
\sphinxcode{ON\_COMMIT}.
\unskip}\relax \\
\hline
\sphinxcode{delivery\_mode}
&
\sphinxcode{PERSISTENT}
\\
\hline
\sphinxcode{sequence\_deviation}
&
\sphinxcode{NULL}
\\
\hline
\sphinxcode{transformation}
&
\sphinxcode{NULL}
\\
\hline
\sphinxcode{relative\_msgid}
&
\sphinxcode{NULL}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxcode{\textless{}message\_properties\textgreater{}}

\sphinxcode{\textless{}message\_properties\textgreater{}} is a value of the type, \sphinxcode{message\_properties\_t}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
message\PYGZus{}properties\PYGZus{}t IS RECORD(
 priority INTEGER,
 delay INTEGER,
 expiration INTEGER,
 correlation CHARACTER VARYING(128) COLLATE pg\PYGZus{}catalog.”C”,
 attempts INTEGER,
 recipient\PYGZus{}list “AQ\PYGZdl{}\PYGZus{}RECIPIENT\PYGZus{}LIST\PYGZus{}T”,
 exception\PYGZus{}queue CHARACTER VARYING(61) COLLATE pg\PYGZus{}catalog.”C”,
 enqueue\PYGZus{}time TIMESTAMP WITHOUT TIME ZONE,
 state INTEGER,
 original\PYGZus{}msgid BYTEA,
 transaction\PYGZus{}group CHARACTER VARYING(30) COLLATE pg\PYGZus{}catalog.”C”,
 delivery\PYGZus{}mode INTEGER
DBMS\PYGZus{}AQ.PERSISTENT);
\end{sphinxVerbatim}

The supported values for \sphinxcode{message\_properties\_t} are:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|\Y{0.3}|\Y{0.7}|}
\hline

\sphinxcode{priority}
&
If the queue table definition includes a \sphinxcode{sort\_list} that references \sphinxcode{priority}, this parameter affects the order that messages are dequeued. A lower value indicates a higher dequeue priority.
\\
\hline
\sphinxcode{delay}
&
Specify the number of seconds that will pass before a message is available for dequeueing or \sphinxcode{NO\_DELAY}.
\\
\hline
\sphinxcode{expiration}
&
Use the expiration parameter to specify the number of seconds until a message expires.
\\
\hline
\sphinxcode{correlation}
&
Use correlation to specify a message that will be associated with the entry; the default is \sphinxcode{NULL}.
\\
\hline
\sphinxcode{attempts}
&
This is a system-maintained value that specifies the number of attempts to dequeue the message.
\\
\hline
\sphinxcode{recipient\_list}
&
This parameter is not supported.
\\
\hline
\sphinxcode{exception\_queue}
&
Use the \sphinxcode{exception\_queue} parameter to specify the name of an exception queue to which a message will be moved if it expires or is dequeued by a transaction that rolls back too many times.
\\
\hline
\sphinxcode{enqueue\_time}
&
\sphinxcode{enqueue\_time} is the time the record was added to the queue; this value is provided by the system.
\\
\hline
\sphinxcode{state}
&
This parameter is maintained by DBMS\_AQ; state can be:

\sphinxcode{DBMS\_AQ.WAITING} \textendash{} the delay has not been reached.

\sphinxcode{DBMS\_AQ.READY} \textendash{} the queue entry is ready for processing.

\sphinxcode{DBMS\_AQ.PROCESSED} \textendash{} the queue entry has been processed.

\sphinxcode{DBMS\_AQ.EXPIRED} \textendash{} the queue entry has been moved to the exception queue.
\\
\hline
\sphinxcode{original\_msgid}
&
This parameter is accepted for compatibility and ignored.
\\
\hline
\sphinxcode{transaction\_group}
&
This parameter is accepted for compatibility and ignored.
\\
\hline
\sphinxcode{delivery\_mode}
&
This parameter is not supported; specify a value of \sphinxcode{DBMS\_AQ.PERSISTENT}.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxcode{\textless{}payload\textgreater{}}
\begin{quote}

Use the \sphinxcode{\textless{}payload\textgreater{}} parameter to provide the data that will be
associated with the queue entry. The payload type must match the
type specified when creating the corresponding queue table (see
\sphinxcode{DBMS\_AQADM.CREATE\_QUEUE\_TABLE}).
\end{quote}

\sphinxcode{\textless{}msgid\textgreater{}}
\begin{quote}

Use the \sphinxcode{\textless{}msgid\textgreater{}} parameter to retrieve a unique (system-generated)
message identifier.
\end{quote}

\sphinxstylestrong{Example}

The following anonymous block calls \sphinxcode{DBMS\_AQ.ENQUEUE}, adding a message
to a queue named \sphinxcode{work\_order}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
 enqueue\PYGZus{}options    DBMS\PYGZus{}AQ.ENQUEUE\PYGZus{}OPTIONS\PYGZus{}T;
 message\PYGZus{}properties DBMS\PYGZus{}AQ.MESSAGE\PYGZus{}PROPERTIES\PYGZus{}T;
 message\PYGZus{}handle     raw(16);
 payload            work\PYGZus{}order;

BEGIN

 payload := work\PYGZus{}order(\PYGZsq{}Smith\PYGZsq{}, \PYGZsq{}system upgrade\PYGZsq{});

DBMS\PYGZus{}AQ.ENQUEUE(
 queue\PYGZus{}name         =\PYGZgt{} \PYGZsq{}work\PYGZus{}order\PYGZsq{},
 enqueue\PYGZus{}options    =\PYGZgt{} enqueue\PYGZus{}options,
 message\PYGZus{}properties =\PYGZgt{} message\PYGZus{}properties,
 payload            =\PYGZgt{} payload,
 msgid              =\PYGZgt{} message\PYGZus{}handle
   );
END;
\end{sphinxVerbatim}

\newpage


\subsection{\index{DEQUEUE}DEQUEUE}
\label{\detokenize{dequeue:dequeue}}\label{\detokenize{dequeue::doc}}
The \sphinxcode{DEQUEUE} procedure dequeues a message. The signature is:
\begin{quote}

\sphinxcode{DEQUEUE(}
\begin{quote}

\sphinxcode{\textless{}queue\_name\textgreater{} IN VARCHAR2},

\sphinxcode{\textless{}dequeue\_options\textgreater{} IN DBMS\_AQ.DEQUEUE\_OPTIONS\_T,}

\sphinxcode{\textless{}message\_properties\textgreater{} OUT DBMS\_AQ.MESSAGE\_PROPERTIES\_T,}

\sphinxcode{\textless{}payload\textgreater{} OUT type\_name},

\sphinxcode{\textless{}msgid\textgreater{} OUT RAW)}
\end{quote}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}queue\_name\textgreater{}}
\begin{quote}

The name (optionally schema-qualified) of an existing queue. If you
omit the schema name, the server will use the schema specified in
the \sphinxcode{SEARCH\_PATH}. Please note that unlike Oracle, unquoted
identifiers are converted to lower case before storing. To include
special characters or use a case-sensitive name, enclose the name in
double quotes.

For detailed information about creating a queue, please see
\sphinxcode{DBMS\_AQADM.CREATE\_QUEUE}.
\end{quote}

\sphinxcode{\textless{}dequeue\_options\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}dequeue\_options\textgreater{}} is a value of the type,
\sphinxcode{dequeue\_options\_t}:
\end{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DEQUEUE\PYGZus{}OPTIONS\PYGZus{}T IS RECORD(
  consumer\PYGZus{}name CHARACTER VARYING(30),
  dequeue\PYGZus{}mode INTEGER,
  navigation INTEGER,
  visibility INTEGER,
  wait INTEGER,
  msgid BYTEA,
  correlation CHARACTER VARYING(128),
  deq\PYGZus{}condition CHARACTER VARYING(4000),
  transformation CHARACTER VARYING(61),
  delivery\PYGZus{}mode INTEGER);
\end{sphinxVerbatim}

\newpage

Currently, the supported parameter values for \sphinxcode{dequeue\_options\_t} are:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|\Y{0.3}|\Y{0.7}|}
\hline

\sphinxcode{consumer\_name}
&
Must be \sphinxcode{NULL}.
\\
\hline
\sphinxcode{dequeue\_mode}
&
The locking behavior of the dequeue operation. Must be either:

\sphinxcode{DBMS\_AQ.BROWSE} \textendash{} Read the message without obtaining a lock.

\sphinxcode{DBMS\_AQ.LOCKED} \textendash{} Read the message after acquiring a lock.

\sphinxcode{DBMS\_AQ.REMOVE} \textendash{} Read the message before deleting the message.

\sphinxcode{DBMS\_AQ.REMOVE\_NODATA} \textendash{} Read the message, but do not delete the message.
\\
\hline
\sphinxcode{navigation}
&
Identifies the message that will be retrieved. Must be either:

\sphinxcode{FIRST\_MESSAGE} \textendash{} The first message within the queue that matches the search term.

\sphinxcode{NEXT\_MESSAGE} \textendash{} The next message that is available that matches the first term.
\\
\hline
\sphinxcode{visibility}
&
Must be \sphinxcode{ON\_COMMIT} \textendash{} if you roll back the current transaction the dequeued item will remain in the queue.
\\
\hline
\sphinxcode{wait}
&
Must be a number larger than 0, or:

\sphinxcode{DBMS\_AQ.FOREVER} \textendash{} Wait indefinitely.

\sphinxcode{DBMS\_AQ.NO\_WAIT} \textendash{} Do not wait.
\\
\hline
\sphinxcode{msgid}
&
The message ID of the message that will be dequeued.
\\
\hline
\sphinxcode{correlation}
&
Accepted for compatibility, and ignored.
\\
\hline
\sphinxcode{deq\_condition}
&
A \sphinxcode{VARCHAR2} expression that evaluates to a \sphinxcode{BOOLEAN} value indicating if the message should be dequeued
\\
\hline
\sphinxcode{transformation}
&
Accepted for compatibility, and ignored.
\\
\hline
\sphinxcode{delivery\_mode}
&
Must be \sphinxcode{PERSISTENT}; buffered messages are not supported at this time.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxcode{\textless{}message\_properties\textgreater{}}

\sphinxcode{\textless{}message\_properties\textgreater{}} is a value of the type,
\sphinxcode{message\_properties\_t}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
message\PYGZus{}properties\PYGZus{}t IS RECORD(
  priority INTEGER,
  delay INTEGER,
  expiration INTEGER,
  correlation CHARACTER VARYING(128) COLLATE pg\PYGZus{}catalog.”C”,
  attempts INTEGER,
  recipient\PYGZus{}list “AQ\PYGZdl{}\PYGZus{}RECIPIENT\PYGZus{}LIST\PYGZus{}T”,
  exception\PYGZus{}queue CHARACTER VARYING(61) COLLATE pg\PYGZus{}catalog.”C”,
  enqueue\PYGZus{}time TIMESTAMP WITHOUT TIME ZONE,
  state INTEGER,
  original\PYGZus{}msgid BYTEA,
  transaction\PYGZus{}group CHARACTER VARYING(30) COLLATE pg\PYGZus{}catalog.”C”,
  delivery\PYGZus{}mode INTEGER
DBMS\PYGZus{}AQ.PERSISTENT);
\end{sphinxVerbatim}

The supported values for \sphinxcode{message\_properties\_t} are:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|\Y{0.3}|\Y{0.7}|}
\hline

\sphinxcode{priority}
&
If the queue table definition includes a \sphinxcode{sort\_list} that references priority, this parameter affects the order that messages are dequeued. A lower value indicates a higher dequeue priority.
\\
\hline
\sphinxcode{delay}
&
Specify the number of seconds that will pass before a message is available for dequeueing or \sphinxcode{NO\_DELAY}.
\\
\hline
\sphinxcode{expiration}
&
Use the expiration parameter to specify the number of seconds until a message expires.
\\
\hline
\sphinxcode{correlation}
&
Use correlation to specify a message that will be associated with the entry; the default is \sphinxcode{NULL}.
\\
\hline
\sphinxcode{attempts}
&
This is a system-maintained value that specifies the number of attempts to dequeue the message.
\\
\hline
\sphinxcode{recipient\_list}
&
This parameter is not supported.
\\
\hline
\sphinxcode{exception\_queue}
&
Use the \sphinxcode{exception\_queue} parameter to specify the name of an exception queue to which a message will be moved if it expires or is dequeued by a transaction that rolls back too many times.
\\
\hline
\sphinxcode{enqueue\_time}
&
\sphinxcode{enqueue\_time} is the time the record was added to the queue; this value is provided by the system.
\\
\hline
\sphinxcode{state}
&
This parameter is maintained by \sphinxcode{DBMS\_AQ}; state can be:
\sphinxcode{DBMS\_AQ.WAITING} \textendash{} the delay has not been reached.
\sphinxcode{DBMS\_AQ.READY} \textendash{} the queue entry is ready for processing.
\sphinxcode{DBMS\_AQ.PROCESSED} \textendash{} the queue entry has been processed.
\sphinxcode{DBMS\_AQ.EXPIRED} \textendash{} the queue entry has been moved to the exception queue.
\\
\hline
\sphinxcode{original\_msgid}
&
This parameter is accepted for compatibility and ignored.
\\
\hline
\sphinxcode{transaction\_group}
&
This parameter is accepted for compatibility and ignored.
\\
\hline
\sphinxcode{delivery\_mode}
&
This parameter is not supported; specify a value of \sphinxcode{DBMS\_AQ.PERSISTENT}.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxcode{\textless{}payload\textgreater{}}
\begin{quote}

Use the \sphinxcode{\textless{}payload\textgreater{}} parameter to retrieve the payload of a message
with a dequeue operation. The payload type must match the type
specified when creating the queue table.
\end{quote}

\sphinxcode{\textless{}msgid\textgreater{}}
\begin{quote}

Use the \sphinxcode{\textless{}msgid\textgreater{}} parameter to retrieve a unique message identifier.
\end{quote}

\sphinxstylestrong{Example}

The following anonymous block calls \sphinxcode{DBMS\_AQ.DEQUEUE}, retrieving a
message from the queue and a payload:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE

  dequeue\PYGZus{}options    DBMS\PYGZus{}AQ.DEQUEUE\PYGZus{}OPTIONS\PYGZus{}T;
  message\PYGZus{}properties DBMS\PYGZus{}AQ.MESSAGE\PYGZus{}PROPERTIES\PYGZus{}T;
  message\PYGZus{}handle     raw(16);
  payload            work\PYGZus{}order;

BEGIN
  dequeue\PYGZus{}options.dequeue\PYGZus{}mode := DBMS\PYGZus{}AQ.BROWSE;

  DBMS\PYGZus{}AQ.DEQUEUE(
    queue\PYGZus{}name         =\PYGZgt{} \PYGZsq{}work\PYGZus{}queue\PYGZsq{},
    dequeue\PYGZus{}options    =\PYGZgt{} dequeue\PYGZus{}options,
    message\PYGZus{}properties =\PYGZgt{} message\PYGZus{}properties,
    payload            =\PYGZgt{} payload,
    msgid              =\PYGZgt{} message\PYGZus{}handle
  );

  DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(
  \PYGZsq{}The next work order is [\PYGZsq{} \textbar{}\textbar{} payload.subject \textbar{}\textbar{} \PYGZsq{}].\PYGZsq{}
  );
END;
\end{sphinxVerbatim}

The payload is displayed by \sphinxcode{DBMS\_OUTPUT.PUT\_LINE}.

\newpage

\index{DBMS\_AQ\_Register}\ignorespaces 

\subsection{REGISTER}
\label{\detokenize{register::doc}}\label{\detokenize{register:register}}\label{\detokenize{register:index-0}}
Use the \sphinxcode{REGISTER} procedure to register an email address, procedure or
URL that will be notified when an item is enqueued or dequeued. The
signature is:
\begin{quote}

\sphinxcode{REGISTER(}
\begin{quote}

\sphinxcode{\textless{}reg\_list\textgreater{} IN SYS.AQ\$\_REG\_INFO\_LIST},

\sphinxcode{\textless{}count\textgreater{} IN NUMBER)}
\end{quote}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}reg\_list\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}reg\_list\textgreater{}} is a list of type \sphinxcode{AQ\$\_REG\_INFO\_LIST}; that provides
information about each subscription that you would like to register.
Each entry within the list is of the type \sphinxcode{AQ\$\_REG\_INFO}, and may
contain:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|\Y{0.2}|\Y{0.2}|\Y{0.6}|}
\hline

Attribute
&
Type
&
Description
\\
\hline
\sphinxcode{name}
&
VARCHAR2 (128)
&
The (optionally schema-qualified) name of the subscription.
\\
\hline
\sphinxcode{namespace}
&
NUMERIC
&
The only supported value is \sphinxcode{DBMS\_AQ.NAMESPACE\_AQ (0)}
\\
\hline
\sphinxcode{callback}
&
VARCHAR2 (4000)
&
Describes the action that will be performed upon notification. Currently, only calls to PL/SQL procedures are supported. The call should take the form:

\sphinxcode{plsql://schema.procedure}
\begin{quote}

Where:

schema specifies the schema in which the procedure resides.

procedure specifies the name of the procedure that will be notified.
\end{quote}
\\
\hline
\sphinxcode{context}
&
RAW (16)
&
Any user-defined value required by the callback procedure.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

\sphinxcode{\textless{}count\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}count\textgreater{}} is the number of entries in \sphinxcode{\textless{}reg\_list\textgreater{}}.
\end{quote}

\sphinxstylestrong{Example}

The following anonymous block calls \sphinxcode{DBMS\_AQ.REGISTER}, registering
procedures that will be notified when an item is added to or removed
from a queue. A set of attributes (of \sphinxcode{sys.aq\$\_reg\_info} type) is
provided for each subscription identified in the \sphinxcode{DECLARE} section:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
   subscription1 sys.aq\PYGZdl{}\PYGZus{}reg\PYGZus{}info;
   subscription2 sys.aq\PYGZdl{}\PYGZus{}reg\PYGZus{}info;
   subscription3 sys.aq\PYGZdl{}\PYGZus{}reg\PYGZus{}info;
   subscriptionlist sys.aq\PYGZdl{}\PYGZus{}reg\PYGZus{}info\PYGZus{}list;
BEGIN
  subscription1 := sys.aq\PYGZdl{}\PYGZus{}reg\PYGZus{}info(\PYGZsq{}q\PYGZsq{}, DBMS\PYGZus{}AQ.NAMESPACE\PYGZus{}AQ,
\PYGZsq{}plsql://assign\PYGZus{}worker?PR=0\PYGZsq{},HEXTORAW(\PYGZsq{}FFFF\PYGZsq{}));
  subscription2 := sys.aq\PYGZdl{}\PYGZus{}reg\PYGZus{}info(\PYGZsq{}q\PYGZsq{}, DBMS\PYGZus{}AQ.NAMESPACE\PYGZus{}AQ,
\PYGZsq{}plsql://add\PYGZus{}to\PYGZus{}history?PR=1\PYGZsq{},HEXTORAW(\PYGZsq{}FFFF\PYGZsq{}));
  subscription3 := sys.aq\PYGZdl{}\PYGZus{}reg\PYGZus{}info(\PYGZsq{}q\PYGZsq{}, DBMS\PYGZus{}AQ.NAMESPACE\PYGZus{}AQ,
\PYGZsq{}plsql://reserve\PYGZus{}parts?PR=2\PYGZsq{},HEXTORAW(\PYGZsq{}FFFF\PYGZsq{}));

  subscriptionlist := sys.aq\PYGZdl{}\PYGZus{}reg\PYGZus{}info\PYGZus{}list(subscription1,
subscription2, subscription3);
  dbms\PYGZus{}aq.register(subscriptionlist, 3);
commit;

   END;
    /
\end{sphinxVerbatim}

The \sphinxcode{subscriptionlist} is of type \sphinxcode{sys.aq\$\_reg\_info\_list}, and contains
the previously described \sphinxcode{sys.aq\$\_reg\_info} objects. The list name and
an object count are passed to \sphinxcode{dbms\_aq.register}.

\newpage


\subsection{\index{UNREGISTER}UNREGISTER}
\label{\detokenize{unregister::doc}}\label{\detokenize{unregister:unregister}}
Use the \sphinxcode{UNREGISTER} procedure to turn off notifications related to
enqueueing and dequeueing. The signature is:
\begin{quote}

\sphinxcode{UNREGISTER(}
\begin{quote}

\sphinxcode{\textless{}reg\_list\textgreater{} IN SYS.AQ\$\_REG\_INFO\_LIST},

\sphinxcode{\textless{}count\textgreater{} IN NUMBER)}
\end{quote}
\end{quote}

\sphinxstylestrong{Parameter}

\sphinxcode{\textless{}reg\_list\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}reg\_list\textgreater{}} is a list of type \sphinxcode{AQ\$\_REG\_INFO\_LIST}; that provides
information about each subscription that you would like to register.
Each entry within the list is of the type \sphinxcode{AQ\$\_REG\_INFO}, and may
contain:
\end{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|\Y{0.2}|\Y{0.2}|\Y{0.6}|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Attribute
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Type
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Description
\unskip}\relax \\
\hline
\sphinxcode{name}
&
VARCHAR2 (128)
&
The (optionally schema-qualified) name of the subscription.
\\
\hline
\sphinxcode{namespace}
&
NUMERIC
&
The only supported value is \sphinxcode{DBMS\_AQ.NAMESPACE\_AQ (0)}
\\
\hline
\sphinxcode{callback}
&
VARCHAR2 (4000)
&
Describes the action that will be performed upon notification. Currently, only calls to PL/SQL procedures are supported. The call should take the form:

\sphinxcode{plsql://schema.procedure}
\begin{quote}

Where:

schema specifies the schema in which the procedure resides.

procedure specifies the name of the procedure that will be notified.
\end{quote}
\\
\hline
\sphinxcode{context}
&
RAW (16)
&
Any user-defined value required by the procedure.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxcode{\textless{}count\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}count\textgreater{}} is the number of entries in \sphinxcode{\textless{}reg\_list\textgreater{}}.
\end{quote}

\sphinxstylestrong{Example}

The following anonymous block calls \sphinxcode{DBMS\_AQ.UNREGISTER}, disabling the
notifications specified in the example for \sphinxcode{DBMS\_AQ.REGISTER}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE

   subscription1 sys.aq\PYGZdl{}\PYGZus{}reg\PYGZus{}info;
   subscription2 sys.aq\PYGZdl{}\PYGZus{}reg\PYGZus{}info;
   subscription3 sys.aq\PYGZdl{}\PYGZus{}reg\PYGZus{}info;
   subscriptionlist sys.aq\PYGZdl{}\PYGZus{}reg\PYGZus{}info\PYGZus{}list;

BEGIN

   subscription1 := sys.aq\PYGZdl{}\PYGZus{}reg\PYGZus{}info(\PYGZsq{}q\PYGZsq{}, DBMS\PYGZus{}AQ.NAMESPACE\PYGZus{}AQ,
\PYGZsq{}plsql://assign\PYGZus{}worker?PR=0\PYGZsq{},HEXTORAW(\PYGZsq{}FFFF\PYGZsq{}));
   subscription2 := sys.aq\PYGZdl{}\PYGZus{}reg\PYGZus{}info(\PYGZsq{}q\PYGZsq{}, DBMS\PYGZus{}AQ.NAMESPACE\PYGZus{}AQ,
\PYGZsq{}plsql://add\PYGZus{}to\PYGZus{}history?PR=1\PYGZsq{},HEXTORAW(\PYGZsq{}FFFF\PYGZsq{}));
   subscription3 := sys.aq\PYGZdl{}\PYGZus{}reg\PYGZus{}info(\PYGZsq{}q\PYGZsq{}, DBMS\PYGZus{}AQ.NAMESPACE\PYGZus{}AQ,
\PYGZsq{}plsql://reserve\PYGZus{}parts?PR=2\PYGZsq{},HEXTORAW(\PYGZsq{}FFFF\PYGZsq{}));

   subscriptionlist := sys.aq\PYGZdl{}\PYGZus{}reg\PYGZus{}info\PYGZus{}list(subscription1,
 subscription2, subscription3);

   dbms\PYGZus{}aq.unregister(subscriptionlist, 3);
   commit;
  END;
   /
\end{sphinxVerbatim}

The \sphinxcode{subscriptionlist} is of type \sphinxcode{sys.aq\$\_reg\_info\_list}, and contains
the previously described \sphinxcode{sys.aq\$\_reg\_info} objects. The list name and
an object count are passed to \sphinxcode{dbms\_aq.unregister}.

\newpage


\section{\index{DBMS\_AQADM}DBMS\_AQADM}
\label{\detokenize{dbms_aqadm::doc}}\label{\detokenize{dbms_aqadm:dbms-aqadm}}
EDB Postgres Advanced Server Advanced Queueing provides message queueing
and message processing for the Advanced Server database. User-defined
messages are stored in a queue; a collection of queues is stored in a
queue table. Procedures in the DBMS\_AQADM package create and manage
message queues and queue tables. Use the DBMS\_AQ package to add
messages to a queue or remove messages from a queue, or register or
unregister a PL/SQL callback procedure.

Advanced Server also provides extended (non-compatible) functionality
for the DBMS\_AQ package with SQL commands. Please see the \sphinxstyleemphasis{Database
Compatibility for Oracle Developers Reference Guide} for detailed
information about the following SQL commands:
\begin{itemize}
\item {} 
\sphinxcode{ALTER QUEUE}

\item {} 
\sphinxcode{ALTER QUEUE TABLE}

\item {} 
\sphinxcode{CREATE QUEUE}

\item {} 
\sphinxcode{CREATE QUEUE TABLE}

\item {} 
\sphinxcode{DROP QUEUE}

\item {} 
\sphinxcode{DROP QUEUE TABLE}

\end{itemize}

The DBMS\_AQADM package provides procedures that allow you to create and
manage queues and queue tables.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|\Y{0.3}|\Y{0.1}|\Y{0.6}|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Function/Procedure
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Return Type
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Description
\unskip}\relax \\
\hline
\sphinxcode{ALTER\_QUEUE}
&
n/a
&
Modify an existing queue.
\\
\hline
\sphinxcode{ALTER\_QUEUE\_TABLE}
&
n/a
&
Modify an existing queue table.
\\
\hline
\sphinxcode{CREATE\_QUEUE}
&
n/a
&
Create a queue.
\\
\hline
\sphinxcode{CREATE\_QUEUE\_TABLE}
&
n/a
&
Create a queue table.
\\
\hline
\sphinxcode{DROP\_QUEUE}
&
n/a
&
Drop an existing queue.
\\
\hline
\sphinxcode{DROP\_QUEUE\_TABLE}
&
n/a
&
Drop an existing queue table.
\\
\hline
\sphinxcode{PURGE\_QUEUE\_TABLE}
&
n/a
&
Remove one or more messages from a queue table.
\\
\hline
\sphinxcode{START\_QUEUE}
&
n/a
&
Make a queue available for enqueueing and dequeueing procedures.
\\
\hline
\sphinxcode{STOP\_QUEUE}
&
n/a
&
Make a queue unavailable for enqueueing and dequeueing procedures
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Advanced Server’s implementation of \sphinxcode{DBMS\_AQADM} is a partial
implementation when compared to Oracle’s version. Only those functions
and procedures listed in the table above are supported.

Advanced Server supports use of the arguments listed below:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|\Y{0.45}|\Y{0.2}|\Y{0.35}|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Constant
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Description
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
For Parameters
\unskip}\relax \\
\hline
\sphinxcode{DBMS\_AQADM.TRANSACTIONAL(1)}
&
This constant is defined, but will return an error if used.
&
\sphinxcode{message\_grouping}
\\
\hline
\sphinxcode{DBMS\_AQADM.NONE(0)}
&
Use to specify message grouping for a queue table.
&
\sphinxcode{message\_grouping}
\\
\hline
\sphinxcode{DBMS\_AQADM.NORMAL\_QUEUE(0)}
&
Use with \sphinxcode{create\_queue} to \sphinxcode{specify queue\_type}.
&
\sphinxcode{queue\_type}
\\
\hline
\sphinxcode{DBMS\_AQADM.EXCEPTION\_QUEUE (1)}
&
Use with \sphinxcode{create\_queue} to specify \sphinxcode{queue\_type}.
&
\sphinxcode{queue\_type}
\\
\hline
\sphinxcode{DBMS\_AQADM.INFINITE(-1)}
&
Use with \sphinxcode{create\_queue} to specify \sphinxcode{retention\_time}.
&
\sphinxcode{retention\_time}
\\
\hline
\sphinxcode{DBMS\_AQADM.PERSISTENT (0)}
&
The message should be stored in a table.
&
\sphinxcode{enqueue\_options\_t.delivery\_mode}
\\
\hline
\sphinxcode{DBMS\_AQADM.BUFFERED (1)}
&
This constant is defined, but will return an error if used.
&
\sphinxcode{enqueue\_options\_t.delivery\_mode}
\\
\hline
\sphinxcode{DBMS\_AQADM.PERSISTENT\_OR\_BUFFERED (2)}
&
This constant is defined, but will return an error if used.
&
\sphinxcode{enqueue\_options\_t.delivery\_mode}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\newpage


\subsection{\index{ALTER\_QUEUE}ALTER\_QUEUE}
\label{\detokenize{alter_queue::doc}}\label{\detokenize{alter_queue:alter-queue}}
Use the \sphinxcode{ALTER\_QUEUE} procedure to modify an existing queue. The
signature is:

\sphinxcode{ALTER\_QUEUE(}
\begin{quote}

\sphinxcode{\textless{}max\_retries\textgreater{} IN NUMBER DEFAULT NULL},

\sphinxcode{\textless{}retry\_delay\textgreater{} IN NUMBER DEFAULT 0}

\sphinxcode{\textless{}retention\_time\textgreater{} IN NUMBER DEFAULT 0},

\sphinxcode{\textless{}auto\_commit\textgreater{} IN BOOLEAN DEFAULT TRUE)}

\sphinxcode{\textless{}comment\textgreater{} IN VARCHAR2 DEFAULT NULL},
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}queue\_name\textgreater{}}
\begin{quote}

The name of the new queue.
\end{quote}

\sphinxcode{\textless{}max\_retries\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}max\_retries\textgreater{}} specifies the maximum number of attempts to
remove a message with a dequeue statement. The value of
\sphinxcode{\textless{}max\_retries\textgreater{}} is incremented with each \sphinxcode{ROLLBACK} statement.
When the number of failed attempts reaches the value specified by
\sphinxcode{\textless{}max\_retries\textgreater{}}, the message is moved to the exception queue.
Specify \sphinxcode{0} to indicate that no retries are allowed.
\end{quote}

\sphinxcode{\textless{}retry\_delay\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}retry\_delay\textgreater{}} specifies the number of seconds until a message is
scheduled for re-processing after a \sphinxcode{ROLLBACK}. Specify \sphinxcode{0} to indicate
that the message should be retried immediately (the default).
\end{quote}

\sphinxcode{\textless{}retention\_time\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}retention\_time\textgreater{}} specifies the length of time (in seconds) that a
message will be stored after being dequeued. You can also specify \sphinxcode{0}
(the default) to indicate the message should not be retained after
dequeueing, or \sphinxcode{INFINITE} to retain the message forever.
\end{quote}

\sphinxcode{\textless{}auto\_commit\textgreater{}}
\begin{quote}

This parameter is accepted for compatibility and ignored.
\end{quote}

\sphinxcode{\textless{}comment\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}comment\textgreater{}} specifies a comment associated with the queue.
\end{quote}

\sphinxstylestrong{Example}

The following command alters a queue named \sphinxcode{work\_order}, setting the
\sphinxcode{retry\_delay} parameter to 5 seconds:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
EXEC DBMS\PYGZus{}AQADM.ALTER\PYGZus{}QUEUE(queue\PYGZus{}name =\PYGZgt{} \PYGZsq{}work\PYGZus{}order\PYGZsq{}, retry\PYGZus{}delay
=\PYGZgt{} 5);
\end{sphinxVerbatim}

\newpage


\subsection{\index{ALTER\_QUEUE\_TABLE}ALTER\_QUEUE\_TABLE}
\label{\detokenize{alter_queue_table:alter-queue-table}}\label{\detokenize{alter_queue_table::doc}}
Use the \sphinxcode{ALTER\_QUEUE\_TABLE} procedure to modify an existing queue table.

The signature is:

\sphinxcode{ALTER\_QUEUE\_TABLE (}
\begin{quote}

\sphinxcode{\textless{}queue\_table\textgreater{} IN VARCHAR2},

\sphinxcode{\textless{}comment\textgreater{} IN VARCHAR2 DEFAULT NULL},

\sphinxcode{\textless{}primary\_instance\textgreater{} IN BINARY\_INTEGER DEFAULT 0},

\sphinxcode{\textless{}secondary\_instance\textgreater{} IN BINARY\_INTEGER DEFAULT 0},
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}queue\_table\textgreater{}}
\begin{quote}

The (optionally schema-qualified) name of the queue table.
\end{quote}

\sphinxcode{\textless{}comment\textgreater{}}
\begin{quote}

Use the \sphinxcode{\textless{}comment\textgreater{}} parameter to provide a comment about the queue
table.
\end{quote}

\sphinxcode{\textless{}primary\_instance\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}primary\_instance\textgreater{}} is accepted for compatibility and stored, but is
ignored.
\end{quote}

\sphinxcode{\textless{}secondary\_instance\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}secondary\_instance\textgreater{}} is accepted for compatibility, but is ignored.
\end{quote}

\sphinxstylestrong{Example}

The following command modifies a queue table named \sphinxcode{work\_order\_table}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
EXEC DBMS\PYGZus{}AQADM.ALTER\PYGZus{}QUEUE\PYGZus{}TABLE
      (queue\PYGZus{}table =\PYGZgt{} \PYGZsq{}work\PYGZus{}order\PYGZus{}table\PYGZsq{}, comment =\PYGZgt{} \PYGZsq{}This queue table
contains work orders for the shipping department.\PYGZsq{});
\end{sphinxVerbatim}

The queue table is named \sphinxcode{work\_order\_table}; the command adds a comment
to the definition of the queue table.

\newpage


\subsection{\index{CREATE\_QUEUE}CREATE\_QUEUE}
\label{\detokenize{create_queue::doc}}\label{\detokenize{create_queue:create-queue}}
Use the \sphinxcode{CREATE\_QUEUE} procedure to create a queue in an existing queue
table. The signature is:
\begin{quote}

\sphinxcode{CREATE\_QUEUE(}
\begin{quote}

\sphinxcode{\textless{}queue\_name\textgreater{} IN VARCHAR2}

\sphinxcode{\textless{}queue\_table\textgreater{} IN VARCHAR2},

\sphinxcode{\textless{}queue\_type\textgreater{} IN BINARY\_INTEGER DEFAULT NORMAL\_QUEUE},

\sphinxcode{\textless{}max\_retries\textgreater{} IN NUMBER DEFAULT 5},

\sphinxcode{\textless{}retry\_delay\textgreater{} IN NUMBER DEFAULT 0}

\sphinxcode{\textless{}retention\_time\textgreater{} IN NUMBER DEFAULT 0},

\sphinxcode{\textless{}dependency\_tracking\textgreater{} IN BOOLEAN DEFAULT FALSE},

\sphinxcode{\textless{}comment\textgreater{} IN VARCHAR2 DEFAULT NULL},

\sphinxcode{\textless{}auto\_commit\textgreater{} IN BOOLEAN DEFAULT TRUE)}
\end{quote}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}queue\_name\textgreater{}}
\begin{quote}

The name of the new queue.
\end{quote}

\sphinxcode{\textless{}queue\_table\textgreater{}}
\begin{quote}

The name of the table in which the new queue will reside.
\end{quote}

\sphinxcode{\textless{}queue\_type\textgreater{}}
\begin{quote}

The type of the new queue. The valid values for \sphinxcode{\textless{}queue\_type\textgreater{}}
are:

\sphinxcode{DBMS\_AQADM.NORMAL\_QUEUE} \textendash{} This value specifies a normal queue (the
default).

\sphinxcode{DBMS\_AQADM.EXCEPTION\_QUEUE} \textendash{} This value specifies that the new
queue is an exception queue. An exception queue will support only
dequeue operations.
\end{quote}

\sphinxcode{\textless{}max\_retries\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}max\_retries\textgreater{}} specifies the maximum number of attempts to
remove a message with a dequeue statement. The value of
\sphinxcode{\textless{}max\_retries\textgreater{}} is incremented with each \sphinxcode{ROLLBACK} statement.
When the number of failed attempts reaches the value specified by
\sphinxcode{\textless{}max\_retries\textgreater{}}, the message is moved to the exception queue.
The default value for a system table is \sphinxcode{0}; the default value for a
user created table is \sphinxcode{5}.
\end{quote}

\sphinxcode{\textless{}retry\_delay\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}retry\_delay\textgreater{}} specifies the number of seconds until a message is
scheduled for re-processing after a \sphinxcode{ROLLBACK}. Specify \sphinxcode{0} to indicate
that the message should be retried immediately (the default).
\end{quote}

\sphinxcode{\textless{}retention\_time\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}retention\_time\textgreater{}} specifies the length of time (in seconds) that a
message will be stored after being dequeued. You can also specify \sphinxcode{0}
(the default) to indicate the message should not be retained after
dequeueing, or \sphinxcode{INFINITE} to retain the message forever.
\end{quote}

\sphinxcode{\textless{}dependency\_tracking\textgreater{}}
\begin{quote}

This parameter is accepted for compatibility and ignored.
\end{quote}

\sphinxcode{\textless{}comment\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}comment\textgreater{}} specifies a comment associated with the queue.
\end{quote}

\sphinxcode{\textless{}auto\_commit\textgreater{}}
\begin{quote}

This parameter is accepted for compatibility and ignored.
\end{quote}

\sphinxstylestrong{Example}

The following anonymous block creates a queue named \sphinxcode{work\_order} in the
\sphinxcode{work\_order\_table} table:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
BEGIN
DBMS\PYGZus{}AQADM.CREATE\PYGZus{}QUEUE ( queue\PYGZus{}name =\PYGZgt{} \PYGZsq{}work\PYGZus{}order\PYGZsq{}, queue\PYGZus{}table
=\PYGZgt{} \PYGZsq{}work\PYGZus{}order\PYGZus{}table\PYGZsq{}, comment =\PYGZgt{} \PYGZsq{}This queue contains pending work
orders.\PYGZsq{});
END;
\end{sphinxVerbatim}

\newpage


\subsection{\index{CREATE\_QUEUE\_TABLE}CREATE\_QUEUE\_TABLE}
\label{\detokenize{create_queue_table:create-queue-table}}\label{\detokenize{create_queue_table::doc}}
Use the \sphinxcode{CREATE\_QUEUE\_TABLE} procedure to create a queue table. The
signature is:
\begin{quote}

\sphinxcode{CREATE\_QUEUE\_TABLE (}
\begin{quote}

\sphinxcode{\textless{}queue\_table\textgreater{} IN VARCHAR2},

\sphinxcode{\textless{}queue \_payload\_type\textgreater{} IN VARCHAR2},

\sphinxcode{\textless{}storage\_clause\textgreater{} IN VARCHAR2 DEFAULT NULL},

\sphinxcode{\textless{}sort\_list\textgreater{} IN VARCHAR2 DEFAULT NULL},

\sphinxcode{\textless{}multiple\_consumers\textgreater{} IN BOOLEAN DEFAULT FALSE},

\sphinxcode{\textless{}message\_grouping\textgreater{} IN BINARY\_INTEGER DEFAULT NONE},

\sphinxcode{\textless{}comment\textgreater{} IN VARCHAR2 DEFAULT NULL},

\sphinxcode{\textless{}auto\_commit\textgreater{} IN BOOLEAN DEFAULT TRUE},

\sphinxcode{\textless{}primary\_instance\textgreater{} IN BINARY\_INTEGER DEFAULT 0},

\sphinxcode{\textless{}secondary\_instance\textgreater{} IN BINARY\_INTEGER DEFAULT 0},

\sphinxcode{\textless{}compatible\textgreater{} IN VARCHAR2 DEFAULT NULL},

\sphinxcode{\textless{}secure\textgreater{} IN BOOLEAN DEFAULT FALSE)}
\end{quote}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}queue\_table\textgreater{}}
\begin{quote}

The (optionally schema-qualified) name of the queue table.
\end{quote}

\sphinxcode{\textless{}queue\_payload\_type\textgreater{}}
\begin{quote}

The user-defined type of the data that will be stored in the queue
table. Please note that to specify a \sphinxcode{RAW} data type, you must create
a user-defined type that identifies a \sphinxcode{RAW} type.
\end{quote}

\sphinxcode{\textless{}storage\_clause\textgreater{}}
\begin{quote}

Use the \sphinxcode{\textless{}storage\_clause\textgreater{}} parameter to specify attributes for
the queue table. Please note that only the \sphinxcode{TABLESPACE} option is
enforced; all others are accepted for compatibility and ignored. Use
the \sphinxcode{TABLESPACE} clause to specify the name of a tablespace in which
the table will be created.

\sphinxcode{\textless{}storage\_clause\textgreater{}} may be one or more of the following:

\sphinxcode{TABLESPACE \textless{}tablespace\_name\textgreater{}, PCTFREE} integer, \sphinxcode{PCTUSED integer},

\sphinxcode{INITRANS integer, MAXTRANS integer} or \sphinxcode{STORAGE \textless{}storage\_option\textgreater{}}.

\sphinxcode{\textless{}storage\_option\textgreater{}} may be one or more of the following:

\sphinxcode{MINEXTENTS integer, MAXEXTENTS integer, PCTINCREASE integer},

\sphinxcode{INITIAL \textless{}size\_clause\textgreater{}, NEXT, FREELISTS integer, OPTIMAL}

\sphinxcode{\textless{}size\_clause\textgreater{}, BUFFER\_POOL \{KEEP\textbar{}RECYCLE\textbar{}DEFAULT\}}.
\end{quote}

\sphinxcode{\textless{}sort\_list\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}sort\_list\textgreater{}} controls the dequeueing order of the queue; specify the
names of the column(s) that will be used to sort the queue (in
ascending order). The currently accepted values are the following
combinations of \sphinxcode{enq\_time} and \sphinxcode{priority}:

\sphinxcode{enq\_time, priority}

\sphinxcode{priority, enq\_time}

\sphinxcode{priority}

\sphinxcode{enq\_time}
\end{quote}

\sphinxcode{\textless{}multiple\_consumers\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}multiple\_consumers\textgreater{}} queue tables is not supported.
\end{quote}

\sphinxcode{\textless{}message\_grouping\textgreater{}}
\begin{quote}

If specified, \sphinxcode{\textless{}message\_grouping\textgreater{}} must be \sphinxcode{NONE}.
\end{quote}

\sphinxcode{\textless{}comment\textgreater{}}
\begin{quote}

Use the \sphinxcode{\textless{}comment\textgreater{}} parameter to provide a comment about the queue
table.
\end{quote}

\sphinxcode{\textless{}auto\_commit\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}auto\_commit\textgreater{}} is accepted for compatibility, but is ignored.
\end{quote}

\sphinxcode{\textless{}primary\_instance\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}primary\_instance\textgreater{}} is accepted for compatibility and stored, but is
ignored.
\end{quote}

\sphinxcode{\textless{}secondary\_instance\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}secondary\_instance\textgreater{}} is accepted for compatibility, but is ignored.
\end{quote}

\sphinxcode{\textless{}compatible\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}compatible\textgreater{}} is accepted for compatibility, but is ignored.
\end{quote}

\sphinxcode{\textless{}secure\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}secure\textgreater{}} is accepted for compatibility, but is ignored.
\end{quote}

\sphinxstylestrong{Example}

The following anonymous block first creates a type (\sphinxcode{work\_order}) with
attributes that hold a name (a \sphinxcode{VARCHAR2}), and a project description (a
\sphinxcode{TEXT}). The block then uses that type to create a queue table:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
BEGIN

CREATE TYPE work\PYGZus{}order AS (name VARCHAR2, project TEXT, completed BOOLEAN);

EXEC DBMS\PYGZus{}AQADM.CREATE\PYGZus{}QUEUE\PYGZus{}TABLE
      (queue\PYGZus{}table =\PYGZgt{} \PYGZsq{}work\PYGZus{}order\PYGZus{}table\PYGZsq{},
      queue\PYGZus{}payload\PYGZus{}type =\PYGZgt{} \PYGZsq{}work\PYGZus{}order\PYGZsq{},
      comment =\PYGZgt{} \PYGZsq{}Work order message queue table\PYGZsq{});

END;
\end{sphinxVerbatim}

The queue table is named \sphinxcode{work\_order\_table}, and contains a payload of a
type \sphinxcode{work\_order}. A comment notes that this is the \sphinxcode{Work order message
queue table}.

\newpage


\subsection{\index{DROP\_QUEUE}DROP\_QUEUE}
\label{\detokenize{drop_queue::doc}}\label{\detokenize{drop_queue:drop-queue}}
Use the \sphinxcode{DROP\_QUEUE} procedure to delete a queue. The signature is:
\begin{quote}

\sphinxcode{DROP\_QUEUE(}
\begin{quote}

\sphinxcode{\textless{}queue\_name\textgreater{} IN VARCHAR2},

\sphinxcode{\textless{}auto\_commit\textgreater{} IN BOOLEAN DEFAULT TRUE)}
\end{quote}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}queue\_name\textgreater{}}
\begin{quote}

The name of the queue that you wish to drop.
\end{quote}

\sphinxcode{\textless{}auto\_commit\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}auto\_commit\textgreater{}} is accepted for compatibility, but is ignored.
\end{quote}

\sphinxstylestrong{Example}
\begin{quote}

The following anonymous block drops the queue named \sphinxcode{work\_order}:
\end{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
BEGIN
DBMS\PYGZus{}AQADM.DROP\PYGZus{}QUEUE(queue\PYGZus{}name =\PYGZgt{} \PYGZsq{}work\PYGZus{}order\PYGZsq{});
END;
\end{sphinxVerbatim}

\newpage


\subsection{\index{DROP\_QUEUE\_TABLE}DROP\_QUEUE\_TABLE}
\label{\detokenize{drop_queue_table::doc}}\label{\detokenize{drop_queue_table:drop-queue-table}}
Use the \sphinxcode{DROP\_QUEUE\_TABLE} procedure to delete a queue table. The
signature is:
\begin{quote}

\sphinxcode{DROP\_QUEUE\_TABLE(}
\begin{quote}

\sphinxcode{\textless{}queue\_table\textgreater{} IN VARCHAR2},

\sphinxcode{\textless{}force\textgreater{} IN BOOLEAN default FALSE},

\sphinxcode{\textless{}auto\_commit\textgreater{} IN BOOLEAN default TRUE)}
\end{quote}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}queue\_table\textgreater{}}
\begin{quote}

The (optionally schema-qualified) name of the queue table.
\end{quote}

\sphinxcode{\textless{}force\textgreater{}}
\begin{quote}

The \sphinxcode{\textless{}force\textgreater{}} keyword determines the behavior of the
\sphinxcode{DROP\_QUEUE\_TABLE} command when dropping a table that contain
entries:
\begin{quote}

If the target table contains entries and force is \sphinxcode{FALSE}, the command
will fail, and the server will issue an error.

If the target table contains entries and force is \sphinxcode{TRUE}, the command
will drop the table and any dependent objects.
\end{quote}
\end{quote}

\sphinxcode{\textless{}auto\_commit\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}auto\_commit\textgreater{}} is accepted for compatibility, but is ignored.
\end{quote}

\sphinxstylestrong{Example}

The following anonymous block drops a table named \sphinxcode{work\_order\_table}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
BEGIN
  DBMS\PYGZus{}AQADM.DROP\PYGZus{}QUEUE\PYGZus{}TABLE (\PYGZsq{}work\PYGZus{}order\PYGZus{}table\PYGZsq{}, force =\PYGZgt{} TRUE);
END;
\end{sphinxVerbatim}

\newpage


\subsection{\index{PURGE\_QUEUE\_TABLE}PURGE\_QUEUE\_TABLE}
\label{\detokenize{purge_queue_table::doc}}\label{\detokenize{purge_queue_table:purge-queue-table}}
Use the \sphinxcode{PURGE\_QUEUE\_TABLE} procedure to delete messages from a queue
table. The signature is:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{PURGE\_QUEUE\_TABLE(}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \sphinxcode{\textless{}queue\_table\textgreater{} IN VARCHAR2},
\item[] \sphinxcode{\textless{}purge\_condition\textgreater{} IN VARCHAR2},
\item[] \sphinxcode{\textless{}purge\_options\textgreater{} IN aq\$\_purge\_options\_t)}
\end{DUlineblock}
\end{DUlineblock}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}queue\_table\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}queue\_table\textgreater{}} specifies the name of the queue table from which you
are deleting a message.
\end{quote}

\sphinxcode{\textless{}purge\_condition\textgreater{}}
\begin{quote}

Use \sphinxcode{\textless{}purge\_condition\textgreater{}} to specify a condition (a SQL \sphinxcode{WHERE}
clause) that the server will evaluate when deciding which messages
to purge.
\end{quote}

\sphinxcode{\textless{}purge\_options\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}purge\_options\textgreater{}} is an object of the type \sphinxcode{aq\$\_purge\_options\_t}. An
\sphinxcode{aq\$\_purge\_options\_t} object contains:
\end{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|\Y{0.2}|\Y{0.2}|\Y{0.6}|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Attribute
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Type
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Description
\unskip}\relax \\
\hline
\sphinxcode{Block}
&
Boolean
&
Specify \sphinxcode{TRUE} if an exclusive lock should be held on all queues within the table; the default is \sphinxcode{FALSE}.
\\
\hline
\sphinxcode{delivery\_mode}
&
INTEGER
&
\sphinxcode{\textless{}delivery\_mode\textgreater{}} specifies the type of message that will be purged. The only accepted value is \sphinxcode{DBMS\_AQ.PERSISTENT}.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxstylestrong{Example}

The following anonymous block removes any messages from the
\sphinxcode{work\_order\_table} with a value in the \sphinxcode{completed} column of \sphinxcode{YES}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
   purge\PYGZus{}options dbms\PYGZus{}aqadm.aq\PYGZdl{}\PYGZus{}purge\PYGZus{}options\PYGZus{}t;
BEGIN
   dbms\PYGZus{}aqadm.purge\PYGZus{}queue\PYGZus{}table(\PYGZsq{}work\PYGZus{}order\PYGZus{}table\PYGZsq{}, \PYGZsq{}completed = YES\PYGZsq{},
purge\PYGZus{}options);
  END;
\end{sphinxVerbatim}

\newpage


\subsection{\index{START\_QUEUE}START\_QUEUE}
\label{\detokenize{start_queue::doc}}\label{\detokenize{start_queue:start-queue}}
Use the \sphinxcode{START\_QUEUE} procedure to make a queue available for enqueuing
and dequeueing.

The signature is:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{START\_QUEUE(}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \sphinxcode{\textless{}queue\_name\textgreater{} IN VARCHAR2},
\item[] \sphinxcode{\textless{}enqueue\textgreater{} IN BOOLEAN DEFAULT TRUE},
\item[] \sphinxcode{\textless{}dequeue\textgreater{} IN BOOLEAN DEFAULT TRUE)}
\end{DUlineblock}
\end{DUlineblock}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}queue\_name\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}queue\_name\textgreater{}} specifies the name of the queue that you are starting.
\end{quote}

\sphinxcode{\textless{}enqueue\textgreater{}}
\begin{quote}

Specify \sphinxcode{TRUE} to enable enqueueing (the default), or \sphinxcode{FALSE} to leave
the current setting unchanged.
\end{quote}

\sphinxcode{\textless{}dequeue\textgreater{}}
\begin{quote}

Specify \sphinxcode{TRUE} to enable dequeueing (the default), or \sphinxcode{FALSE} to leave
the current setting unchanged.
\end{quote}

\sphinxstylestrong{Example}

The following anonymous block makes a queue named \sphinxcode{work\_order} available
for enqueueing:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
BEGIN
DBMS\PYGZus{}AQADM.START\PYGZus{}QUEUE
(queue\PYGZus{}name =\PYGZgt{} \PYGZsq{}work\PYGZus{}order);
END;
\end{sphinxVerbatim}

\newpage


\subsection{\index{STOP\_QUEUE}STOP\_QUEUE}
\label{\detokenize{stop_queue:stop-queue}}\label{\detokenize{stop_queue::doc}}
Use the \sphinxcode{STOP\_QUEUE} procedure to disable enqueuing or dequeueing on a
specified queue.

The signature is:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{STOP\_QUEUE(}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \sphinxcode{\textless{}queue\_name\textgreater{} IN VARCHAR2},
\item[] \sphinxcode{\textless{}enqueue\textgreater{} IN BOOLEAN DEFAULT TRUE},
\item[] \sphinxcode{\textless{}dequeue\textgreater{} IN BOOLEAN DEFAULT TRUE},
\item[] \sphinxcode{\textless{}wait\textgreater{} IN BOOLEAN DEFAULT TRUE)}
\end{DUlineblock}
\end{DUlineblock}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}queue\_name\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}queue\_name\textgreater{}} specifies the name of the queue that you are stopping.
\end{quote}

\sphinxcode{\textless{}enqueu\textgreater{}}
\begin{quote}

Specify \sphinxcode{TRUE} to disable enqueueing (the default), or \sphinxcode{FALSE} to leave
the current setting unchanged.
\end{quote}

\sphinxcode{\textless{}dequeue\textgreater{}}
\begin{quote}

Specify \sphinxcode{TRUE} to disable dequeueing (the default), or \sphinxcode{FALSE} to leave
the current setting unchanged.
\end{quote}

\sphinxcode{\textless{}wait\textgreater{}}
\begin{quote}

Specify \sphinxcode{TRUE} to instruct the server to wait for any uncompleted
transactions to complete before applying the specified changes;
while waiting to stop the queue, no transactions are allowed to
enqueue or dequeue from the specified queue. Specify \sphinxcode{FALSE} to stop
the queue immediately.
\end{quote}

\sphinxstylestrong{Example}

The following anonymous block disables enqueueing and dequeueing from
the queue named \sphinxcode{work\_order}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
BEGIN
DBMS\PYGZus{}AQADM.STOP\PYGZus{}QUEUE(queue\PYGZus{}name =\PYGZgt{}\PYGZsq{}work\PYGZus{}order\PYGZsq{}, enqueue=\PYGZgt{}TRUE,
dequeue=\PYGZgt{}TRUE, wait=\PYGZgt{}TRUE);
END;
\end{sphinxVerbatim}

Enqueueing and dequeueing will stop after any outstanding transactions complete.

\newpage


\section{\index{DBMS\_CRYPTO}DBMS\_CRYPTO}
\label{\detokenize{dbms_crypto::doc}}\label{\detokenize{dbms_crypto:dbms-crypto}}
The \sphinxcode{DBMS\_CRYPTO} package provides functions and procedures that allow
you to encrypt or decrypt \sphinxcode{RAW, BLOB} or \sphinxcode{CLOB} data. You can also use
\sphinxcode{DBMS\_CRYPTO} functions to generate cryptographically strong random
values.

The following table lists the \sphinxcode{DBMS\_CRYPTO} Functions and Procedures.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|\Y{0.4}|\Y{0.1}|\Y{0.5}|}
\hline

Function/Procedure
&
Return Type
&
Description
\\
\hline
\sphinxcode{DECRYPT(src, typ, key, iv)}
&
\sphinxcode{RAW}
&
Decrypts \sphinxcode{RAW} data.
\\
\hline
\sphinxcode{DECRYPT(dst INOUT, src, typ, key, iv)}
&
N/A
&
Decrypts \sphinxcode{BLOB} data.
\\
\hline
\sphinxcode{DECRYPT(dst INOUT, src, typ, key, iv)}
&
N/A
&
Decrypts \sphinxcode{CLOB} data.
\\
\hline
\sphinxcode{ENCRYPT(src, typ, key, iv)}
&
\sphinxcode{RAW}
&
Encrypts \sphinxcode{RAW} data.
\\
\hline
\sphinxcode{ENCRYPT(dst INOUT, src, typ, key, iv)}
&
N/A
&
Encrypts \sphinxcode{BLOB} data.
\\
\hline
\sphinxcode{ENCRYPT(dst INOUT, src, typ, key, iv)}
&
N/A
&
Encrypts \sphinxcode{CLOB} data.
\\
\hline
\sphinxcode{HASH(src, typ)}
&
\sphinxcode{RAW}
&
Applies a hash algorithm to \sphinxcode{RAW} data.
\\
\hline
\sphinxcode{HASH(src)}
&
\sphinxcode{RAW}
&
Applies a hash algorithm to \sphinxcode{CLOB} data.
\\
\hline
\sphinxcode{MAC(src, typ, key)}
&
\sphinxcode{RAW}
&
Returns the hashed \sphinxcode{MAC} value of the given \sphinxcode{RAW} data using the specified
hash algorithm and key.
\\
\hline
\sphinxcode{MAC(src, typ, key)}
&
\sphinxcode{RAW}
&
Returns the hashed \sphinxcode{MAC} value of the given \sphinxcode{CLOB} data using the specified
hash algorithm and key.
\\
\hline
\sphinxcode{RANDOMBYTES(number\_bytes)}
&
\sphinxcode{RAW}
&
Returns a specified number of cryptographically strong random bytes.
\\
\hline
\sphinxcode{RANDOMINTEGER()}
&
\sphinxcode{INTEGER}
&
Returns a random \sphinxcode{INTEGER}.
\\
\hline
\sphinxcode{RANDOMNUMBER()}
&
\sphinxcode{NUMBER}
&
Returns a random \sphinxcode{NUMBER.}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxcode{DBMS\_CRYPTO} functions and procedures support the following error
messages:
\begin{quote}

\sphinxcode{ORA-28239 - DBMS\_CRYPTO.KeyNull}

\sphinxcode{ORA-28829 - DBMS\_CRYPTO.CipherSuiteNull}

\sphinxcode{ORA-28827 - DBMS\_CRYPTO.CipherSuiteInvalid}
\end{quote}

Unlike Oracle, Advanced Server will not return error \sphinxcode{ORA-28233} if you
re-encrypt previously encrypted information.

Please note that \sphinxcode{RAW} and \sphinxcode{BLOB} are synonyms for the PostgreSQL \sphinxcode{BYTEA} data
type, and \sphinxcode{CLOB} is a synonym for \sphinxcode{TEXT}.

\newpage


\subsection{\index{DECRYPT}DECRYPT}
\label{\detokenize{decrypt::doc}}\label{\detokenize{decrypt:decrypt}}
The \sphinxcode{DECRYPT} function or procedure decrypts data using a user-specified
cipher algorithm, key and optional initialization vector. The signature
of the \sphinxcode{DECRYPT} function is:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{DECRYPT}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \sphinxcode{(\textless{}src\textgreater{} IN RAW, \textless{}typ\textgreater{} IN INTEGER, \textless{}key\textgreater{} IN RAW, \textless{}iv\textgreater{} IN RAW}
\item[] \sphinxcode{DEFAULT NULL) RETURN RAW}
\end{DUlineblock}
\end{DUlineblock}
\end{quote}

The signature of the \sphinxcode{DECRYPT} procedure is:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{DECRYPT}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \sphinxcode{(\textless{}dst\textgreater{} INOUT BLOB, \textless{}src\textgreater{} IN BLOB, \textless{}typ\textgreater{} IN INTEGER, \textless{}key\textgreater{} IN RAW},
\item[] \sphinxcode{\textless{}iv\textgreater{} IN RAW DEFAULT NULL)}
\end{DUlineblock}
\end{DUlineblock}
\end{quote}

or
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{DECRYPT}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \sphinxcode{(\textless{}dst\textgreater{} INOUT CLOB, \textless{}src\textgreater{} IN CLOB, \textless{}typ\textgreater{} IN INTEGER, \textless{}key\textgreater{} IN RAW},
\item[] \sphinxcode{\textless{}iv\textgreater{} IN RAW DEFAULT NULL)}
\end{DUlineblock}
\end{DUlineblock}
\end{quote}

When invoked as a procedure, \sphinxcode{DECRYPT} returns \sphinxcode{BLOB} or \sphinxcode{CLOB} data to a
user-specified \sphinxcode{BLOB}.

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}dst\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}dst\textgreater{}} specifies the name of a \sphinxcode{BLOB} to which the output of the
\sphinxcode{DECRYPT} procedure will be written. The \sphinxcode{DECRYPT} procedure will
overwrite any existing data currently in \sphinxcode{\textless{}dst\textgreater{}}.
\end{quote}

\sphinxcode{\textless{}src\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}src\textgreater{}} specifies the source data that will be decrypted. If you are
invoking \sphinxcode{DECRYPT} as a function, specify \sphinxcode{RAW} data; if invoking
\sphinxcode{DECRYPT} as a procedure, specify \sphinxcode{BLOB} or \sphinxcode{CLOB} data.
\end{quote}

\sphinxcode{\textless{}typ\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}typ\textgreater{}} specifies the block cipher type and any modifiers. This should
match the type specified when the \sphinxcode{\textless{}src\textgreater{}} was encrypted. Advanced
Server supports the following block cipher algorithms, modifiers and
cipher suites:
\end{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{2}}
\sphinxstylethead{\sphinxstyletheadfamily \sphinxstylestrong{Block Cipher Algorithms}
\unskip}\relax \par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline
\sphinxcode{ENCRYPT\_DES}
&
\sphinxcode{CONSTANT INTEGER := 1;}
\\
\hline
\sphinxcode{ENCRYPT\_3DES}
&
\sphinxcode{CONSTANT INTEGER := 3;}
\\
\hline
\sphinxcode{ENCRYPT\_AES}
&
\sphinxcode{CONSTANT INTEGER := 4;}
\\
\hline
\sphinxcode{ENCRYPT\_AES128}
&
\sphinxcode{CONSTANT INTEGER := 6;}
\\
\hline\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{2}}
\sphinxstylestrong{Block Cipher Modifiers}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline
\sphinxcode{CHAIN\_CBC}
&
\sphinxcode{CONSTANT INTEGER := 256;}
\\
\hline
\sphinxcode{CHAIN\_ECB}
&
\sphinxcode{CONSTANT INTEGER := 768;}
\\
\hline\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{2}}
\sphinxstylestrong{Block Cipher Padding Modifiers}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline
\sphinxcode{PAD\_PKCS5}
&
\sphinxcode{CONSTANT INTEGER := 4096;}
\\
\hline
\sphinxcode{PAD\_NONE}
&
\sphinxcode{CONSTANT INTEGER := 8192;}
\\
\hline\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{2}}
\sphinxstylestrong{Block Cipher Suites}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline
\sphinxcode{DES\_CBC\_PKCS5}
&
\sphinxcode{CONSTANT INTEGER := ENCRYPT\_DES + CHAIN\_CBC + PAD\_PKCS5;}
\\
\hline
\sphinxcode{DES3\_CBC\_PKCS5}
&
\sphinxcode{CONSTANT INTEGER := ENCRYPT\_3DES + CHAIN\_CBC + PAD\_PKCS5;}
\\
\hline
\sphinxcode{AES\_CBC\_PKCS5}
&
\sphinxcode{CONSTANT INTEGER := ENCRYPT\_AES + CHAIN\_CBC + PAD\_PKCS5;}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\newpage

\sphinxcode{\textless{}key\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}key\textgreater{}} specifies the user-defined decryption key. This should match
the key specified when the \sphinxcode{\textless{}src\textgreater{}} was encrypted.
\end{quote}

\sphinxcode{\textless{}iv\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}iv\textgreater{}} (optional) specifies an initialization vector. If an
initialization vector was specified when the \sphinxcode{\textless{}src\textgreater{}} was encrypted,
you must specify an initialization vector when decrypting the \sphinxcode{\textless{}src\textgreater{}}.
The default is \sphinxcode{NULL}.
\end{quote}

\sphinxstylestrong{Examples}

The following example uses the \sphinxcode{DBMS\_CRYPTO.DECRYPT} function to decrypt
an encrypted password retrieved from the passwords table:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
CREATE TABLE passwords
(
   principal VARCHAR2(90) PRIMARY KEY, \PYGZhy{}\PYGZhy{} username
   ciphertext RAW(9) \PYGZhy{}\PYGZhy{} encrypted password
);

CREATE FUNCTION get\PYGZus{}password(username VARCHAR2) RETURN RAW AS
 typ       INTEGER := DBMS\PYGZus{}CRYPTO.DES\PYGZus{}CBC\PYGZus{}PKCS5;
 key       RAW(128) := \PYGZsq{}my secret key\PYGZsq{};
 iv        RAW(100) := \PYGZsq{}my initialization vector\PYGZsq{};
 password  RAW(2048);
 BEGIN
   SELECT ciphertext INTO password FROM passwords WHERE principal =
   username;
   RETURN dbms\PYGZus{}crypto.decrypt(password, typ, key, iv);
 END;
\end{sphinxVerbatim}

Note that when calling \sphinxcode{DECRYPT}, you must pass the same cipher type, key
value and initialization vector that was used when \sphinxcode{ENCRYPTING} the
target.

\newpage


\subsection{\index{ENCRYPT}ENCRYPT}
\label{\detokenize{encrypt::doc}}\label{\detokenize{encrypt:encrypt}}
The \sphinxcode{ENCRYPT} function or procedure uses a user-specified algorithm, key,
and optional initialization vector to encrypt \sphinxcode{RAW}, \sphinxcode{BLOB} or \sphinxcode{CLOB} data.
The signature of the \sphinxcode{ENCRYPT} function is:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{ENCRYPT}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \sphinxcode{(\textless{}src\textgreater{} IN RAW, \textless{}typ\textgreater{} IN INTEGER, \textless{}key\textgreater{} IN RAW},
\item[] \sphinxcode{\textless{}iv\textgreater{} IN RAW DEFAULT NULL) RETURN RAW}
\end{DUlineblock}
\end{DUlineblock}
\end{quote}

The signature of the \sphinxcode{ENCRYPT} procedure is:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{ENCRYPT}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \sphinxcode{(\textless{}dst\textgreater{} INOUT BLOB, \textless{}src\textgreater{} IN BLOB, \textless{}typ\textgreater{} IN INTEGER, \textless{}key\textgreater{} IN RAW},
\item[] \sphinxcode{\textless{}iv\textgreater{} IN RAW DEFAULT NULL)}
\end{DUlineblock}
\end{DUlineblock}
\end{quote}

or
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{ENCRYPT}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \sphinxcode{(\textless{}dst\textgreater{} INOUT BLOB, \textless{}src\textgreater{} IN CLOB, \textless{}typ\textgreater{} IN INTEGER, \textless{}key\textgreater{} IN RAW},
\item[] \sphinxcode{\textless{}iv\textgreater{} IN RAW DEFAULT NULL)}
\end{DUlineblock}
\end{DUlineblock}
\end{quote}

When invoked as a procedure, \sphinxcode{ENCRYPT} returns \sphinxcode{BLOB} or \sphinxcode{CLOB} data to a
user-specified \sphinxcode{BLOB}.

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}dst\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}dst\textgreater{}} specifies the name of a \sphinxcode{BLOB} to which the output of the
\sphinxcode{ENCRYPT} procedure will be written. The \sphinxcode{ENCRYPT} procedure will
overwrite any existing data currently in \sphinxcode{\textless{}dst\textgreater{}}.
\end{quote}

\sphinxcode{\textless{}src\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}src\textgreater{}} specifies the source data that will be encrypted. If you are
invoking \sphinxcode{ENCRYPT} as a function, specify \sphinxcode{RAW} data; if invoking
\sphinxcode{ENCRYPT} as a procedure, specify \sphinxcode{BLOB} or \sphinxcode{CLOB} data.
\end{quote}

\sphinxcode{\textless{}typ\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}typ\textgreater{}} specifies the block cipher type that will be used by \sphinxcode{ENCRYPT},
and any modifiers. Advanced Server supports the block cipher
algorithms, modifiers and cipher suites listed below:
\end{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{2}}
\sphinxstylethead{\sphinxstyletheadfamily \sphinxstylestrong{Block Cipher Algorithms}
\unskip}\relax \par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline
\sphinxcode{ENCRYPT\_DES}
&
\sphinxcode{CONSTANT INTEGER := 1;}
\\
\hline
\sphinxcode{ENCRYPT\_3DES}
&
\sphinxcode{CONSTANT INTEGER := 3;}
\\
\hline
\sphinxcode{ENCRYPT\_AES}
&
\sphinxcode{CONSTANT INTEGER := 4;}
\\
\hline
\sphinxcode{ENCRYPT\_AES128}
&
\sphinxcode{CONSTANT INTEGER := 6;}
\\
\hline\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{2}}
\sphinxstylestrong{Block Cipher Modifiers}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline
\sphinxcode{CHAIN\_CBC}
&
\sphinxcode{CONSTANT INTEGER := 256;}
\\
\hline
\sphinxcode{CHAIN\_ECB}
&
\sphinxcode{CONSTANT INTEGER := 768;}
\\
\hline\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{2}}
\sphinxstylestrong{Block Cipher Padding Modifiers}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline
{}`{}` PAD\_PKCS5{}`{}`
&
\sphinxcode{CONSTANT INTEGER := 4096;}
\\
\hline
\sphinxcode{PAD\_NONE}
&
\sphinxcode{CONSTANT INTEGER := 8192;}
\\
\hline\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{2}}
\sphinxstylestrong{Block Cipher Suites}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline
\sphinxcode{DES\_CBC\_PKCS5}
&
\sphinxcode{CONSTANT INTEGER := ENCRYPT\_DES + CHAIN\_CBC + PAD\_PKCS5;}
\\
\hline
\sphinxcode{DES3\_CBC\_PKCS5}
&
\sphinxcode{CONSTANT INTEGER := ENCRYPT\_3DES + CHAIN\_CBC + PAD\_PKCS5;}
\\
\hline
\sphinxcode{AES\_CBC\_PKCS5}
&
\sphinxcode{CONSTANT INTEGER := ENCRYPT\_AES + CHAIN\_CBC + PAD\_PKCS5;}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxcode{\textless{}key\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}key\textgreater{}} specifies the encryption key.
\end{quote}

\sphinxcode{\textless{}iv\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}iv\textgreater{}} (optional) specifies an initialization vector. By default, \sphinxcode{\textless{}iv\textgreater{}}
is \sphinxcode{NULL}.
\end{quote}

\sphinxstylestrong{Examples}

The following example uses the \sphinxcode{DBMS\_CRYPTO.DES\_CBC\_PKCS5} Block Cipher
Suite (a pre-defined set of algorithms and modifiers) to encrypt a value
retrieved from the \sphinxcode{passwords} table:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
CREATE TABLE passwords
(
 principal   VARCHAR2(90) PRIMARY KEY, \PYGZhy{}\PYGZhy{} username
 ciphertext  RAW(9) \PYGZhy{}\PYGZhy{} encrypted password
);
CREATE PROCEDURE set\PYGZus{}password(username VARCHAR2, cleartext RAW) AS
 typ         INTEGER := DBMS\PYGZus{}CRYPTO.DES\PYGZus{}CBC\PYGZus{}PKCS5;
 key         RAW(128) := \PYGZsq{}my secret key\PYGZsq{};
 iv          RAW(100) := \PYGZsq{}my initialization vector\PYGZsq{};
 encrypted   RAW(2048);
BEGIN
 encrypted := dbms\PYGZus{}crypto.encrypt(cleartext, typ, key, iv);
 UPDATE passwords SET ciphertext = encrypted WHERE principal =
 username;
END;
\end{sphinxVerbatim}

\sphinxcode{ENCRYPT} uses a key value of \sphinxcode{my secret key} and an initialization vector
of \sphinxcode{my initialization vector} when encrypting the \sphinxcode{password}; specify the
same key and initialization vector when decrypting the \sphinxcode{password}.

\newpage


\subsection{\index{HASH}HASH}
\label{\detokenize{hash::doc}}\label{\detokenize{hash:hash}}
The \sphinxcode{HASH} function uses a user-specified algorithm to return the hash
value of a \sphinxcode{RAW} or \sphinxcode{CLOB} value. The \sphinxcode{HASH} function is available in three
forms:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{HASH}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] (\sphinxcode{\textless{}src\textgreater{} IN RAW, \textless{}typ\textgreater{} IN INTEGER) RETURN RAW}
\end{DUlineblock}
\end{DUlineblock}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{HASH}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] (\sphinxcode{\textless{}src\textgreater{} IN CLOB, \textless{}typ\textgreater{} IN INTEGER) RETURN RAW}
\end{DUlineblock}
\end{DUlineblock}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}src\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}src\textgreater{}} specifies the value for which the hash value will be
generated. You can specify a \sphinxcode{RAW}, a \sphinxcode{BLOB}, or a \sphinxcode{CLOB} value.
\end{quote}

\sphinxcode{\textless{}typ\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}typ\textgreater{}} specifies the \sphinxcode{HASH} function type. Advanced Server supports the
\sphinxcode{HASH} function types listed below:
\end{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{2}}
\sphinxstylethead{\sphinxstyletheadfamily \sphinxstylestrong{HASH Functions}
\unskip}\relax \par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline
\sphinxcode{HASH\_MD4}
&
\sphinxcode{CONSTANT INTEGER := 1;}
\\
\hline
\sphinxcode{HASH\_MD5}
&
\sphinxcode{CONSTANT INTEGER := 2;}
\\
\hline
\sphinxcode{HASH\_SH1}
&
\sphinxcode{CONSTANT INTEGER := 3;}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxstylestrong{Examples}

The following example uses \sphinxcode{DBMS\_CRYPTO.HASH} to find the \sphinxcode{md5} hash value
of the string, \sphinxcode{cleartext source}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
  typ INTEGER := DBMS\PYGZus{}CRYPTO.HASH\PYGZus{}MD5;
  hash\PYGZus{}value RAW(100);
BEGIN

  hash\PYGZus{}value := DBMS\PYGZus{}CRYPTO.HASH(\PYGZsq{}cleartext source\PYGZsq{}, typ);

END;
\end{sphinxVerbatim}

\newpage


\subsection{\index{MAC}MAC}
\label{\detokenize{mac::doc}}\label{\detokenize{mac:mac}}
The \sphinxcode{MAC} function uses a user-specified \sphinxcode{MAC} function to return the hashed
\sphinxcode{MAC} value of a \sphinxcode{RAW} or \sphinxcode{CLOB} value. The \sphinxcode{MAC} function is available in three
forms:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{MAC}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \sphinxcode{(\textless{}src\textgreater{} IN RAW, \textless{}typ\textgreater{} IN INTEGER, \textless{}key\textgreater{} IN RAW) RETURN RAW}
\end{DUlineblock}
\end{DUlineblock}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{MAC}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \sphinxcode{(\textless{}src\textgreater{} IN CLOB, \textless{}typ\textgreater{} IN INTEGER, \textless{}key\textgreater{} IN RAW) RETURN RAW}
\end{DUlineblock}
\end{DUlineblock}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}src\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}src\textgreater{}} specifies the value for which the \sphinxcode{MAC} value will be generated.
Specify a \sphinxcode{RAW}, \sphinxcode{BLOB}, or \sphinxcode{CLOB} value.
\end{quote}

\sphinxcode{\textless{}typ\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}typ\textgreater{}} specifies the \sphinxcode{MAC} function used. Advanced Server supports the
\sphinxcode{MAC} functions listed below.
\end{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{2}}
\sphinxstylethead{\sphinxstyletheadfamily \sphinxstylestrong{MAC Functions}
\unskip}\relax \par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline
\sphinxcode{HMAC\_MD5}
&
\sphinxcode{CONSTANT INTEGER := 1;}
\\
\hline
\sphinxcode{HMAC\_SH1}
&
\sphinxcode{CONSTANT INTEGER := 2;}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxcode{\textless{}key\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}key\textgreater{}} specifies the key that will be used to calculate the hashed
\sphinxcode{MAC} value.
\end{quote}

\sphinxstylestrong{Examples}

The following example finds the hashed \sphinxcode{MAC} value of the string cleartext
source:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
  typ INTEGER := DBMS\PYGZus{}CRYPTO.HMAC\PYGZus{}MD5;
  key RAW(100) := \PYGZsq{}my secret key\PYGZsq{};
  mac\PYGZus{}value RAW(100);
BEGIN

  mac\PYGZus{}value := DBMS\PYGZus{}CRYPTO.MAC(\PYGZsq{}cleartext source\PYGZsq{}, typ, key);

END;
\end{sphinxVerbatim}

\sphinxcode{DBMS\_CRYPTO.MAC} uses a key value of \sphinxcode{my secret} key when calculating the
\sphinxcode{MAC} value of \sphinxcode{cleartext source}.

\newpage


\subsection{\index{RANDOMBYTES}RANDOMBYTES}
\label{\detokenize{randombytes::doc}}\label{\detokenize{randombytes:randombytes}}
The \sphinxcode{RANDOMBYTES} function returns a \sphinxcode{RAW} value of the specified length,
containing cryptographically random bytes. The signature is:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{RANDOMBYTES}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \sphinxcode{(\textless{}number\_bytes\textgreater{} IN INTEGER) RETURNS RAW}
\end{DUlineblock}
\end{DUlineblock}
\end{quote}

\sphinxstylestrong{Parameter}

\sphinxcode{\textless{}number\_bytes\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}number\_bytes\textgreater{}} specifies the number of random bytes to be returned
\end{quote}

\sphinxstylestrong{Examples}

The following example uses \sphinxcode{RANDOMBYTES} to return a value that is 1024
bytes long:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
  result RAW(1024);
BEGIN
  result := DBMS\PYGZus{}CRYPTO.RANDOMBYTES(1024);
END;
\end{sphinxVerbatim}

\newpage


\subsection{\index{RANDOMINTEGER}RANDOMINTEGER}
\label{\detokenize{randominteger::doc}}\label{\detokenize{randominteger:randominteger}}
The \sphinxcode{RANDOMINTEGER()} function returns a random \sphinxcode{INTEGER} between \sphinxcode{0} and
\sphinxcode{268,435,455}. The signature is:
\begin{quote}

\sphinxcode{RANDOMINTEGER() RETURNS INTEGER}
\end{quote}

\sphinxstylestrong{Examples}

The following example uses the \sphinxcode{RANDOMINTEGER} function to return a
cryptographically strong random \sphinxcode{INTEGER} value:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
  result INTEGER;
BEGIN
  result := DBMS\PYGZus{}CRYPTO.RANDOMINTEGER();
  DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(result);
END;
\end{sphinxVerbatim}

\newpage


\subsection{\index{RANDOMNUMBER}RANDOMNUMBER}
\label{\detokenize{randomnumber::doc}}\label{\detokenize{randomnumber:randomnumber}}
The \sphinxcode{RANDOMNUMBER()} function returns a random \sphinxcode{NUMBER} between \sphinxcode{0} and
\sphinxcode{268,435,455}. The signature is:
\begin{quote}

\sphinxcode{RANDOMNUMBER() RETURNS NUMBER}
\end{quote}

\sphinxstylestrong{Examples}

The following example uses the \sphinxcode{RANDOMNUMBER} function to return a
cryptographically strong random number:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
  result NUMBER;
BEGIN
  result := DBMS\PYGZus{}CRYPTO.RANDOMNUMBER();
  DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(result);
END;
\end{sphinxVerbatim}

\newpage


\section{\index{DBMS\_JOB}DBMS\_JOB}
\label{\detokenize{dbms_job::doc}}\label{\detokenize{dbms_job:dbms-job}}
The \sphinxcode{DBMS\_JOB} package provides for the creation, scheduling, and
managing of jobs. A job runs a stored procedure which has been
previously stored in the database. The \sphinxcode{SUBMIT} procedure is used to
create and store a job definition. A job identifier is assigned to a job
along with its associated stored procedure and the attributes describing
when and how often the job is to be run.

This package relies on the \sphinxcode{pgAgent} scheduler. By default, the Advanced
Server installer installs \sphinxcode{pgAgent}, but you must start the \sphinxcode{pgAgent}
service manually prior to using \sphinxcode{DBMS\_JOB}. If you attempt to use this
package to schedule a job after un-installing \sphinxcode{pgAgent, DBMS\_JOB} will
throw an error. \sphinxcode{DBMS\_JOB} verifies that \sphinxcode{pgAgent} is installed, but does
not verify that the service is running.

The following table lists the supported \sphinxcode{DBMS\_JOB} procedures:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|\Y{0.4}|\Y{0.1}|\Y{0.5}|}
\hline

\sphinxstylestrong{Function/Procedure}
&
\sphinxstylestrong{Return Type}
&
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{BROKEN(\textless{}job\textgreater{}, \textless{}broken\textgreater{} {[}, \textless{}next\_date\textgreater{} {]})}
&
n/a
&
Specify that a given job is either broken or not broken.
\\
\hline
\sphinxcode{CHANGE(\textless{}job, \textless{}what\textgreater{}, \textless{}next\_date\textgreater{}, \textless{}interval, instance, force\textgreater{})}
&
n/a
&
Change the job’s parameters.
\\
\hline
\sphinxcode{INTERVAL(\textless{}job\textgreater{}, \textless{}interval\textgreater{})}
&
n/a
&
Set the execution frequency by means of a date function that is recalculated each time the job is run. This value becomes the next date/time for execution.
\\
\hline
\sphinxcode{NEXT\_DATE(\textless{}job\textgreater{}, \textless{}next\_date\textgreater{})}
&
n/a
&
Set the next date/time the job is to be run.
\\
\hline
\sphinxcode{REMOVE(\textless{}job\textgreater{})}
&
n/a
&
Delete the job definition from the database.
\\
\hline
\sphinxcode{RUN(\textless{}job\textgreater{})}
&
n/a
&
Forces execution of a job even if it is marked broken.
\\
\hline
\sphinxcode{SUBMIT(\textless{}job\textgreater{} OUT, \textless{}what\textgreater{} {[}, \textless{}next\_date\textgreater{} {[}, \textless{}interval\textgreater{} {[}, \textless{}no\_parse\textgreater{} {]}{]}{]})}
&
n/a
&
Creates a job and stores its definition in the database.
\\
\hline
\sphinxcode{WHAT(\textless{}job\textgreater{}, \textless{}what\textgreater{})}
&
n/a
&
Change the stored procedure run by a job.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Advanced Server’s implementation of \sphinxcode{DBMS\_JOB} is a partial
implementation when compared to Oracle’s version. Only those functions
and procedures listed in the table above are supported.

Before using \sphinxcode{DBMS\_JOB}, a database superuser must create the \sphinxcode{pgAgent}
extension. Use the \sphinxcode{psql} client to connect to a database and invoke the
command:
\begin{quote}

\sphinxcode{CREATE EXTENSION pgagent};
\end{quote}

When and how often a job is run is dependent upon two interacting
parameters \textendash{} \sphinxcode{\textless{}next\_date\textgreater{}} and \sphinxcode{\textless{}interval\textgreater{}}. The \sphinxcode{\textless{}next\_date\textgreater{}} parameter is
a date/time value that specifies the next date/time when the job is to
be executed. The \sphinxcode{\textless{}interval\textgreater{}} parameter is a string that contains a date
function that evaluates to a date/time value.

Just prior to any execution of the job, the expression in the \sphinxcode{\textless{}interval\textgreater{}}
parameter is evaluated. The resulting value replaces the \sphinxcode{\textless{}next\_date\textgreater{}}
value stored with the job. The job is then executed. In this manner, the
expression in \sphinxcode{\textless{}interval\textgreater{}} is repeatedly re-evaluated prior to each job
execution, supplying the \sphinxcode{\textless{}next\_date\textgreater{}} date/time for the next execution.

The following examples use the following stored procedure, \sphinxcode{job\_proc},
which simply inserts a timestamp into table, \sphinxcode{jobrun}, containing a single
\sphinxcode{VARCHAR2} column.

\newpage

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
CREATE TABLE jobrun (
       runtime VARCHAR2(40)
);

CREATE OR REPLACE PROCEDURE job\PYGZus{}proc
IS
BEGIN
    INSERT INTO jobrun VALUES (\PYGZsq{}job\PYGZus{}proc run at \PYGZsq{} \textbar{}\textbar{} TO\PYGZus{}CHAR(SYSDATE,
        \PYGZsq{}yyyy\PYGZhy{}mm\PYGZhy{}dd hh24:mi:ss\PYGZsq{}));
END;
\end{sphinxVerbatim}

\newpage


\subsection{\index{BROKEN}BROKEN}
\label{\detokenize{broken::doc}}\label{\detokenize{broken:broken}}
The \sphinxcode{BROKEN} procedure sets the state of a job to either broken or not
broken. A broken job cannot be executed except by using the \sphinxcode{RUN}
procedure.

\sphinxcode{BROKEN(\textless{}job\textgreater{} BINARY\_INTEGER, \textless{}broken\textgreater{} BOOLEAN {[}, \textless{}next\_date\textgreater{} DATE {]})}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}job\textgreater{}}
\begin{quote}

Identifier of the job to be set as broken or not broken.
\end{quote}

\sphinxcode{\textless{}broken\textgreater{}}
\begin{quote}

If set to \sphinxcode{TRUE} the job’s state is set to broken. If set to \sphinxcode{FALSE} the
job’s state is set to not broken. Broken jobs cannot be run except by
using the \sphinxcode{RUN} procedure.
\end{quote}

\sphinxcode{\textless{}next\_date\textgreater{}}
\begin{quote}

Date/time when the job is to be run. The default is \sphinxcode{SYSDATE}.
\end{quote}

\sphinxstylestrong{Examples}

Set the state of a job with job identifier 104 to broken:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
BEGIN
   DBMS\PYGZus{}JOB.BROKEN(104,true);
END;
\end{sphinxVerbatim}

Change the state back to not broken:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
BEGIN
   DBMS\PYGZus{}JOB.BROKEN(104,false);
END;
\end{sphinxVerbatim}

\newpage


\subsection{\index{CHANGE}CHANGE}
\label{\detokenize{change:change}}\label{\detokenize{change::doc}}
The \sphinxcode{CHANGE} procedure modifies certain job attributes including the
stored procedure to be run, the next date/time the job is to be run, and
how often it is to be run.

\sphinxcode{CHANGE(\textless{}job\textgreater{} BINARY\_INTEGER \textless{}what\textgreater{} VARCHAR2, \textless{}next\_date\textgreater{} DATE,}
\begin{quote}

\sphinxcode{\textless{}interval\textgreater{} VARCHAR2, \textless{}instance\textgreater{} BINARY\_INTEGER, \textless{}force\textgreater{} BOOLEAN)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}job\textgreater{}}
\begin{quote}

Identifier of the job to modify.
\end{quote}

\sphinxcode{\textless{}what\textgreater{}}
\begin{quote}

Stored procedure name. Set this parameter to null if the existing value
is to remain unchanged.
\end{quote}

\sphinxcode{\textless{}next\_date\textgreater{}}
\begin{quote}

Date/time when the job is to be run next. Set this parameter to null if
the existing value is to remain unchanged.
\end{quote}

\sphinxcode{\textless{}interval\textgreater{}}
\begin{quote}

Date function that when evaluated, provides the next date/time the job
is to run. Set this parameter to null if the existing value is to remain
unchanged.
\end{quote}

\sphinxcode{\textless{}instance\textgreater{}}
\begin{quote}

This argument is ignored, but is included for compatibility.
\end{quote}

\sphinxcode{\textless{}force\textgreater{}}
\begin{quote}

This argument is ignored, but is included for compatibility.
\end{quote}

\sphinxstylestrong{Examples}

Change the job to run next on December 13, 2007. Leave other parameters
unchanged.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
BEGIN

   DBMS\PYGZus{}JOB.CHANGE(104,NULL,TO\PYGZus{}DATE(\PYGZsq{}13\PYGZhy{}DEC\PYGZhy{}07\PYGZsq{},\PYGZsq{}DD\PYGZhy{}MON\PYGZhy{}YY\PYGZsq{}),NULL, NULL,

   NULL);

END;
\end{sphinxVerbatim}

\newpage


\subsection{\index{INTERVAL}INTERVAL}
\label{\detokenize{interval::doc}}\label{\detokenize{interval:interval}}
The \sphinxcode{INTERVAL} procedure sets the frequency of how often a job is to be
run.

\sphinxcode{INTERVAL(\textless{}job\textgreater{} BINARY\_INTEGER, \textless{}interval\textgreater{} VARCHAR2)}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}job\textgreater{}}
\begin{quote}

Identifier of the job to modify.
\end{quote}

\sphinxcode{\textless{}interval\textgreater{}}
\begin{quote}

Date function that when evaluated, provides the next date/time the job
is to be run. If \sphinxcode{\textless{}interval\textgreater{}} is \sphinxcode{NULL} and the job is complete, the job is
removed from the queue.
\end{quote}

\sphinxstylestrong{Examples}

Change the job to run once a week:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
BEGIN

   DBMS\PYGZus{}JOB.INTERVAL(104,\PYGZsq{}SYSDATE + 7\PYGZsq{});

END;
\end{sphinxVerbatim}

\newpage


\subsection{\index{NEXT\_DATE}NEXT\_DATE}
\label{\detokenize{next_date::doc}}\label{\detokenize{next_date:next-date}}
The \sphinxcode{NEXT\_DATE} procedure sets the date/time of when the job is to be run
next.

\sphinxcode{NEXT\_DATE(\textless{}job\textgreater{} BINARY\_INTEGER, \textless{}next\_date\textgreater{} DATE)}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}job\textgreater{}}
\begin{quote}

Identifier of the job whose next run date is to be set.
\end{quote}

\sphinxcode{\textless{}next\_date\textgreater{}}
\begin{quote}

Date/time when the job is to be run next.
\end{quote}

\sphinxstylestrong{Examples}

Change the job to run next on December 14, 2007:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
BEGIN

  DBMS\PYGZus{}JOB.NEXT\PYGZus{}DATE(104, TO\PYGZus{}DATE(\PYGZsq{}14\PYGZhy{}DEC\PYGZhy{}07\PYGZsq{},\PYGZsq{}DD\PYGZhy{}MON\PYGZhy{}YY\PYGZsq{}));

END;
\end{sphinxVerbatim}

\newpage

\index{DBMS\_JOB\_Remove}\ignorespaces 

\subsection{REMOVE}
\label{\detokenize{remove::doc}}\label{\detokenize{remove:index-0}}\label{\detokenize{remove:remove}}
The \sphinxcode{REMOVE} procedure deletes the specified job from the database. The
job must be resubmitted using the \sphinxcode{SUBMIT} procedure in order to have it
executed again. Note that the stored procedure that was associated with
the job is not deleted.

\sphinxcode{REMOVE(\textless{}job\textgreater{} BINARY\_INTEGER)}

\sphinxstylestrong{Parameter}

\sphinxcode{\textless{}job\textgreater{}}
\begin{quote}

Identifier of the job that is to be removed from the database.
\end{quote}

\sphinxstylestrong{Examples}

Remove a job from the database:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
BEGIN

   DBMS\PYGZus{}JOB.REMOVE(104);

END;
\end{sphinxVerbatim}

\newpage


\subsection{\index{RUN}RUN}
\label{\detokenize{run::doc}}\label{\detokenize{run:run}}
The \sphinxcode{RUN} procedure forces the job to be run, even if its state is broken.

\sphinxcode{RUN(\textless{}job\textgreater{} BINARY\_INTEGER)}

\sphinxstylestrong{Parameter}

\sphinxcode{\textless{}job\textgreater{}}
\begin{quote}

Identifier of the job to be run.
\end{quote}

\sphinxstylestrong{Examples}

Force a job to be run.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
BEGIN

   DBMS\PYGZus{}JOB.RUN(104);

END;
\end{sphinxVerbatim}

\newpage


\subsection{\index{SUBMIT}SUBMIT}
\label{\detokenize{submit::doc}}\label{\detokenize{submit:submit}}
The \sphinxcode{SUBMIT} procedure creates a job definition and stores it in the
database. A job consists of a job identifier, the stored procedure to be
executed, when the job is to be first run, and a date function that
calculates the next date/time the job is to be run.

\sphinxcode{SUBMIT(\textless{}job\textgreater{} OUT BINARY\_INTEGER, \textless{}what\textgreater{} VARCHAR2}

\sphinxcode{{[}, \textless{}next\_date\textgreater{} DATE {[}, \textless{}interval\textgreater{} VARCHAR2 {[}, \textless{}no\_parse\textgreater{} BOOLEAN {]}{]}{]})}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}job\textgreater{}}
\begin{quote}

Identifier assigned to the job.
\end{quote}

\sphinxcode{\textless{}what\textgreater{}}
\begin{quote}

Name of the stored procedure to be executed by the job.
\end{quote}

\sphinxcode{\textless{}next\_date\textgreater{}}
\begin{quote}

Date/time when the job is to be run next. The default is \sphinxcode{SYSDATE}.
\end{quote}

\sphinxcode{\textless{}interval\textgreater{}}
\begin{quote}

Date function that when evaluated, provides the next date/time the job
is to run. If \sphinxcode{\textless{}interval\textgreater{}} is set to null, then the job is run only once.
Null is the default.
\end{quote}

\sphinxcode{\textless{}no\_parse\textgreater{}}
\begin{quote}

If set to \sphinxcode{TRUE}, do not syntax-check the stored procedure upon job
creation \textendash{} check only when the job first executes. If set to \sphinxcode{FALSE},
check the procedure upon job creation. The default is \sphinxcode{FALSE}.

\begin{sphinxadmonition}{note}{Note:}
The \sphinxcode{\textless{}no\_parse\textgreater{}} option is not supported in this implementation of \sphinxcode{SUBMIT()}. It is included for compatibility only.
\end{sphinxadmonition}
\end{quote}

\sphinxstylestrong{Examples}

The following example creates a job using stored procedure, \sphinxcode{job\_proc}.
The job will execute immediately and run once a day thereafter as set by
the \sphinxcode{\textless{}interval\textgreater{}} parameter, \sphinxcode{SYSDATE + 1}.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
   jobid INTEGER;
BEGIN
   DBMS\PYGZus{}JOB.SUBMIT(jobid,\PYGZsq{}job\PYGZus{}proc;\PYGZsq{},SYSDATE,
       \PYGZsq{}SYSDATE + 1\PYGZsq{});
   DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}jobid: \PYGZsq{} \textbar{}\textbar{} jobid);
END;

jobid: 104
\end{sphinxVerbatim}

The job immediately executes procedure, \sphinxcode{job\_proc}, populating table,
jobrun, with a row:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
SELECT * FROM jobrun;

               runtime

\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
  job\PYGZus{}proc run at 2007\PYGZhy{}12\PYGZhy{}11 11:43:25
  (1 row)
\end{sphinxVerbatim}

\newpage


\subsection{\index{WHAT}WHAT}
\label{\detokenize{what::doc}}\label{\detokenize{what:what}}
The \sphinxcode{WHAT} procedure changes the stored procedure that the job will
execute.

\sphinxcode{WHAT(\textless{}job\textgreater{} BINARY\_INTEGER, \textless{}what\textgreater{} VARCHAR2)}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}job\textgreater{}}
\begin{quote}

Identifier of the job for which the stored procedure is to be changed.
\end{quote}

\sphinxcode{\textless{}what\textgreater{}}
\begin{quote}

Name of the stored procedure to be executed.
\end{quote}

Examples

Change the job to run the \sphinxcode{list\_emp} procedure:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
BEGIN

   DBMS\PYGZus{}JOB.WHAT(104,\PYGZsq{}list\PYGZus{}emp;\PYGZsq{});

END;
\end{sphinxVerbatim}

\newpage


\section{\index{DBMS\_LOB}DBMS\_LOB}
\label{\detokenize{dbms_lob::doc}}\label{\detokenize{dbms_lob:dbms-lob}}
The \sphinxcode{DBMS\_LOB} package provides the capability to operate on large
objects. The following table lists the supported functions and
procedures:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|\Y{0.4}|\Y{0.2}|\Y{0.4}|}
\hline

\sphinxstylestrong{Function/Procedure}
&
\sphinxstylestrong{Return Type}
&
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{APPEND(\textless{}dest\_lob\textgreater{} IN OUT, \textless{}src\_lob\textgreater{})}
&
n/a
&
Appends one large object to another.
\\
\hline
\sphinxcode{COMPARE(\textless{}lob\_1\textgreater{}, \textless{}lob\_2\textgreater{} {[}, \textless{}amount\textgreater{} {[}, \textless{}offset\_1\textgreater{} {[}, \textless{}offset\_2\textgreater{} {]}{]}{]})}
&
\sphinxcode{INTEGER}
&
Compares two large objects.
\\
\hline
\sphinxcode{CONVERTOBLOB(\textless{}dest\_lob\textgreater{} IN OUT, \textless{}src\_clob\textgreater{}, \textless{}amount\textgreater{}, \textless{}dest\_offset\textgreater{} IN OUT, \textless{}src\_offset\textgreater{} IN OUT, \textless{}blob\_csid\textgreater{}, \textless{}lang\_context\textgreater{} IN OUT, \textless{}warning\textgreater{} OUT)}
&
n/a
&
Converts character data to binary.
\\
\hline
\sphinxcode{CONVERTTOCLOB(\textless{}dest\_lob\textgreater{} IN OUT, \textless{}src\_blob\textgreater{}, \textless{}amount\textgreater{}, \textless{}dest\_offset\textgreater{} IN OUT, \textless{}src\_offset\textgreater{} IN OUT, \textless{}blob\_csid\textgreater{}, \textless{}lang\_context\textgreater{} IN OUT, \textless{}warning\textgreater{} OUT)}
&
n/a
&
Converts binary data to character.
\\
\hline
\sphinxcode{COPY(\textless{}dest\_lob\textgreater{} IN OUT, \textless{}src\_lob\textgreater{}, \textless{}amount\textgreater{} {[}, \textless{}dest\_offset\textgreater{} {[}, \textless{}src\_offset\textgreater{} {]}{]})}
&
n/a
&
Copies one large object to another.
\\
\hline
\sphinxcode{ERASE(lob\_loc IN OUT, \textless{}amount\textgreater{} IN OUT {[}, \textless{}offset\textgreater{} {]})}
&
n/a
&
Erase a large object.
\\
\hline
\sphinxcode{GET\_STORAGE\_LIMIT(\textless{}lob\_loc\textgreater{})}
&
\sphinxcode{INTEGER}
&
Get the storage limit for large objects.
\\
\hline
\sphinxcode{GETLENGTH(\textless{}lob\_loc\textgreater{})}
&
\sphinxcode{INTEGER}
&
Get the length of the large object.
\\
\hline
\sphinxcode{INSTR(\textless{}lob\_loc\textgreater{}, \textless{}pattern\textgreater{} {[}, \textless{}offset\textgreater{} {[}, \textless{}nth\textgreater{} {]}{]})}
&
\sphinxcode{INTEGER}
&
Get the position of the nth occurrence of a pattern in the large object starting at \sphinxcode{\textless{}offset\textgreater{}}
\\
\hline
\sphinxcode{READ(\textless{}lob\_loc\textgreater{}, \textless{}amount\textgreater{} IN OUT, \textless{}offset\textgreater{}, \textless{}buffer\textgreater{} OUT)}
&
n/a
&
Read a large object.
\\
\hline
\sphinxcode{SUBSTR(\textless{}lob\_loc\textgreater{} {[}, \textless{}amount\textgreater{} {[}, \textless{}offset\textgreater{} {]}{]})}
&
\sphinxcode{RAW, VARCHAR2}
&
Get part of a large object.
\\
\hline
\sphinxcode{TRIM(\textless{}lob\_loc\textgreater{} IN OUT, \textless{}newlen\textgreater{})}
&
n/a
&
Trim a large object to the specified length.
\\
\hline
\sphinxcode{WRITE(\textless{}lob\_loc\textgreater{} IN OUT, \textless{}amount\textgreater{}, \textless{}offset\textgreater{}, \textless{}buffer\textgreater{})}
&
n/a
&
Write data to a large object.
\\
\hline
\sphinxcode{WRITEAPPEND(\textless{}lob\_loc\textgreater{} IN OUT, \textless{}amount\textgreater{}, \textless{}buffer\textgreater{})}
&
n/a
&
Write data from the buffer to the end of a large object.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Advanced Server’s implementation of \sphinxcode{DBMS\_LOB} is a partial
implementation when compared to Oracle’s version. Only those functions
and procedures listed in the table above are supported.

The following table lists the public variables available in the package.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxstylestrong{Public Variables}
&
\sphinxstylestrong{Data Type}
&
\sphinxstylestrong{Value}
\\
\hline
\sphinxcode{compress off}
&
\sphinxcode{INTEGER}
&
\sphinxcode{0}
\\
\hline
\sphinxcode{compress\_on}
&
\sphinxcode{INTEGER}
&
\sphinxcode{1}
\\
\hline
\sphinxcode{deduplicate\_off}
&
\sphinxcode{INTEGER}
&
\sphinxcode{0}
\\
\hline
\sphinxcode{deduplicate\_on}
&
\sphinxcode{INTEGER}
&
\sphinxcode{4}
\\
\hline
\sphinxcode{default\_csid}
&
\sphinxcode{INTEGER}
&
\sphinxcode{0}
\\
\hline
\sphinxcode{default\_lang\_ctx}
&
\sphinxcode{INTEGER}
&
\sphinxcode{0}
\\
\hline
\sphinxcode{encrypt\_off}
&
\sphinxcode{INTEGER}
&
\sphinxcode{0}
\\
\hline
\sphinxcode{encrypt\_on}
&
\sphinxcode{INTEGER}
&
\sphinxcode{1}
\\
\hline
\sphinxcode{file\_readonly}
&
\sphinxcode{INTEGER}
&
\sphinxcode{0}
\\
\hline
\sphinxcode{lobmaxsize}
&
\sphinxcode{INTEGER}
&
\sphinxcode{1073741823}
\\
\hline
\sphinxcode{lob\_readonly}
&
\sphinxcode{INTEGER}
&
\sphinxcode{0}
\\
\hline
\sphinxcode{lob\_readwrite}
&
\sphinxcode{INTEGER}
&
\sphinxcode{1}
\\
\hline
\sphinxcode{no\_warning}
&
\sphinxcode{INTEGER}
&
\sphinxcode{0}
\\
\hline
\sphinxcode{opt\_compress}
&
\sphinxcode{INTEGER}
&
\sphinxcode{1}
\\
\hline
\sphinxcode{opt\_deduplicate}
&
\sphinxcode{INTEGER}
&
\sphinxcode{4}
\\
\hline
\sphinxcode{opt\_encrypt}
&
\sphinxcode{INTEGER}
&
\sphinxcode{2}
\\
\hline
\sphinxcode{warn\_inconvertible\_char}
&
\sphinxcode{INTEGER}
&
\sphinxcode{1}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

In the following sections, lengths and offsets are measured in bytes if
the large objects are \sphinxcode{BLOBs}. Lengths and offsets are measured in
characters if the large objects are \sphinxcode{CLOBs}.

\newpage


\subsection{\index{APPEND}APPEND}
\label{\detokenize{append::doc}}\label{\detokenize{append:append}}
The \sphinxcode{APPEND} procedure provides the capability to append one large object
to another. Both large objects must be of the same type.

\sphinxcode{APPEND(\textless{}dest\_lob\textgreater{} IN OUT \{ BLOB \textbar{} CLOB \}, \textless{}src\_lob\textgreater{} \{ BLOB \textbar{} CLOB
\})}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}dest\_lob\textgreater{}}
\begin{quote}

Large object locator for the destination object. Must be the same data
type as \sphinxcode{\textless{}src\_lob\textgreater{}}.
\end{quote}

\sphinxcode{\textless{}src\_lob\textgreater{}}
\begin{quote}

Large object locator for the source object. Must be the same data type
as \sphinxcode{\textless{}dest\_lob\textgreater{}}.
\end{quote}

\newpage


\subsection{\index{COMPARE}COMPARE}
\label{\detokenize{compare::doc}}\label{\detokenize{compare:compare}}
The \sphinxcode{COMPARE} procedure performs an exact byte-by-byte comparison of two
large objects for a given length at given offsets. The large objects
being compared must be the same data type.

\sphinxcode{\textless{}status\textgreater{} INTEGER COMPARE(\textless{}lob\_1\textgreater{} \{ BLOB \textbar{} CLOB \}},
\begin{quote}

\sphinxcode{\textless{}lob\_2\textgreater{} \{ BLOB \textbar{} CLOB \}}

\sphinxcode{{[}, \textless{}amount\textgreater{} INTEGER {[}, \textless{}offset\_1\textgreater{} INTEGER {[}, \textless{}offset\_2\textgreater{} INTEGER {]}{]}{]})}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}lob\_1\textgreater{}}
\begin{quote}

Large object locator of the first large object to be compared. Must be
the same data type as \sphinxcode{\textless{}lob\_2\textgreater{}}.
\end{quote}

\sphinxcode{\textless{}lob\_2\textgreater{}}
\begin{quote}

Large object locator of the second large object to be compared. Must be
the same data type as \sphinxcode{\textless{}lob\_1\textgreater{}}.
\end{quote}

\sphinxcode{\textless{}amount\textgreater{}}
\begin{quote}

If the data type of the large objects is \sphinxcode{BLOB}, then the comparison is
made for \sphinxcode{\textless{}amount\textgreater{}} bytes. If the data type of the large objects is \sphinxcode{CLOB},
then the comparison is made for \sphinxcode{\textless{}amount\textgreater{}} characters. The default is the
maximum size of a large object.
\end{quote}

\sphinxcode{\textless{}offset\_1\textgreater{}}
\begin{quote}

Position within the first large object to begin the comparison. The
first byte/character is offset 1. The default is 1.
\end{quote}

\sphinxcode{\textless{}offset\_2\textgreater{}}
\begin{quote}

Position within the second large object to begin the comparison. The
first byte/character is offset 1. The default is 1.
\end{quote}

\sphinxcode{\textless{}status\textgreater{}}
\begin{quote}

Zero if both large objects are exactly the same for the specified length
for the specified offsets. Non-zero, if the objects are not the same.
\sphinxcode{\textless{}NULL\textgreater{}} if \sphinxcode{\textless{}amount\textgreater{}}, \sphinxcode{\textless{}offset\_1\textgreater{}}, or \sphinxcode{\textless{}offset\_2\textgreater{}} are less than zero.
\end{quote}

\newpage


\subsection{\index{CONVERTTOBLOB}CONVERTTOBLOB}
\label{\detokenize{converttoblob::doc}}\label{\detokenize{converttoblob:converttoblob}}
The \sphinxcode{CONVERTTOBLOB} procedure provides the capability to convert character
data to binary.
\begin{quote}

\sphinxcode{CONVERTTOBLOB(\textless{}dest\_lob\textgreater{} IN OUT BLOB, \textless{}src\_clob\textgreater{} CLOB,}
\begin{quote}

\sphinxcode{\textless{}amount\textgreater{} INTEGER, \textless{}dest\_offset\textgreater{} IN OUT INTEGER},

\sphinxcode{\textless{}src\_offset\textgreater{} IN OUT INTEGER, \textless{}blob\_csid\textgreater{} NUMBER},

\sphinxcode{\textless{}lang\_context\textgreater{} IN OUT INTEGER, \textless{}warning\textgreater{} OUT INTEGER)}
\end{quote}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}dest\_lob\textgreater{}}
\begin{quote}

\sphinxcode{BLOB} large object locator to which the character data is to be
converted.
\end{quote}

\sphinxcode{\textless{}src\_clob\textgreater{}}
\begin{quote}

\sphinxcode{CLOB} large object locator of the character data to be converted.
\end{quote}

\sphinxcode{\textless{}amount\textgreater{}}
\begin{quote}

Number of characters of \sphinxcode{\textless{}src\_clob\textgreater{}} to be converted.
\end{quote}

\sphinxcode{\textless{}dest\_offset\textgreater{} IN}
\begin{quote}

Position in bytes in the destination \sphinxcode{BLOB} where writing of the source
\sphinxcode{CLOB} should begin. The first byte is offset 1.
\end{quote}

\sphinxcode{\textless{}dest\_offset\textgreater{} OUT}
\begin{quote}

Position in bytes in the destination \sphinxcode{BLOB} after the write operation
completes. The first byte is offset 1.
\end{quote}

\sphinxcode{\textless{}src\_offset\textgreater{} IN}
\begin{quote}

Position in characters in the source \sphinxcode{CLOB} where conversion to the
destination \sphinxcode{BLOB} should begin. The first character is offset 1.
\end{quote}

\sphinxcode{\textless{}src\_offset\textgreater{} OUT}
\begin{quote}

Position in characters in the source \sphinxcode{CLOB} after the conversion operation
completes. The first character is offset 1.
\end{quote}

\sphinxcode{\textless{}blob\_csid\textgreater{}}
\begin{quote}

Character set ID of the converted, destination \sphinxcode{BLOB}.
\end{quote}

\sphinxcode{\textless{}lang\_context\textgreater{} IN}
\begin{quote}

Language context for the conversion. The default value of 0 is typically
used for this setting.
\end{quote}

\sphinxcode{\textless{}lang\_context\textgreater{} OUT}
\begin{quote}

Language context after the conversion completes.
\end{quote}

\sphinxcode{\textless{}warning\textgreater{}}
\begin{quote}

0 if the conversion was successful, 1 if an inconvertible character was
encountered.
\end{quote}

\newpage


\subsection{\index{CONVERTTOCLOB}CONVERTTOCLOB}
\label{\detokenize{converttoclob::doc}}\label{\detokenize{converttoclob:converttoclob}}
The \sphinxcode{CONVERTTOCLOB} procedure provides the capability to convert binary
data to character.
\begin{quote}

\sphinxcode{CONVERTTOCLOB(\textless{}dest\_lob\textgreater{} IN OUT CLOB, \textless{}src\_blob\textgreater{} BLOB},
\begin{quote}

\sphinxcode{\textless{}amount\textgreater{} INTEGER, \textless{}dest\_offset\textgreater{} IN OUT INTEGER},

\sphinxcode{\textless{}src\_offset\textgreater{} IN OUT INTEGER, \textless{}blob\_csid\textgreater{} NUMBER},

\sphinxcode{\textless{}lang\_context\textgreater{} IN OUT INTEGER, \textless{}warning\textgreater{} OUT INTEGER)}
\end{quote}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}dest\_lob\textgreater{}}
\begin{quote}

\sphinxcode{CLOB} large object locator to which the binary data is to be converted.
\end{quote}

\sphinxcode{\textless{}src\_blob\textgreater{}}
\begin{quote}

\sphinxcode{BLOB} large object locator of the binary data to be converted.
\end{quote}

\sphinxcode{\textless{}amount\textgreater{}}
\begin{quote}

Number of bytes of \sphinxcode{\textless{}src\_blob\textgreater{}} to be converted.
\end{quote}

\sphinxcode{\textless{}dest\_offset\textgreater{} IN}
\begin{quote}

Position in characters in the destination \sphinxcode{CLOB} where writing of the
source \sphinxcode{BLOB} should begin. The first character is offset 1.
\end{quote}

\sphinxcode{\textless{}dest\_offset\textgreater{} OUT}
\begin{quote}

Position in characters in the destination \sphinxcode{CLOB} after the write operation
completes. The first character is offset 1.
\end{quote}

\sphinxcode{\textless{}src\_offset\textgreater{} IN}
\begin{quote}

Position in bytes in the source \sphinxcode{BLOB} where conversion to the destination
\sphinxcode{CLOB} should begin. The first byte is offset 1.
\end{quote}

\sphinxcode{\textless{}src\_offset\textgreater{} OUT}
\begin{quote}

Position in bytes in the source \sphinxcode{BLOB} after the conversion operation
completes. The first byte is offset 1.
\end{quote}

\sphinxcode{\textless{}blob\_csid\textgreater{}}
\begin{quote}

Character set ID of the converted, destination \sphinxcode{CLOB}.
\end{quote}

\sphinxcode{\textless{}lang\_context\textgreater{} IN}
\begin{quote}

Language context for the conversion. The default value of 0 is typically
used for this setting.
\end{quote}

\sphinxcode{\textless{}lang\_context\textgreater{} OUT}
\begin{quote}

Language context after the conversion completes.
\end{quote}

\sphinxcode{\textless{}warning\textgreater{}}
\begin{quote}

0 if the conversion was successful, 1 if an inconvertible character was
encountered.
\end{quote}

\newpage


\subsection{\index{COPY}COPY}
\label{\detokenize{copy::doc}}\label{\detokenize{copy:copy}}
The \sphinxcode{COPY} procedure provides the capability to copy one large object to
another. The source and destination large objects must be the same data
type.
\begin{quote}

\sphinxcode{COPY(\textless{}dest\_lob\textgreater{} IN OUT \{ BLOB \textbar{} CLOB \}, \textless{}src\_lob\textgreater{}}

\sphinxcode{\{ BLOB \textbar{} CLOB \}},
\begin{quote}

\sphinxcode{\textless{}amount\textgreater{} INTEGER}

\sphinxcode{{[}, \textless{}dest\_offset\textgreater{} INTEGER {[}, \textless{}src\_offset\textgreater{} INTEGER {]}{]})}
\end{quote}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}dest\_lob\textgreater{}}
\begin{quote}

Large object locator of the large object to which \sphinxcode{\textless{}src\_lob\textgreater{}} is to be
copied. Must be the same data type as \sphinxcode{\textless{}src\_lob\textgreater{}}.
\end{quote}

\sphinxcode{\textless{}src\_lob\textgreater{}}
\begin{quote}

Large object locator of the large object to be copied to \sphinxcode{\textless{}dest\_lob\textgreater{}}.
Must be the same data type as \sphinxcode{\textless{}dest\_lob\textgreater{}}.
\end{quote}

\sphinxcode{\textless{}amount\textgreater{}}
\begin{quote}

Number of bytes/characters of \sphinxcode{\textless{}src\_lob\textgreater{}} to be copied.
\end{quote}

\sphinxcode{\textless{}dest\_offset\textgreater{}}
\begin{quote}

Position in the destination large object where writing of the source
large object should begin. The first position is offset 1. The default
is 1.
\end{quote}

\sphinxcode{\textless{}src\_offset\textgreater{}}
\begin{quote}

Position in the source large object where copying to the destination
large object should begin. The first position is offset 1. The default
is 1.
\end{quote}

\newpage


\subsection{\index{ERASE}ERASE}
\label{\detokenize{erase::doc}}\label{\detokenize{erase:erase}}
The \sphinxcode{ERASE} procedure provides the capability to erase a portion of a
large object. To erase a large object means to replace the specified
portion with zero-byte fillers for \sphinxcode{BLOBs} or with spaces for \sphinxcode{CLOBs}. The
actual size of the large object is not altered.
\begin{quote}

\sphinxcode{ERASE( \textless{}lob\_loc\textgreater{} IN OUT \{ BLOB \textbar{} CLOB \}, \textless{}amount\textgreater{} IN OUT INTEGER}
\begin{quote}

\sphinxcode{{[}, \textless{}offset\textgreater{} INTEGER {]})}
\end{quote}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}lob\_loc\textgreater{}}
\begin{quote}

Large object locator of the large object to be erased.
\end{quote}

\sphinxcode{\textless{}amount\textgreater{} IN}
\begin{quote}

Number of bytes/characters to be erased.
\end{quote}

\sphinxcode{\textless{}amount\textgreater{} OUT}
\begin{quote}

Number of bytes/characters actually erased. This value can be smaller
than the input value if the end of the large object is reached before
\sphinxcode{\textless{}amount\textgreater{}} bytes/characters have been erased.
\end{quote}

\sphinxcode{\textless{}offset\textgreater{}}
\begin{quote}

Position in the large object where erasing is to begin. The first
byte/character is position 1. The default is 1.
\end{quote}

\newpage


\subsection{\index{GET\_STORAGE\_LIMIT}GET\_STORAGE\_LIMIT}
\label{\detokenize{get_storage_limit:get-storage-limit}}\label{\detokenize{get_storage_limit::doc}}
The \sphinxcode{GET\_STORAGE\_LIMIT} function returns the limit on the largest
allowable large object.
\begin{quote}

\sphinxcode{\textless{}size\textgreater{} INTEGER GET\_STORAGE\_LIMIT(\textless{}lob\_loc\textgreater{} BLOB)}

\sphinxcode{\textless{}size\textgreater{} INTEGER GET\_STORAGE\_LIMIT(\textless{}lob\_loc\textless{} CLOB)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}size\textgreater{}}
\begin{quote}

Maximum allowable size of a large object in this database.
\end{quote}

\sphinxcode{\textless{}lob\_loc\textgreater{}}
\begin{quote}

This parameter is ignored, but is included for compatibility.
\end{quote}

\newpage


\subsection{\index{GETLENGTH}GETLENGTH}
\label{\detokenize{getlength::doc}}\label{\detokenize{getlength:getlength}}
The \sphinxcode{GETLENGTH} function returns the length of a large object.
\begin{quote}

\sphinxcode{\textless{}amount\textgreater{} INTEGER GETLENGTH(\textless{}lob\_loc\textgreater{} BLOB)}

\sphinxcode{\textless{}amount\textgreater{} INTEGER GETLENGTH(\textless{}lob\_loc\textgreater{} CLOB)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}lob\_loc\textgreater{}}
\begin{quote}

Large object locator of the large object whose length is to be obtained.
\end{quote}

\sphinxcode{\textless{}amount\textgreater{}}
\begin{quote}

Length of the large object in bytes for \sphinxcode{BLOBs} or characters for \sphinxcode{CLOBs}.
\end{quote}

\newpage


\subsection{\index{INSTR}INSTR}
\label{\detokenize{instr:instr}}\label{\detokenize{instr::doc}}
The \sphinxcode{INSTR} function returns the location of the nth occurrence of a given
pattern within a large object.
\begin{quote}

\sphinxcode{\textless{}position\textgreater{} INTEGER INSTR(\textless{}lob\_loc\textgreater{} \{ BLOB \textbar{} CLOB \}},

\sphinxcode{\textless{}pattern\textgreater{} \{ RAW \textbar{} VARCHAR2 \} {[}, \textless{}offset\textgreater{} INTEGER {[}, \textless{}nth\textgreater{} INTEGER{]}{]})}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}lob\_loc\textgreater{}}
\begin{quote}

Large object locator of the large object in which to search for pattern.
\end{quote}

\sphinxcode{\textless{}pattern\textgreater{}}
\begin{quote}

Pattern of bytes or characters to match against the large object, lob.
\sphinxcode{\textless{}pattern\textgreater{}} must be RAW if \sphinxcode{\textless{}lob\_loc\textgreater{}} is a \sphinxcode{BLOB}. pattern must be \sphinxcode{VARCHAR2}
if \sphinxcode{\textless{}lob\_loc\textgreater{}} is a \sphinxcode{CLOB}.
\end{quote}

\sphinxcode{\textless{}offset\textgreater{}}
\begin{quote}

Position within \sphinxcode{\textless{}lob\_loc\textgreater{}} to start search for \sphinxcode{\textless{}pattern\textgreater{}}. The first
byte/character is position 1. The default is 1.
\end{quote}

\sphinxcode{\textless{}nth\textgreater{}}
\begin{quote}

Search for \sphinxcode{\textless{}pattern\textgreater{}}, \sphinxcode{\textless{}nth\textgreater{}} number of times starting at the position
given by \sphinxcode{\textless{}offset\textgreater{}}. The default is 1.
\end{quote}

\sphinxcode{\textless{}position\textgreater{}}
\begin{quote}

Position within the large object where \textless{}pattern\textless{} appears the nth time
specified by \textless{}nth\textless{} starting from the position given by \sphinxcode{\textless{}offset\textgreater{}}.
\end{quote}

\newpage


\subsection{\index{READ}READ}
\label{\detokenize{read::doc}}\label{\detokenize{read:read}}
The \sphinxcode{READ} procedure provides the capability to read a portion of a large
object into a buffer.
\begin{quote}

\sphinxcode{READ(\textless{}lob\_loc\textgreater{} \{ BLOB \textbar{} CLOB \}, \textless{}amount\textgreater{} IN OUT BINARY\_INTEGER},
\begin{quote}

\sphinxcode{\textless{}offset\textgreater{} INTEGER, \textless{}buffer\textgreater{} OUT \{ RAW \textbar{} VARCHAR2 \})}
\end{quote}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}lob\_loc\textgreater{}}
\begin{quote}

Large object locator of the large object to be read.
\end{quote}

\sphinxcode{\textless{}amount\textgreater{} IN}
\begin{quote}

Number of bytes/characters to read.
\end{quote}

\sphinxcode{\textless{}amount\textgreater{} OUT}
\begin{quote}

Number of bytes/characters actually read. If there is no more data to be
read, then \sphinxcode{\textless{}amount\textgreater{}} returns 0 and a \sphinxcode{DATA\_NOT\_FOUND} exception is
thrown.
\end{quote}

\sphinxcode{\textless{}offset\textgreater{}}
\begin{quote}

Position to begin reading. The first byte/character is position 1.
\end{quote}

\sphinxcode{\textless{}buffer\textgreater{}}
\begin{quote}

Variable to receive the large object. If \sphinxcode{\textless{}lob\_loc\textgreater{}} is a \sphinxcode{BLOB}, then
\sphinxcode{\textless{}buffer\textgreater{}} must be \sphinxcode{RAW}. If \sphinxcode{\textless{}lob\_loc\textgreater{}} is a \sphinxcode{CLOB}, then \sphinxcode{\textless{}buffer\textgreater{}} must be
\sphinxcode{VARCHAR2}.
\end{quote}

\newpage

\index{DBMS\_LOB\_SUBSTR}\ignorespaces 

\subsection{SUBSTR}
\label{\detokenize{substr::doc}}\label{\detokenize{substr:index-0}}\label{\detokenize{substr:substr}}
The \sphinxcode{SUBSTR} function provides the capability to return a portion of a
large object.
\begin{quote}

\sphinxcode{\textless{}data\textgreater{} \{ RAW \textbar{} VARCHAR2 \} SUBSTR(\textless{}lob\_loc\textgreater{} \{ BLOB \textbar{} CLOB \}}
\begin{quote}

\sphinxcode{{[}, \textless{}amount\textgreater{} INTEGER {[}, \textless{}offset\textgreater{} INTEGER {]}{]})}
\end{quote}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}lob\_loc\textgreater{}}
\begin{quote}

Large object locator of the large object to be read.
\end{quote}

\sphinxcode{\textless{}amount\textgreater{}}
\begin{quote}

Number of bytes/characters to be returned. Default is 32,767.
\end{quote}

\sphinxcode{\textless{}offset\textgreater{}}
\begin{quote}

Position within the large object to begin returning data. The first
byte/character is position 1. The default is 1.
\end{quote}

\sphinxcode{\textless{}data\textgreater{}}
\begin{quote}

Returned portion of the large object to be read. If \sphinxcode{\textless{}lob\_loc\textgreater{}} is a
\sphinxcode{BLOB}, the return data type is \sphinxcode{RAW}. If \sphinxcode{\textless{}lob\_loc\textgreater{}} is a \sphinxcode{CLOB}, the return
data type is \sphinxcode{VARCHAR2}.
\end{quote}

\newpage


\subsection{\index{TRIM}TRIM}
\label{\detokenize{trim::doc}}\label{\detokenize{trim:trim}}
The \sphinxcode{TRIM} procedure provides the capability to truncate a large object to
the specified length.
\begin{quote}

\sphinxcode{TRIM(\textless{}lob\_loc\textgreater{} IN OUT \{ BLOB \textbar{} CLOB \}, \textless{}newlen\textgreater{} INTEGER)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}lob\_loc\textgreater{}}
\begin{quote}

Large object locator of the large object to be trimmed.
\end{quote}

\sphinxcode{\textless{}newlen\textgreater{}}
\begin{quote}

Number of bytes/characters to which the large object is to be trimmed.
\end{quote}

\newpage


\subsection{\index{WRITE}WRITE}
\label{\detokenize{write::doc}}\label{\detokenize{write:write}}
The \sphinxcode{WRITE} procedure provides the capability to write data into a large
object. Any existing data in the large object at the specified offset
for the given length is overwritten by data given in the buffer.
\begin{quote}

\sphinxcode{WRITE(\textless{}lob\_loc\textgreater{} IN OUT \{ BLOB \textbar{} CLOB \}},
\begin{quote}

\sphinxcode{\textless{}amount\textgreater{} BINARY\_INTEGER},

\sphinxcode{\textless{}offset\textgreater{} INTEGER, \textless{}buffer\textgreater{} \{ RAW \textbar{} VARCHAR2 \})}
\end{quote}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}lob\_loc\textgreater{}}
\begin{quote}

Large object locator of the large object to be written.
\end{quote}

\sphinxcode{\textless{}amount\textgreater{}}
\begin{quote}

The number of bytes/characters in \sphinxcode{\textless{}buffer\textgreater{}} to be written to the large
object.
\end{quote}

\sphinxcode{\textless{}offset\textgreater{}}
\begin{quote}

The offset in bytes/characters from the beginning of the large object
(origin is 1) for the write operation to begin.
\end{quote}

\sphinxcode{\textless{}buffer\textgreater{}}
\begin{quote}

Contains data to be written to the large object. If \sphinxcode{\textless{}lob\_loc\textgreater{}} is a
\sphinxcode{BLOB}, then \sphinxcode{\textless{}buffer\textgreater{}} must be \sphinxcode{RAW}. If \sphinxcode{\textless{}lob\_loc\textgreater{}} is a \sphinxcode{CLOB}, then \sphinxcode{\textless{}buffer\textgreater{}}
must be \sphinxcode{VARCHAR2}.
\end{quote}

\newpage


\subsection{\index{WRITEAPPEND}WRITEAPPEND}
\label{\detokenize{writeappend::doc}}\label{\detokenize{writeappend:writeappend}}
The \sphinxcode{WRITEAPPEND} procedure provides the capability to add data to the end
of a large object.
\begin{quote}

\sphinxcode{WRITEAPPEND(\textless{}lob\_loc\textgreater{} IN OUT \{ BLOB \textbar{} CLOB \}},
\begin{quote}

\sphinxcode{\textless{}amount\textgreater{} BINARY\_INTEGER, \textless{}buffer\textgreater{} \{ RAW \textbar{} VARCHAR2 \})}
\end{quote}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}lob\_loc\textgreater{}}
\begin{quote}

Large object locator of the large object to which data is to be
appended.
\end{quote}

\sphinxcode{\textless{}amount\textgreater{}}
\begin{quote}

Number of bytes/characters from \sphinxcode{\textless{}buffer\textgreater{}} to be appended the large
object.
\end{quote}

\sphinxcode{\textless{}buffer\textgreater{}}
\begin{quote}

Data to be appended to the large object. If \sphinxcode{\textless{}lob\_loc\textgreater{}} is a \sphinxcode{BLOB}, then
\sphinxcode{\textless{}buffer\textgreater{}} must be RAW. If \sphinxcode{\textless{}lob\_loc\textgreater{}} is a \sphinxcode{CLOB}, then \sphinxcode{\textless{}buffer\textgreater{}} must be
\sphinxcode{VARCHAR2}.
\end{quote}

\newpage


\section{\index{DBMS\_LOCK}DBMS\_LOCK}
\label{\detokenize{dbms_lock::doc}}\label{\detokenize{dbms_lock:dbms-lock}}
Advanced Server provides support for the \sphinxcode{DBMS\_LOCK.SLEEP} procedure.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxstylestrong{Function/Procedure}
&
\sphinxstylestrong{Return Type}
&
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{SLEEP(\textless{}seconds\textgreater{})}
&
n/a
&
Suspends a session for the specified number of \sphinxcode{\textless{}seconds\textgreater{}}.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Advanced Server’s implementation of \sphinxcode{DBMS\_LOCK} is a partial
implementation when compared to Oracle’s version. Only \sphinxcode{DBMS\_LOCK.SLEEP}
is supported.


\subsection{\index{SLEEP}SLEEP}
\label{\detokenize{dbms_lock:sleep}}
The \sphinxcode{SLEEP} procedure suspends the current session for the specified
number of seconds.

\sphinxcode{SLEEP(\textless{}seconds\textgreater{} NUMBER)}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}seconds\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}seconds\textgreater{}} specifies the number of seconds for which you wish to
suspend the session. \sphinxcode{\textless{}seconds\textgreater{}} can be a fractional value; for
example, enter \sphinxcode{1.75} to specify one and three-fourths of a second.
\end{quote}

\newpage


\section{\index{DBMS\_MVIEW}DBMS\_MVIEW}
\label{\detokenize{dbms_mview::doc}}\label{\detokenize{dbms_mview:dbms-mview}}
Use procedures in the \sphinxcode{DBMS\_MVIEW} package to manage and refresh
materialized views and their dependencies. Advanced Server provides
support for the following \sphinxcode{DBMS\_MVIEW} procedures:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxstylestrong{Procedure}
&
\sphinxstylestrong{Return Type}
&
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{GET\_MV\_DEPENDENCIES(\textless{}list\textgreater{} VARCHAR2, \textless{}deplist\textgreater{} VARCHAR2);}
&
n/a
&
The \sphinxcode{GET\_MV\_DEPENDENCIES} procedure returns a list of dependencies for a specified view.
\\
\hline
\sphinxcode{REFRESH(\textless{}list\textgreater{} VARCHAR2, \textless{}method\textgreater{} VARCHAR2, \textless{}rollback\_seg\textgreater{} VARCHAR2 , \textless{}push\_deferred\_rpc\textgreater{} BOOLEAN, \textless{}refresh\_after\_errors\textgreater{} BOOLEAN , \textless{}purge\_option\textgreater{} NUMBER, \textless{}parallelism\textgreater{} NUMBER, \textless{}heap\_size\textgreater{} NUMBER , \textless{}atomic\_refresh\textgreater{} BOOLEAN , \textless{}nested\textgreater{} BOOLEAN);}
&
n/a
&
This variation of the \sphinxcode{REFRESH} procedure refreshes all views named in a comma-separated list of view names.
\\
\hline
\sphinxcode{REFRESH(\textless{}tab\textgreater{} dbms\_utility.uncl\_array, \textless{}method\textgreater{} VARCHAR2, \textless{}rollback\_seg\textgreater{} VARCHAR2, \textless{}push\_deferred\_rpc\textgreater{} BOOLEAN, \textless{}refresh\_after\_errors\textgreater{} BOOLEAN, \textless{}purge\_option\textgreater{} NUMBER, \textless{}parallelism\textgreater{} NUMBER, \textless{}heap\_size\textgreater{} NUMBER, \textless{}atomic\_refresh\textgreater{} BOOLEAN, \textless{}nested\textgreater{} BOOLEAN);}
&
n/a
&
This variation of the \sphinxcode{REFRESH} procedure refreshes all views named in a table of \sphinxcode{dbms\_utility.uncl\_array} values.
\\
\hline
\sphinxcode{REFRESH\_ALL\_MVIEWS(\textless{}number\_of\_failures\textgreater{} BINARY\_INTEGER, \textless{}method\textgreater{} VARCHAR2, \textless{}rollback\_seg\textgreater{} VARCHAR2, \textless{}refresh\_after\_errors\textgreater{} BOOLEAN, \textless{}atomic\_refresh\textgreater{} BOOLEAN);}
&
n/a
&
The \sphinxcode{REFRESH\_ALL\_MVIEWS} procedure refreshes all materialized views.
\\
\hline
\sphinxcode{REFRESH\_DEPENDENT(\textless{}number\_of\_failures\textgreater{} BINARY\_INTEGER, \textless{}list\textgreater{} VARCHAR2, \textless{}method\textless{} VARCHAR2, \textless{}rollback\_seg\textgreater{} VARCHAR2, \textless{}refresh\_after\_errors\textgreater{} BOOLEAN, \textless{}atomic\_refresh\textgreater{} BOOLEAN, \textless{}nested\textgreater{} BOOLEAN);}
&
n/a
&
This variation of the \sphinxcode{REFRESH\_DEPENDENT} procedure refreshes all views that are dependent on the views listed in a comma-separated list.
\\
\hline
\sphinxcode{REFRESH\_DEPENDENT(\textless{}number\_of\_failures\textgreater{} BINARY\_INTEGER, \textless{}tab\textgreater{} dbms\_utility.uncl\_array, \textless{}method\textgreater{} VARCHAR2, \textless{}rollback\_seg\textgreater{} VARCHAR2, \textless{}refresh\_after\_errors\textgreater{} BOOLEAN, \textless{}atomic\_refresh\textgreater{} BOOLEAN, \textless{}nested\textgreater{} BOOLEAN);}
&
n/a
&
This variation of the \sphinxcode{REFRESH\_DEPENDENT} procedure refreshes all views that are dependent on the views listed in a table of \sphinxcode{dbms\_utility.uncl\_array} values.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Advanced Server’s implementation of \sphinxcode{DBMS\_MVIEW} is a partial
implementation when compared to Oracle’s version. Only those functions
and procedures listed in the table above are supported.

\newpage


\subsection{\index{GET\_MV\_DEPENDENCIES}GET\_MV\_DEPENDENCIES}
\label{\detokenize{get_mv_dependencies::doc}}\label{\detokenize{get_mv_dependencies:get-mv-dependencies}}
When given the name of a materialized view, \sphinxcode{GET\_MV\_DEPENDENCIES}
returns a list of items that depend on the specified view. The signature
is:
\begin{quote}

\sphinxcode{GET\_MV\_DEPENDENCIES(}
\begin{quote}

\sphinxcode{\textless{}list\textgreater{} IN VARCHAR2,}

\sphinxcode{\textless{}deplist\textgreater{} OUT VARCHAR2);}
\end{quote}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}list\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}list\textgreater{}} specifies the name of a materialized view, or a
comma-separated list of materialized view names.
\end{quote}

\sphinxcode{\textless{}deplist\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}deplist\textgreater{}} is a comma-separated list of schema-qualified
dependencies. \sphinxcode{\textless{}deplist\textgreater{}} is a \sphinxcode{VARCHAR2} value.
\end{quote}

\sphinxstylestrong{Examples}

The following example:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
  deplist VARCHAR2(1000);
BEGIN
  DBMS\PYGZus{}MVIEW.GET\PYGZus{}MV\PYGZus{}DEPENDENCIES(\PYGZsq{}public.emp\PYGZus{}view\PYGZsq{}, deplist);
  DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}deplist: \PYGZsq{} \textbar{}\textbar{} deplist);
END;
\end{sphinxVerbatim}

Displays a list of the dependencies on a materialized view named
\sphinxcode{public.emp\_view}.

\newpage


\subsection{\index{REFRESH}REFRESH}
\label{\detokenize{refresh::doc}}\label{\detokenize{refresh:refresh}}
Use the \sphinxcode{REFRESH} procedure to refresh all views specified in either a
comma-separated list of view names, or a table of
\sphinxcode{DBMS\_UTILITY.UNCL\_ARRAY} values. The procedure has two signatures; use
the first form when specifying a comma-separated list of view names:
\begin{quote}

\sphinxcode{REFRESH(}
\begin{quote}

\sphinxcode{\textless{}list\textgreater{} IN VARCHAR2},

\sphinxcode{\textless{}method\textgreater{} IN VARCHAR2 DEFAULT NULL},

\sphinxcode{\textless{}rollback\_seg\textgreater{} IN VARCHAR2 DEFAULT NULL},

\sphinxcode{\textless{}push\_deferred\_rpc\textgreater{} IN BOOLEAN DEFAULT TRUE},

\sphinxcode{\textless{}refresh\_after\_errors\textgreater{} IN BOOLEAN DEFAULT FALSE},

\sphinxcode{\textless{}purge\_option\textgreater{} IN NUMBER DEFAULT 1},

\sphinxcode{\textless{}parallelism\textgreater{} IN NUMBER DEFAULT 0},

\sphinxcode{\textless{}heap\_size\textgreater{} IN NUMBER DEFAULT 0},

\sphinxcode{\textless{}atomic\_refresh\textgreater{} IN BOOLEAN DEFAULT TRUE},

\sphinxcode{\textless{}nested\textgreater{} IN BOOLEAN DEFAULT FALSE);}
\end{quote}
\end{quote}

Use the second form to specify view names in a table of
\sphinxcode{DBMS\_UTILITY.UNCL\_ARRAY} values:
\begin{quote}

\sphinxcode{REFRESH(}
\begin{quote}

\sphinxcode{\textless{}tab\textgreater{} IN OUT DBMS\_UTILITY.UNCL\_ARRAY,}

\sphinxcode{\textless{}method\textgreater{} IN VARCHAR2 DEFAULT NULL,}

\sphinxcode{\textless{}rollback\_seg\textgreater{} IN VARCHAR2 DEFAULT NULL,}

\sphinxcode{\textless{}push\_deferred\_rpc\textgreater{} IN BOOLEAN DEFAULT TRUE,}

\sphinxcode{\textless{}refresh\_after\_errors\textgreater{} IN BOOLEAN DEFAULT FALSE,}

\sphinxcode{\textless{}purge\_option\textgreater{} IN NUMBER DEFAULT 1,}

\sphinxcode{\textless{}parallelism\textgreater{} IN NUMBER DEFAULT 0,}

\sphinxcode{\textless{}heap\_size\textgreater{} IN NUMBER DEFAULT 0,}

\sphinxcode{\textless{}atomic\_refresh\textgreater{} IN BOOLEAN DEFAULT TRUE,}

\sphinxcode{\textless{}nested\textgreater{} IN BOOLEAN DEFAULT FALSE);}
\end{quote}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}list\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}list\textgreater{}} is a \sphinxcode{VARCHAR2} value that specifies the name of a materialized
view, or a comma-separated list of materialized view names. The
names may be schema-qualified.
\end{quote}

\sphinxcode{\textless{}tab\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}tab\textgreater{}} is a table of \sphinxcode{DBMS\_UTILITY.UNCL\_ARRAY} values that specify
the name (or names) of a materialized view.
\end{quote}

\sphinxcode{\textless{}method\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}method\textgreater{}} is a \sphinxcode{VARCHAR2} value that specifies the refresh method that
will be applied to the specified view (or views). The only supported
method is \sphinxcode{C}; this performs a complete refresh of the view.
\end{quote}

\sphinxcode{\textless{}rollback\_seg\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}rollback\_seg\textgreater{}} is accepted for compatibility and ignored. The
default is \sphinxcode{NULL}.
\end{quote}

\sphinxcode{\textless{}push\_deferred\_rpc\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}push\_deferred\_rpc\textgreater{}} is accepted for compatibility and ignored. The
default is \sphinxcode{TRUE}.
\end{quote}

\sphinxcode{\textless{}refresh\_after\_errors\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}refresh\_after\_errors\textgreater{}} is accepted for compatibility and ignored.
The default is \sphinxcode{FALSE}.
\end{quote}

\sphinxcode{\textless{}purge\_option\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}purge\_option\textgreater{}} is accepted for compatibility and ignored. The
default is \sphinxcode{1}.
\end{quote}

\sphinxcode{\textless{}parallelism\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}parallelism\textgreater{}} is accepted for compatibility and ignored. The default
is \sphinxcode{0}.
\end{quote}

\sphinxcode{\textless{}heap\_size\textgreater{} IN NUMBER DEFAULT 0},
\begin{quote}

\sphinxcode{\textless{}heap\_size\textgreater{}} is accepted for compatibility and ignored. The default
is \sphinxcode{0}.
\end{quote}

\sphinxcode{\textless{}atomic\_refresh\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}atomic\_refresh\textgreater{}} is accepted for compatibility and ignored. The
default is \sphinxcode{TRUE}.
\end{quote}

\sphinxcode{\textless{}nested\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}nested\textgreater{}} is accepted for compatibility and ignored. The default is
\sphinxcode{FALSE}.
\end{quote}

\sphinxstylestrong{Examples}

The following example uses \sphinxcode{DBMS\_MVIEW.REFRESH} to perform a \sphinxcode{COMPLETE}
refresh on the \sphinxcode{public.emp\_view} materialized view:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
EXEC DBMS\PYGZus{}MVIEW.REFRESH(list =\PYGZgt{} \PYGZsq{}public.emp\PYGZus{}view\PYGZsq{}, method =\PYGZgt{} \PYGZsq{}C\PYGZsq{});
\end{sphinxVerbatim}

\newpage


\subsection{\index{REFRESH\_ALL\_MVIEWS}REFRESH\_ALL\_MVIEWS}
\label{\detokenize{refresh_all_mviews::doc}}\label{\detokenize{refresh_all_mviews:refresh-all-mviews}}
Use the \sphinxcode{REFRESH\_ALL\_MVIEWS} procedure to refresh any materialized views
that have not been refreshed since the table or view on which the view
depends has been modified. The signature is:
\begin{quote}

\sphinxcode{REFRESH\_ALL\_MVIEWS(}
\begin{quote}

\sphinxcode{\textless{}number\_of\_failures\textgreater{} OUT BINARY\_INTEGER,}

\sphinxcode{\textless{}method\textless{} IN VARCHAR2 DEFAULT NULL,}

\sphinxcode{\textless{}rollback\_seg\textgreater{} IN VARCHAR2 DEFAULT NULL,}

\sphinxcode{\textless{}refresh\_after\_errors\textgreater{} IN BOOLEAN DEFAULT FALSE,}

\sphinxcode{\textless{}atomic\_refresh\textgreater{} IN BOOLEAN DEFAULT TRUE);}
\end{quote}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}number\_of\_failures\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}number\_of\_failures\textgreater{}} is a \sphinxcode{BINARY\_INTEGER} that specifies the
number of failures that occurred during the refresh operation.
\end{quote}

\sphinxcode{\textless{}method\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}method\textgreater{}} is a \sphinxcode{VARCHAR2} value that specifies the refresh method that
will be applied to the specified view (or views). The only supported
method is \sphinxcode{C;} this performs a complete refresh of the view.
\end{quote}

\sphinxcode{\textless{}rollback\_seg\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}rollback\_seg\textgreater{}} is accepted for compatibility and ignored. The
default is \sphinxcode{NULL}.
\end{quote}

\sphinxcode{\textless{}refresh\_after\_errors\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}refresh\_after\_errors\textgreater{}} is accepted for compatibility and ignored.
The default is \sphinxcode{FALSE}.
\end{quote}

\sphinxcode{\textless{}atomic\_refresh\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}atomic\_refresh\textgreater{}} is accepted for compatibility and ignored. The
default is \sphinxcode{TRUE}.
\end{quote}

\sphinxstylestrong{Examples}

The following example performs a \sphinxcode{COMPLETE} refresh on all materialized
views:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
  errors INTEGER;
BEGIN
  DBMS\PYGZus{}MVIEW.REFRESH\PYGZus{}ALL\PYGZus{}MVIEWS(errors, method =\PYGZgt{} \PYGZsq{}C\PYGZsq{});
END;
\end{sphinxVerbatim}

Upon completion, \sphinxcode{errors} contains the number of failures.

\newpage


\subsection{\index{REFRESH\_DEPENDENT}REFRESH\_DEPENDENT}
\label{\detokenize{refresh_dependent::doc}}\label{\detokenize{refresh_dependent:refresh-dependent}}
Use the \sphinxcode{REFRESH\_DEPENDENT} procedure to refresh all material views that
are dependent on the views specified in the call to the procedure. You
can specify a comma-separated list or provide the view names in a table
of \sphinxcode{DBMS\_UTILITY.UNCL\_ARRAY} values.

Use the first form of the procedure to refresh all material views that
are dependent on the views specified in a comma-separated list:
\begin{quote}

\sphinxcode{REFRESH\_DEPENDENT(}
\begin{quote}

\sphinxcode{\textless{}number\_of\_failures\textgreater{} OUT BINARY\_INTEGER,}

\sphinxcode{\textless{}list\textgreater{} IN VARCHAR2,}

\sphinxcode{\textless{}method\textgreater{} IN VARCHAR2 DEFAULT NULL,}

\sphinxcode{\textless{}rollback\_seg\textgreater{} IN VARCHAR2 DEFAULT NULL}

\sphinxcode{\textless{}refresh\_after\_errors\textgreater{} IN BOOLEAN DEFAULT FALSE,}

\sphinxcode{\textless{}atomic\_refresh\textgreater{} IN BOOLEAN DEFAULT TRUE,}

\sphinxcode{\textless{}nested\textgreater{} IN BOOLEAN DEFAULT FALSE);}
\end{quote}
\end{quote}

Use the second form of the procedure to refresh all material views that
are dependent on the views specified in a table of
\sphinxcode{DBMS\_UTILITY.UNCL\_ARRAY} values:
\begin{quote}

\sphinxcode{REFRESH\_DEPENDENT(}
\begin{quote}

\sphinxcode{\textless{}number\_of\_failures\textgreater{} OUT BINARY\_INTEGER,}

\sphinxcode{\textless{}tab\textgreater{} IN DBMS\_UTILITY.UNCL\_ARRAY,}

\sphinxcode{\textless{}method\textgreater{} IN VARCHAR2 DEFAULT NULL,}

\sphinxcode{\textless{}rollback\_seg\textgreater{} IN VARCHAR2 DEFAULT NULL,}

\sphinxcode{\textless{}refresh\_after\_errors\textgreater{} IN BOOLEAN DEFAULT FALSE,}

\sphinxcode{\textless{}atomic\_refresh\textgreater{} IN BOOLEAN DEFAULT TRUE,}

\sphinxcode{\textless{}nested\textgreater{} IN BOOLEAN DEFAULT FALSE);}
\end{quote}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}number\_of\_failures\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}number\_of\_failures\textgreater{}} is a \sphinxcode{BINARY\_INTEGER} that contains the number
of failures that occurred during the refresh operation.
\end{quote}

\sphinxcode{\textless{}list\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}list\textgreater{}} is a \sphinxcode{VARCHAR2} value that specifies the name of a materialized
view, or a comma-separated list of materialized view names. The
names may be schema-qualified.
\end{quote}

\sphinxcode{\textless{}tab\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}tab\textgreater{}} is a table of \sphinxcode{DBMS\_UTILITY.UNCL\_ARRAY} values that specify
the name (or names) of a materialized view.
\end{quote}

\sphinxcode{\textless{}method\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}method\textgreater{}} is a \sphinxcode{VARCHAR2} value that specifies the refresh method that
will be applied to the specified view (or views). The only supported
method is \sphinxcode{C}; this performs a complete refresh of the view.
\end{quote}

\sphinxcode{\textless{}rollback\_seg\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}rollback\_seg\textgreater{}} is accepted for compatibility and ignored. The
default is \sphinxcode{NULL}.
\end{quote}

\sphinxcode{\textless{}refresh\_after\_errors\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}refresh\_after\_errors\textgreater{}} is accepted for compatibility and ignored.
The default is \sphinxcode{FALSE}.
\end{quote}

\sphinxcode{\textless{}atomic\_refresh\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}atomic\_refresh\textgreater{}} is accepted for compatibility and ignored. The
default is \sphinxcode{TRUE}.
\end{quote}

\sphinxcode{\textless{}nested\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}nested\textgreater{}} is accepted for compatibility and ignored. The default is
\sphinxcode{FALSE}.
\end{quote}

\sphinxstylestrong{Examples}

The following example performs a \sphinxcode{COMPLETE} refresh on all materialized
views dependent on a materialized view named \sphinxcode{emp\_view} that resides in
the public schema:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
  errors INTEGER;
BEGIN
  DBMS\PYGZus{}MVIEW.REFRESH\PYGZus{}DEPENDENT(errors, list =\PYGZgt{} \PYGZsq{}public.emp\PYGZus{}view\PYGZsq{},
  method =\PYGZgt{}
\PYGZsq{}C\PYGZsq{});
END;
\end{sphinxVerbatim}

Upon completion, \sphinxcode{errors} contains the number of failures.

\newpage


\section{\index{DBMS\_OUTPUT}DBMS\_OUTPUT}
\label{\detokenize{dbms_output::doc}}\label{\detokenize{dbms_output:dbms-output}}
The \sphinxcode{DBMS\_OUTPUT} package provides the capability to send messages (lines
of text) to a message buffer, or get messages from the message buffer. A
message buffer is local to a single session. Use the \sphinxcode{DBMS\_PIPE} package
to send messages between sessions.

The procedures and functions available in the \sphinxcode{DBMS\_OUTPUT} package are
listed in the following table.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxstylestrong{Function/Procedure}
&
\sphinxstylestrong{Return Type}
&
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{DISABLE}
&
n/a
&
Disable the capability to send and receive messages.
\\
\hline
\sphinxcode{ENABLE(\textless{}buffer\_size\textgreater{})}
&
n/a
&
Enable the capability to send and receive messages.
\\
\hline
\sphinxcode{GET\_LINE(\textless{}line\textgreater{} OUT, \textless{}status\textgreater{} OUT)}
&
n/a
&
Get a line from the message buffer.
\\
\hline
\sphinxcode{GET\_LINES(\textless{}lines\textgreater{} OUT, \textless{}numlines\textgreater{} IN OUT)}
&
n/a
&
Get multiple lines from the message buffer.
\\
\hline
\sphinxcode{NEW\_LINE}
&
n/a
&
Puts an end-of-line character sequence.
\\
\hline
\sphinxcode{PUT(\textless{}item\textgreater{})}
&
n/a
&
Puts a partial line without an end-of-line character sequence.
\\
\hline
\sphinxcode{PUT\_LINE(\textless{}item\textgreater{})}
&
n/a
&
Puts a complete line with an end-of-line character sequence.
\\
\hline
\sphinxcode{SERVEROUTPUT(\textless{}stdout\textgreater{})}
&
n/a
&
Direct messages from \sphinxcode{PUT, PUT\_LINE,} or \sphinxcode{NEW\_LINE} to either standard output or the message buffer.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

The following table lists the public variables available in the
\sphinxcode{DBMS\_OUTPUT} package.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline

\sphinxstylestrong{Public Variables}
&
\sphinxstylestrong{Data Type}
&
\sphinxstylestrong{Value}
&
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{chararr}
&
\sphinxcode{TABLE}
&&
For message lines.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{\index{CHARARR}CHARARR}
\label{\detokenize{dbms_output:chararr}}
The \sphinxcode{CHARARR} is for storing multiple message lines.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
TYPE chararr IS TABLE OF VARCHAR2(32767) INDEX BY BINARY\PYGZus{}INTEGER;
\end{sphinxVerbatim}

\newpage

\index{DBMS\_OUTPUT\_DISABLE}\ignorespaces 

\subsection{DISABLE}
\label{\detokenize{dbms_output:disable}}\label{\detokenize{dbms_output:index-2}}
The \sphinxcode{DISABLE} procedure clears out the message buffer. Any messages in the
buffer at the time the \sphinxcode{DISABLE} procedure is executed will no longer be
accessible. Any messages subsequently sent with the \sphinxcode{PUT, PUT\_LINE,} or
\sphinxcode{NEW\_LINE} procedures are discarded. No error is returned to the sender
when the \sphinxcode{PUT, PUT\_LINE,} or \sphinxcode{NEW\_LINE} procedures are executed and
messages have been disabled.

Use the \sphinxcode{ENABLE} procedure or \sphinxcode{SERVEROUTPUT(TRUE)} procedure to re-enable
the sending and receiving of messages.

\sphinxcode{DISABLE}

\sphinxstylestrong{Examples}

This anonymous block disables the sending and receiving messages in the
current session.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
BEGIN

  DBMS\PYGZus{}OUTPUT.DISABLE;

END;
\end{sphinxVerbatim}

\newpage

\index{DBMS\_OUTPUT\_ENABLE}\ignorespaces 

\subsection{ENABLE}
\label{\detokenize{dbms_output:index-3}}\label{\detokenize{dbms_output:enable}}
The \sphinxcode{ENABLE} procedure enables the capability to send messages to the
message buffer or retrieve messages from the message buffer. Running
\sphinxcode{SERVEROUTPUT(TRUE)} also implicitly performs the \sphinxcode{ENABLE} procedure.

The destination of a message sent with \sphinxcode{PUT, PUT\_LINE,} or \sphinxcode{NEW\_LINE}
depends upon the state of \sphinxcode{SERVEROUTPUT}.
\begin{itemize}
\item {} 
If the last state of \sphinxcode{SERVEROUTPUT} is \sphinxcode{TRUE}, the message goes to
standard output of the command line.

\item {} 
If the last state of \sphinxcode{SERVEROUTPUT} is \sphinxcode{FALSE}, the message goes to the
message buffer.
\begin{quote}

\sphinxcode{ENABLE {[} (\textless{}buffer\_size\textgreater{} INTEGER) {]}}
\end{quote}

\end{itemize}

\sphinxstylestrong{Parameter}

\sphinxcode{\textless{}buffer\_size\textgreater{}}
\begin{quote}

Maximum length of the message buffer in bytes. If a \sphinxcode{\textless{}buffer\_size\textgreater{}} of
less than 2000 is specified, the buffer size is set to 2000.
\end{quote}

\sphinxstylestrong{Examples}

The following anonymous block enables messages. Setting
\sphinxcode{SERVEROUTPUT(TRUE)} forces them to standard output.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
BEGIN
   DBMS\PYGZus{}OUTPUT.ENABLE;
   DBMS\PYGZus{}OUTPUT.SERVEROUTPUT(TRUE);
   DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Messages enabled\PYGZsq{});
END;

Messages enabled
\end{sphinxVerbatim}

The same effect could have been achieved by simply using
\sphinxcode{SERVEROUTPUT(TRUE)}.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
BEGIN
   DBMS\PYGZus{}OUTPUT.SERVEROUTPUT(TRUE);
   DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Messages enabled\PYGZsq{});
END;

Messages enabled
\end{sphinxVerbatim}

The following anonymous block enables messages, but setting
\sphinxcode{SERVEROUTPUT(FALSE)} directs messages to the message buffer.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
BEGIN
   DBMS\PYGZus{}OUTPUT.ENABLE;
   DBMS\PYGZus{}OUTPUT.SERVEROUTPUT(FALSE);
   DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Message sent to buffer\PYGZsq{});
END;
\end{sphinxVerbatim}

\newpage


\subsection{\index{GET\_LINE}GET\_LINE}
\label{\detokenize{dbms_output:get-line}}
The \sphinxcode{GET\_LINE} procedure provides the capability to retrieve a line of
text from the message buffer. Only text that has been terminated by an
end-of-line character sequence is retrieved \textendash{} that is complete lines
generated using \sphinxcode{PUT\_LINE}, or by a series of \sphinxcode{PUT} calls followed by a
\sphinxcode{NEW\_LINE} call.
\begin{quote}

\sphinxcode{GET\_LINE(\textless{}line\textgreater{} OUT VARCHAR2, \textless{}status\textgreater{} OUT INTEGER)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}line\textgreater{}}
\begin{quote}

Variable receiving the line of text from the message buffer.
\end{quote}

\sphinxcode{\textless{}status\textgreater{}}
\begin{quote}

0 if a line was returned from the message buffer, 1 if there was no line
to return.
\end{quote}

\sphinxstylestrong{Examples}

The following anonymous block writes the \sphinxcode{emp} table out to the message
buffer as a comma-delimited string for each row.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
EXEC DBMS\PYGZus{}OUTPUT.SERVEROUTPUT(FALSE);

DECLARE
    v\PYGZus{}emprec        VARCHAR2(120);
    CURSOR emp\PYGZus{}cur IS SELECT * FROM emp ORDER BY empno;
BEGIN
    DBMS\PYGZus{}OUTPUT.ENABLE;
    FOR i IN emp\PYGZus{}cur LOOP
        v\PYGZus{}emprec := i.empno \textbar{}\textbar{} \PYGZsq{},\PYGZsq{} \textbar{}\textbar{} i.ename \textbar{}\textbar{} \PYGZsq{},\PYGZsq{} \textbar{}\textbar{} i.job \textbar{}\textbar{} \PYGZsq{},\PYGZsq{} \textbar{}\textbar{}
            NVL(LTRIM(TO\PYGZus{}CHAR(i.mgr,\PYGZsq{}9999\PYGZsq{})),\PYGZsq{}\PYGZsq{}) \textbar{}\textbar{} \PYGZsq{},\PYGZsq{} \textbar{}\textbar{} i.hiredate \textbar{}\textbar{}
            \PYGZsq{},\PYGZsq{} \textbar{}\textbar{} i.sal \textbar{}\textbar{} \PYGZsq{},\PYGZsq{} \textbar{}\textbar{}
            NVL(LTRIM(TO\PYGZus{}CHAR(i.comm,\PYGZsq{}9990.99\PYGZsq{})),\PYGZsq{}\PYGZsq{}) \textbar{}\textbar{} \PYGZsq{},\PYGZsq{} \textbar{}\textbar{} i.deptno;
        DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(v\PYGZus{}emprec);
    END LOOP;
END;
\end{sphinxVerbatim}

The following anonymous block reads the message buffer and inserts the
messages written by the prior example into a table named \sphinxcode{messages}. The
rows in \sphinxcode{messages} are then displayed.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
CREATE TABLE messages (
    status          INTEGER,
    msg             VARCHAR2(100)
);

DECLARE
    v\PYGZus{}line          VARCHAR2(100);
    v\PYGZus{}status        INTEGER := 0;
BEGIN
    DBMS\PYGZus{}OUTPUT.GET\PYGZus{}LINE(v\PYGZus{}line,v\PYGZus{}status);
    WHILE v\PYGZus{}status = 0 LOOP
        INSERT INTO messages VALUES(v\PYGZus{}status, v\PYGZus{}line);
        DBMS\PYGZus{}OUTPUT.GET\PYGZus{}LINE(v\PYGZus{}line,v\PYGZus{}status);
    END LOOP;
END;

SELECT msg FROM messages;

                               msg
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
 7369,SMITH,CLERK,7902,17\PYGZhy{}DEC\PYGZhy{}80 00:00:00,800.00,,20
 7499,ALLEN,SALESMAN,7698,20\PYGZhy{}FEB\PYGZhy{}81 00:00:00,1600.00,300.00,30
 7521,WARD,SALESMAN,7698,22\PYGZhy{}FEB\PYGZhy{}81 00:00:00,1250.00,500.00,30
 7566,JONES,MANAGER,7839,02\PYGZhy{}APR\PYGZhy{}81 00:00:00,2975.00,,20
 7654,MARTIN,SALESMAN,7698,28\PYGZhy{}SEP\PYGZhy{}81 00:00:00,1250.00,1400.00,30
 7698,BLAKE,MANAGER,7839,01\PYGZhy{}MAY\PYGZhy{}81 00:00:00,2850.00,,30
 7782,CLARK,MANAGER,7839,09\PYGZhy{}JUN\PYGZhy{}81 00:00:00,2450.00,,10
 7788,SCOTT,ANALYST,7566,19\PYGZhy{}APR\PYGZhy{}87 00:00:00,3000.00,,20
 7839,KING,PRESIDENT,,17\PYGZhy{}NOV\PYGZhy{}81 00:00:00,5000.00,,10
 7844,TURNER,SALESMAN,7698,08\PYGZhy{}SEP\PYGZhy{}81 00:00:00,1500.00,0.00,30
 7876,ADAMS,CLERK,7788,23\PYGZhy{}MAY\PYGZhy{}87 00:00:00,1100.00,,20
 7900,JAMES,CLERK,7698,03\PYGZhy{}DEC\PYGZhy{}81 00:00:00,950.00,,30
 7902,FORD,ANALYST,7566,03\PYGZhy{}DEC\PYGZhy{}81 00:00:00,3000.00,,20
 7934,MILLER,CLERK,7782,23\PYGZhy{}JAN\PYGZhy{}82 00:00:00,1300.00,,10
(14 rows)
\end{sphinxVerbatim}

\newpage


\subsection{\index{GET\_LINES}GET\_LINES}
\label{\detokenize{dbms_output:get-lines}}
The \sphinxcode{GET\_LINES} procedure provides the capability to retrieve one or more
lines of text from the message buffer into a collection. Only text that
has been terminated by an end-of-line character sequence is retrieved \textendash{}
that is complete lines generated using \sphinxcode{PUT\_LINE}, or by a series of \sphinxcode{PUT}
calls followed by a \sphinxcode{NEW\_LINE} call.
\begin{quote}

\sphinxcode{GET\_LINES(\textless{}lines\textgreater{} OUT CHARARR, \textless{}numlines\textgreater{} IN OUT INTEGER)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}lines\textgreater{}}
\begin{quote}

Table receiving the lines of text from the message buffer. See
\sphinxcode{CHARARR} for a description of \sphinxcode{\textless{}lines\textgreater{}.}
\end{quote}

\sphinxcode{\textless{}numlines\textgreater{} IN}
\begin{quote}

Number of lines to be retrieved from the message buffer.
\end{quote}

\sphinxcode{\textless{}numlines\textgreater{} OUT}
\begin{quote}

Actual number of lines retrieved from the message buffer. If the output
value of \sphinxcode{\textless{}numlines\textgreater{}} is less than the input value, then there are no more
lines left in the message buffer.
\end{quote}

\sphinxstylestrong{Examples}

The following example uses the \sphinxcode{GET\_LINES} procedure to store all rows
from the \sphinxcode{emp} table that were placed on the message buffer, into an
array.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
EXEC DBMS\PYGZus{}OUTPUT.SERVEROUTPUT(FALSE);

DECLARE
    v\PYGZus{}emprec        VARCHAR2(120);
    CURSOR emp\PYGZus{}cur IS SELECT * FROM emp ORDER BY empno;
BEGIN
    DBMS\PYGZus{}OUTPUT.ENABLE;
    FOR i IN emp\PYGZus{}cur LOOP
        v\PYGZus{}emprec := i.empno \textbar{}\textbar{} \PYGZsq{},\PYGZsq{} \textbar{}\textbar{} i.ename \textbar{}\textbar{} \PYGZsq{},\PYGZsq{} \textbar{}\textbar{} i.job \textbar{}\textbar{} \PYGZsq{},\PYGZsq{} \textbar{}\textbar{}
            NVL(LTRIM(TO\PYGZus{}CHAR(i.mgr,\PYGZsq{}9999\PYGZsq{})),\PYGZsq{}\PYGZsq{}) \textbar{}\textbar{} \PYGZsq{},\PYGZsq{} \textbar{}\textbar{} i.hiredate \textbar{}\textbar{}
            \PYGZsq{},\PYGZsq{} \textbar{}\textbar{} i.sal \textbar{}\textbar{} \PYGZsq{},\PYGZsq{} \textbar{}\textbar{}
            NVL(LTRIM(TO\PYGZus{}CHAR(i.comm,\PYGZsq{}9990.99\PYGZsq{})),\PYGZsq{}\PYGZsq{}) \textbar{}\textbar{} \PYGZsq{},\PYGZsq{} \textbar{}\textbar{} i.deptno;
        DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(v\PYGZus{}emprec);
    END LOOP;
END;

DECLARE
    v\PYGZus{}lines         DBMS\PYGZus{}OUTPUT.CHARARR;
    v\PYGZus{}numlines      INTEGER := 14;
    v\PYGZus{}status        INTEGER := 0;
BEGIN
    DBMS\PYGZus{}OUTPUT.GET\PYGZus{}LINES(v\PYGZus{}lines,v\PYGZus{}numlines);
    FOR i IN 1..v\PYGZus{}numlines LOOP
        INSERT INTO messages VALUES(v\PYGZus{}numlines, v\PYGZus{}lines(i));
    END LOOP;
END;

SELECT msg FROM messages;

                               msg
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
 7369,SMITH,CLERK,7902,17\PYGZhy{}DEC\PYGZhy{}80 00:00:00,800.00,,20
 7499,ALLEN,SALESMAN,7698,20\PYGZhy{}FEB\PYGZhy{}81 00:00:00,1600.00,300.00,30
 7521,WARD,SALESMAN,7698,22\PYGZhy{}FEB\PYGZhy{}81 00:00:00,1250.00,500.00,30
 7566,JONES,MANAGER,7839,02\PYGZhy{}APR\PYGZhy{}81 00:00:00,2975.00,,20
 7654,MARTIN,SALESMAN,7698,28\PYGZhy{}SEP\PYGZhy{}81 00:00:00,1250.00,1400.00,30
 7698,BLAKE,MANAGER,7839,01\PYGZhy{}MAY\PYGZhy{}81 00:00:00,2850.00,,30
 7782,CLARK,MANAGER,7839,09\PYGZhy{}JUN\PYGZhy{}81 00:00:00,2450.00,,10
 7788,SCOTT,ANALYST,7566,19\PYGZhy{}APR\PYGZhy{}87 00:00:00,3000.00,,20
 7839,KING,PRESIDENT,,17\PYGZhy{}NOV\PYGZhy{}81 00:00:00,5000.00,,10
 7844,TURNER,SALESMAN,7698,08\PYGZhy{}SEP\PYGZhy{}81 00:00:00,1500.00,0.00,30
 7876,ADAMS,CLERK,7788,23\PYGZhy{}MAY\PYGZhy{}87 00:00:00,1100.00,,20
 7900,JAMES,CLERK,7698,03\PYGZhy{}DEC\PYGZhy{}81 00:00:00,950.00,,30
 7902,FORD,ANALYST,7566,03\PYGZhy{}DEC\PYGZhy{}81 00:00:00,3000.00,,20
 7934,MILLER,CLERK,7782,23\PYGZhy{}JAN\PYGZhy{}82 00:00:00,1300.00,,10
(14 rows)
\end{sphinxVerbatim}

\newpage


\subsection{\index{NEW\_LINE}NEW\_LINE}
\label{\detokenize{dbms_output:new-line}}
The \sphinxcode{NEW\_LINE} procedure writes an end-of-line character sequence in the
message buffer.
\begin{quote}

\sphinxcode{NEW\_LINE}
\end{quote}

\sphinxstylestrong{Parameter}

The \sphinxcode{NEW\_LINE} procedure expects no parameters.

\newpage

\index{DBMS\_OUTPUT\_PUT}\ignorespaces 

\subsection{PUT}
\label{\detokenize{dbms_output:put}}\label{\detokenize{dbms_output:index-7}}
The \sphinxcode{PUT} procedure writes a string to the message buffer. No end-of-line
character sequence is written at the end of the string. Use the
\sphinxcode{NEW\_LINE} procedure to add an end-of-line character sequence.
\begin{quote}

\sphinxcode{PUT(\textless{}item\textgreater{} VARCHAR2)}
\end{quote}

\sphinxstylestrong{Parameter}

\sphinxcode{\textless{}item\textgreater{}}
\begin{quote}

Text written to the message buffer.
\end{quote}

\sphinxstylestrong{Examples}

The following example uses the \sphinxcode{PUT} procedure to display a
comma-delimited list of employees from the emp table.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    CURSOR emp\PYGZus{}cur IS SELECT * FROM emp ORDER BY empno;
BEGIN
    FOR i IN emp\PYGZus{}cur LOOP
        DBMS\PYGZus{}OUTPUT.PUT(i.empno);
        DBMS\PYGZus{}OUTPUT.PUT(\PYGZsq{},\PYGZsq{});
        DBMS\PYGZus{}OUTPUT.PUT(i.ename);
        DBMS\PYGZus{}OUTPUT.PUT(\PYGZsq{},\PYGZsq{});
        DBMS\PYGZus{}OUTPUT.PUT(i.job);
        DBMS\PYGZus{}OUTPUT.PUT(\PYGZsq{},\PYGZsq{});
        DBMS\PYGZus{}OUTPUT.PUT(i.mgr);
        DBMS\PYGZus{}OUTPUT.PUT(\PYGZsq{},\PYGZsq{});
        DBMS\PYGZus{}OUTPUT.PUT(i.hiredate);
        DBMS\PYGZus{}OUTPUT.PUT(\PYGZsq{},\PYGZsq{});
        DBMS\PYGZus{}OUTPUT.PUT(i.sal);
        DBMS\PYGZus{}OUTPUT.PUT(\PYGZsq{},\PYGZsq{});
        DBMS\PYGZus{}OUTPUT.PUT(i.comm);
        DBMS\PYGZus{}OUTPUT.PUT(\PYGZsq{},\PYGZsq{});
        DBMS\PYGZus{}OUTPUT.PUT(i.deptno);
        DBMS\PYGZus{}OUTPUT.NEW\PYGZus{}LINE;
    END LOOP;
END;

7369,SMITH,CLERK,7902,17\PYGZhy{}DEC\PYGZhy{}80 00:00:00,800.00,,20
7499,ALLEN,SALESMAN,7698,20\PYGZhy{}FEB\PYGZhy{}81 00:00:00,1600.00,300.00,30
7521,WARD,SALESMAN,7698,22\PYGZhy{}FEB\PYGZhy{}81 00:00:00,1250.00,500.00,30
7566,JONES,MANAGER,7839,02\PYGZhy{}APR\PYGZhy{}81 00:00:00,2975.00,,20
7654,MARTIN,SALESMAN,7698,28\PYGZhy{}SEP\PYGZhy{}81 00:00:00,1250.00,1400.00,30
7698,BLAKE,MANAGER,7839,01\PYGZhy{}MAY\PYGZhy{}81 00:00:00,2850.00,,30
7782,CLARK,MANAGER,7839,09\PYGZhy{}JUN\PYGZhy{}81 00:00:00,2450.00,,10
7788,SCOTT,ANALYST,7566,19\PYGZhy{}APR\PYGZhy{}87 00:00:00,3000.00,,20
7839,KING,PRESIDENT,,17\PYGZhy{}NOV\PYGZhy{}81 00:00:00,5000.00,,10
7844,TURNER,SALESMAN,7698,08\PYGZhy{}SEP\PYGZhy{}81 00:00:00,1500.00,0.00,30
7876,ADAMS,CLERK,7788,23\PYGZhy{}MAY\PYGZhy{}87 00:00:00,1100.00,,20
7900,JAMES,CLERK,7698,03\PYGZhy{}DEC\PYGZhy{}81 00:00:00,950.00,,30
7902,FORD,ANALYST,7566,03\PYGZhy{}DEC\PYGZhy{}81 00:00:00,3000.00,,20
7934,MILLER,CLERK,7782,23\PYGZhy{}JAN\PYGZhy{}82 00:00:00,1300.00,,10
\end{sphinxVerbatim}

\newpage

\index{DBMS\_OUTPUT\_PUT\_LINE}\ignorespaces 

\subsection{PUT\_LINE}
\label{\detokenize{dbms_output:index-8}}\label{\detokenize{dbms_output:put-line}}
The \sphinxcode{PUT\_LINE} procedure writes a single line to the message buffer
including an end-of-line character sequence.
\begin{quote}

\sphinxcode{PUT\_LINE(\textless{}item\textgreater{} VARCHAR2)}
\end{quote}

\sphinxstylestrong{Parameter}

\sphinxcode{\textless{}item\textgreater{}}
\begin{quote}

Text to be written to the message buffer.
\end{quote}

\sphinxstylestrong{Examples}

The following example uses the \sphinxcode{PUT\_LINE} procedure to display a
comma-delimited list of employees from the \sphinxcode{emp} table.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    v\PYGZus{}emprec        VARCHAR2(120);
    CURSOR emp\PYGZus{}cur IS SELECT * FROM emp ORDER BY empno;
BEGIN
    FOR i IN emp\PYGZus{}cur LOOP
        v\PYGZus{}emprec := i.empno \textbar{}\textbar{} \PYGZsq{},\PYGZsq{} \textbar{}\textbar{} i.ename \textbar{}\textbar{} \PYGZsq{},\PYGZsq{} \textbar{}\textbar{} i.job \textbar{}\textbar{} \PYGZsq{},\PYGZsq{} \textbar{}\textbar{}
            NVL(LTRIM(TO\PYGZus{}CHAR(i.mgr,\PYGZsq{}9999\PYGZsq{})),\PYGZsq{}\PYGZsq{}) \textbar{}\textbar{} \PYGZsq{},\PYGZsq{} \textbar{}\textbar{} i.hiredate \textbar{}\textbar{}
            \PYGZsq{},\PYGZsq{} \textbar{}\textbar{} i.sal \textbar{}\textbar{} \PYGZsq{},\PYGZsq{} \textbar{}\textbar{}
            NVL(LTRIM(TO\PYGZus{}CHAR(i.comm,\PYGZsq{}9990.99\PYGZsq{})),\PYGZsq{}\PYGZsq{}) \textbar{}\textbar{} \PYGZsq{},\PYGZsq{} \textbar{}\textbar{} i.deptno;
        DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(v\PYGZus{}emprec);
    END LOOP;
END;

7369,SMITH,CLERK,7902,17\PYGZhy{}DEC\PYGZhy{}80 00:00:00,800.00,,20
7499,ALLEN,SALESMAN,7698,20\PYGZhy{}FEB\PYGZhy{}81 00:00:00,1600.00,300.00,30
7521,WARD,SALESMAN,7698,22\PYGZhy{}FEB\PYGZhy{}81 00:00:00,1250.00,500.00,30
7566,JONES,MANAGER,7839,02\PYGZhy{}APR\PYGZhy{}81 00:00:00,2975.00,,20
7654,MARTIN,SALESMAN,7698,28\PYGZhy{}SEP\PYGZhy{}81 00:00:00,1250.00,1400.00,30
7698,BLAKE,MANAGER,7839,01\PYGZhy{}MAY\PYGZhy{}81 00:00:00,2850.00,,30
7782,CLARK,MANAGER,7839,09\PYGZhy{}JUN\PYGZhy{}81 00:00:00,2450.00,,10
7788,SCOTT,ANALYST,7566,19\PYGZhy{}APR\PYGZhy{}87 00:00:00,3000.00,,20
7839,KING,PRESIDENT,,17\PYGZhy{}NOV\PYGZhy{}81 00:00:00,5000.00,,10
7844,TURNER,SALESMAN,7698,08\PYGZhy{}SEP\PYGZhy{}81 00:00:00,1500.00,0.00,30
7876,ADAMS,CLERK,7788,23\PYGZhy{}MAY\PYGZhy{}87 00:00:00,1100.00,,20
7900,JAMES,CLERK,7698,03\PYGZhy{}DEC\PYGZhy{}81 00:00:00,950.00,,30
7902,FORD,ANALYST,7566,03\PYGZhy{}DEC\PYGZhy{}81 00:00:00,3000.00,,20
7934,MILLER,CLERK,7782,23\PYGZhy{}JAN\PYGZhy{}82 00:00:00,1300.00,,10
\end{sphinxVerbatim}

\newpage


\subsection{\index{SERVEROUTPUT}SERVEROUTPUT}
\label{\detokenize{dbms_output:serveroutput}}
The \sphinxcode{SERVEROUTPUT} procedure provides the capability to direct messages to
standard output of the command line or to the message buffer. Setting
\sphinxcode{SERVEROUTPUT(TRUE)} also performs an implicit execution of \sphinxcode{ENABLE}.

The default setting of \sphinxcode{SERVEROUTPUT} is implementation dependent. For
example, in Oracle SQL*Plus, \sphinxcode{SERVEROUTPUT(FALSE)} is the default. In
PSQL, \sphinxcode{SERVEROUTPUT(TRUE)} is the default. Also note that in Oracle
SQL*Plus, this setting is controlled using the SQL*Plus SET command,
not by a stored procedure as implemented in Advanced Server.
\begin{quote}

\sphinxcode{SERVEROUTPUT(\textless{}stdout\textgreater{} BOOLEAN)}
\end{quote}

\sphinxstylestrong{Parameter}

\sphinxcode{\textless{}stdout\textgreater{}}
\begin{quote}

Set to \sphinxcode{TRUE} if subsequent \sphinxcode{PUT, PUT\_LINE}, or \sphinxcode{NEW\_LINE} commands are to
send text directly to standard output of the command line. Set to \sphinxcode{FALSE}
if text is to be sent to the message buffer.
\end{quote}

\sphinxstylestrong{Examples}

The following anonymous block sends the first message to the command
line and the second message to the message buffer.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
BEGIN
    DBMS\PYGZus{}OUTPUT.SERVEROUTPUT(TRUE);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}This message goes to the command line\PYGZsq{});
    DBMS\PYGZus{}OUTPUT.SERVEROUTPUT(FALSE);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}This message goes to the message buffer\PYGZsq{});
END;

This message goes to the command line
\end{sphinxVerbatim}

If within the same session, the following anonymous block is executed, the message stored in the message buffer from the prior example is flushed and displayed on the command line as well as the new message.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
BEGIN
    DBMS\PYGZus{}OUTPUT.SERVEROUTPUT(TRUE);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Flush messages from the buffer\PYGZsq{});
END;

This message goes to the message buffer
Flush messages from the buffer
\end{sphinxVerbatim}

\newpage


\section{\index{DBMS\_PIPE}DBMS\_PIPE}
\label{\detokenize{dbms_pipe::doc}}\label{\detokenize{dbms_pipe:dbms-pipe}}
The \sphinxcode{DBMS\_PIPE} package provides the capability to send messages through
a pipe within or between sessions connected to the same database
cluster.

The procedures and functions available in the \sphinxcode{DBMS\_PIPE} package are
listed in the following table:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|\Y{0.4}|\Y{0.2}|\Y{0.4}|}
\hline

\sphinxstylestrong{Function/Procedure}
&
\sphinxstylestrong{Return Type}
&
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{CREATE\_PIPE(\textless{}pipename\textgreater{} {[}, \textless{}maxpipesize\textgreater{} {]} {[}, \textless{}private\textgreater{} {]})}
&
\sphinxcode{INTEGER}
&
Explicitly create a private pipe if \sphinxcode{\textless{}private\textgreater{}} is “true” (the default) or a public pipe if \sphinxcode{\textless{}private\textgreater{}} is “false”.
\\
\hline
\sphinxcode{NEXT\_ITEM\_TYPE}
&
\sphinxcode{INTEGER}
&
Determine the data type of the next item in a received message.
\\
\hline
\sphinxcode{PACK\_MESSAGE(\textless{}item\textgreater{})}
&
n/a
&
Place \sphinxcode{\textless{}item\textgreater{}} in the session’s local message buffer.
\\
\hline
\sphinxcode{PURGE(\textless{}pipename\textgreater{})}
&
n/a
&
Remove unreceived messages from the specified pipe.
\\
\hline
\sphinxcode{RECEIVE\_MESSAGE(\textless{}pipename\textgreater{} {[}, \textless{}timeout\textgreater{} {]})}
&
\sphinxcode{INTEGER}
&
Get a message from a specified pipe.
\\
\hline
\sphinxcode{REMOVE\_PIPE(\textless{}pipename\textgreater{})}
&
\sphinxcode{INTEGER}
&
Delete an explicitly created pipe.
\\
\hline
\sphinxcode{RESET\_BUFFER}
&
n/a
&
Reset the local message buffer.
\\
\hline
\sphinxcode{SEND\_MESSAGE(\textless{}pipename\textgreater{} {[}, \textless{}timeout\textgreater{} {]} {[}, \textless{}maxpipesize\textgreater{} {]})}
&
\sphinxcode{INTEGER}
&
Send a message on a pipe.
\\
\hline
\sphinxcode{UNIQUE\_SESSION\_NAME}
&
\sphinxcode{VARCHAR2}
&
Obtain a unique session name.
\\
\hline
\sphinxcode{UNPACK\_MESSAGE(\textless{}item\textgreater{} OUT)}
&
n/a
&
Retrieve the next data item from a message into a type-compatible variable, \sphinxcode{\textless{}item\textgreater{}}.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Pipes are categorized as implicit or explicit. An \sphinxstyleemphasis{implicit pipe} is
created if a reference is made to a pipe name that was not previously
created by the \sphinxcode{CREATE\_PIPE} function. For example, if the \sphinxcode{SEND\_MESSAGE}
function is executed using a non-existent pipe name, a new implicit pipe
is created with that name. An \sphinxstyleemphasis{explicit pipe} is created using the
\sphinxcode{CREATE\_PIPE} function whereby the first parameter specifies the pipe
name for the new pipe.

Pipes are also categorized as private or public. A \sphinxstyleemphasis{private pipe} can
only be accessed by the user who created the pipe. Even a superuser
cannot access a private pipe that was created by another user. A \sphinxstyleemphasis{public
pipe} can be accessed by any user who has access to the \sphinxcode{DBMS\_PIPE}
package.

A public pipe can only be created by using the \sphinxcode{CREATE\_PIPE} function
with the third parameter set to \sphinxcode{FALSE}. The \sphinxcode{CREATE\_PIPE} function can be
used to create a private pipe by setting the third parameter to \sphinxcode{TRUE} or
by omitting the third parameter. All implicit pipes are private.

The individual data items or “lines” of a message are first built-in a
\sphinxstyleemphasis{local message buffer}, unique to the current session. The \sphinxcode{PACK\_MESSAGE}
procedure builds the message in the session’s local message buffer. The
\sphinxcode{SEND\_MESSAGE} function is then used to send the message through the
pipe.

Receipt of a message involves the reverse operation. The
\sphinxcode{RECEIVE\_MESSAGE} function is used to get a message from the specified
pipe. The message is written to the session’s local message buffer. The
\sphinxcode{UNPACK\_MESSAGE} procedure is then used to transfer the message data
items from the message buffer to program variables. If a pipe contains
multiple messages, \sphinxcode{RECEIVE\_MESSAGE} gets the messages in \sphinxstyleemphasis{FIFO}
(first-in-first-out) order.

Each session maintains separate message buffers for messages created
with the \sphinxcode{PACK\_MESSAGE} procedure and messages retrieved by the
\sphinxcode{RECEIVE\_MESSAGE} function. Thus messages can be both built and received
in the same session. However, if consecutive \sphinxcode{RECEIVE\_MESSAGE} calls are
made, only the message from the last \sphinxcode{RECEIVE\_MESSAGE} call will be
preserved in the local message buffer.

\newpage


\subsection{\index{CREATE\_PIPE}CREATE\_PIPE}
\label{\detokenize{create_pipe::doc}}\label{\detokenize{create_pipe:create-pipe}}
The \sphinxcode{CREATE\_PIPE} function creates an explicit public pipe or an explicit
private pipe with a specified name.
\begin{quote}

\sphinxcode{\textless{}status\textgreater{} INTEGER CREATE\_PIPE(\textless{}pipename\textgreater{} VARCHAR2}
\begin{quote}

\sphinxcode{{[}, \textless{}maxpipesize\textgreater{} INTEGER {]} {[}, \textless{}private\textgreater{} BOOLEAN {]})}
\end{quote}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}pipename\textgreater{}}
\begin{quote}

Name of the pipe.
\end{quote}

\sphinxcode{\textless{}maxpipesize\textgreater{}}
\begin{quote}

Maximum capacity of the pipe in bytes. Default is 8192 bytes.
\end{quote}

\sphinxcode{\textless{}private\textgreater{}}
\begin{quote}

Create a public pipe if set to FALSE. Create a private pipe if set to
\sphinxcode{TRUE.} This is the default.
\end{quote}

\sphinxcode{\textless{}status\textgreater{}}
\begin{quote}

Status code returned by the operation. 0 indicates successful creation.
\end{quote}

\sphinxstylestrong{Examples}

The following example creates a private pipe named \sphinxcode{messages:}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    v\PYGZus{}status        INTEGER;
BEGIN
    v\PYGZus{}status := DBMS\PYGZus{}PIPE.CREATE\PYGZus{}PIPE(\PYGZsq{}messages\PYGZsq{});
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}CREATE\PYGZus{}PIPE status: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}status);
END;
CREATE\PYGZus{}PIPE status: 0
\end{sphinxVerbatim}

The following example creates a public pipe named \sphinxcode{mailbox:}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    v\PYGZus{}status        INTEGER;
BEGIN
    v\PYGZus{}status := DBMS\PYGZus{}PIPE.CREATE\PYGZus{}PIPE(\PYGZsq{}mailbox\PYGZsq{},8192,FALSE);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}CREATE\PYGZus{}PIPE status: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}status);
END;
CREATE\PYGZus{}PIPE status: 0
\end{sphinxVerbatim}

\newpage


\subsection{\index{NEXT\_ITEM\_TYPE}NEXT\_ITEM\_TYPE}
\label{\detokenize{next_item_pipe:next-item-type}}\label{\detokenize{next_item_pipe::doc}}
The \sphinxcode{NEXT\_ITEM\_TYPE} function returns an integer code identifying the
data type of the next data item in a message that has been retrieved
into the session’s local message buffer. As each item is moved off of
the local message buffer with the \sphinxcode{UNPACK\_MESSAGE} procedure, the
\sphinxcode{NEXT\_ITEM\_TYPE} function will return the data type code for the next
available item. A code of 0 is returned when there are no more items
left in the message.
\begin{quote}

\sphinxcode{\textless{}typecode\textgreater{} INTEGER NEXT\_ITEM\_TYPE}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}typecode\textgreater{}}

Code identifying the data type of the next data item as shown in the following table.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Type Code
&
Data Type
\\
\hline
0
&
No more data items
\\
\hline
9
&
NUMBER
\\
\hline
11
&
VARCHAR2
\\
\hline
13
&
DATE
\\
\hline
23
&
RAW
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{sphinxadmonition}{note}{Note:}
The type codes list in the table are not compatible with Oracle databases. Oracle assigns a different numbering sequence to the data types.
\end{sphinxadmonition}

\sphinxstylestrong{Examples}

The following example shows a pipe packed with a \sphinxcode{NUMBER} item, a \sphinxcode{VARCHAR2}
item, a \sphinxcode{DATE} item, and a \sphinxcode{RAW} item. A second anonymous block then uses
the \sphinxcode{NEXT\_ITEM\_TYPE} function to display the type code of each item.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    v\PYGZus{}number        NUMBER := 123;
    v\PYGZus{}varchar       VARCHAR2(20) := \PYGZsq{}Character data\PYGZsq{};
    v\PYGZus{}date          DATE := SYSDATE;
    v\PYGZus{}raw           RAW(4) := \PYGZsq{}21222324\PYGZsq{};
    v\PYGZus{}status        INTEGER;
BEGIN
    DBMS\PYGZus{}PIPE.PACK\PYGZus{}MESSAGE(v\PYGZus{}number);
    DBMS\PYGZus{}PIPE.PACK\PYGZus{}MESSAGE(v\PYGZus{}varchar);
    DBMS\PYGZus{}PIPE.PACK\PYGZus{}MESSAGE(v\PYGZus{}date);
    DBMS\PYGZus{}PIPE.PACK\PYGZus{}MESSAGE(v\PYGZus{}raw);
    v\PYGZus{}status := DBMS\PYGZus{}PIPE.SEND\PYGZus{}MESSAGE(\PYGZsq{}datatypes\PYGZsq{});
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}SEND\PYGZus{}MESSAGE status: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}status);
EXCEPTION
    WHEN OTHERS THEN
        DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}SQLERRM: \PYGZsq{} \textbar{}\textbar{} SQLERRM);
        DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}SQLCODE: \PYGZsq{} \textbar{}\textbar{} SQLCODE);
END;

SEND\PYGZus{}MESSAGE status: 0

DECLARE
    v\PYGZus{}number        NUMBER;
    v\PYGZus{}varchar       VARCHAR2(20);
    v\PYGZus{}date          DATE;
    v\PYGZus{}timestamp     TIMESTAMP;
    v\PYGZus{}raw           RAW(4);
    v\PYGZus{}status        INTEGER;
BEGIN
    v\PYGZus{}status := DBMS\PYGZus{}PIPE.RECEIVE\PYGZus{}MESSAGE(\PYGZsq{}datatypes\PYGZsq{});
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}RECEIVE\PYGZus{}MESSAGE status: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}status);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZsq{});

    v\PYGZus{}status := DBMS\PYGZus{}PIPE.NEXT\PYGZus{}ITEM\PYGZus{}TYPE;
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}NEXT\PYGZus{}ITEM\PYGZus{}TYPE: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}status);
    DBMS\PYGZus{}PIPE.UNPACK\PYGZus{}MESSAGE(v\PYGZus{}number);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}NUMBER Item   : \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}number);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZsq{});

    v\PYGZus{}status := DBMS\PYGZus{}PIPE.NEXT\PYGZus{}ITEM\PYGZus{}TYPE;
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}NEXT\PYGZus{}ITEM\PYGZus{}TYPE: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}status);
    DBMS\PYGZus{}PIPE.UNPACK\PYGZus{}MESSAGE(v\PYGZus{}varchar);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}VARCHAR2 Item : \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}varchar);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZsq{});

    v\PYGZus{}status := DBMS\PYGZus{}PIPE.NEXT\PYGZus{}ITEM\PYGZus{}TYPE;
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}NEXT\PYGZus{}ITEM\PYGZus{}TYPE: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}status);
    DBMS\PYGZus{}PIPE.UNPACK\PYGZus{}MESSAGE(v\PYGZus{}date);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}DATE Item     : \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}date);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZsq{});

    v\PYGZus{}status := DBMS\PYGZus{}PIPE.NEXT\PYGZus{}ITEM\PYGZus{}TYPE;
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}NEXT\PYGZus{}ITEM\PYGZus{}TYPE: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}status);
    DBMS\PYGZus{}PIPE.UNPACK\PYGZus{}MESSAGE(v\PYGZus{}raw);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}RAW Item      : \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}raw);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZsq{});

    v\PYGZus{}status := DBMS\PYGZus{}PIPE.NEXT\PYGZus{}ITEM\PYGZus{}TYPE;
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}NEXT\PYGZus{}ITEM\PYGZus{}TYPE: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}status);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZsq{});
EXCEPTION
    WHEN OTHERS THEN
        DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}SQLERRM: \PYGZsq{} \textbar{}\textbar{} SQLERRM);
        DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}SQLCODE: \PYGZsq{} \textbar{}\textbar{} SQLCODE);
END;

RECEIVE\PYGZus{}MESSAGE status: 0
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
NEXT\PYGZus{}ITEM\PYGZus{}TYPE: 9
NUMBER Item   : 123
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
NEXT\PYGZus{}ITEM\PYGZus{}TYPE: 11
VARCHAR2 Item : Character data
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
NEXT\PYGZus{}ITEM\PYGZus{}TYPE: 13
DATE Item     : 02\PYGZhy{}OCT\PYGZhy{}07 11:11:43
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
NEXT\PYGZus{}ITEM\PYGZus{}TYPE: 23
RAW Item      : 21222324
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
NEXT\PYGZus{}ITEM\PYGZus{}TYPE: 0
\end{sphinxVerbatim}

\newpage


\subsection{\index{PACK\_MESSAGE}PACK\_MESSAGE}
\label{\detokenize{pack_message::doc}}\label{\detokenize{pack_message:pack-message}}
The \sphinxcode{PACK\_MESSAGE} procedure places an item of data in the session’s
local message buffer. \sphinxcode{PACK\_MESSAGE} must be executed at least once
before issuing a \sphinxcode{SEND\_MESSAGE} call.
\begin{quote}

\sphinxcode{PACK\_MESSAGE(\textless{}item\textgreater{} \{ DATE \textbar{} NUMBER \textbar{} VARCHAR2 \textbar{} RAW \})}
\end{quote}

Use the \sphinxcode{UNPACK\_MESSAGE} procedure to obtain data items once the message
is retrieved using a \sphinxcode{RECEIVE\_MESSAGE} call.

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}item\textgreater{}}

An expression evaluating to any of the acceptable parameter data types.
The value is added to the session’s local message buffer.

\newpage


\subsection{\index{PURGE}PURGE}
\label{\detokenize{purge::doc}}\label{\detokenize{purge:purge}}
The \sphinxcode{PURGE} procedure removes the unreceived messages from a specified
implicit pipe.

\sphinxcode{PURGE(\textless{}pipename\textgreater{} VARCHAR2)}

Use the \sphinxcode{REMOVE\_PIPE} function to delete an explicit pipe.

\sphinxstylestrong{Parameter}

\sphinxcode{\textless{}pipename\textgreater{}}
\begin{quote}

Name of the pipe.
\end{quote}

\sphinxstylestrong{Examples}

Two messages are sent on a pipe:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    v\PYGZus{}status        INTEGER;
BEGIN
    DBMS\PYGZus{}PIPE.PACK\PYGZus{}MESSAGE(\PYGZsq{}Message \PYGZsh{}1\PYGZsq{});
    v\PYGZus{}status := DBMS\PYGZus{}PIPE.SEND\PYGZus{}MESSAGE(\PYGZsq{}pipe\PYGZsq{});
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}SEND\PYGZus{}MESSAGE status: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}status);

    DBMS\PYGZus{}PIPE.PACK\PYGZus{}MESSAGE(\PYGZsq{}Message \PYGZsh{}2\PYGZsq{});
    v\PYGZus{}status := DBMS\PYGZus{}PIPE.SEND\PYGZus{}MESSAGE(\PYGZsq{}pipe\PYGZsq{});
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}SEND\PYGZus{}MESSAGE status: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}status);
END;

SEND\PYGZus{}MESSAGE status: 0
SEND\PYGZus{}MESSAGE status: 0
\end{sphinxVerbatim}

Receive the first message and unpack it:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    v\PYGZus{}item          VARCHAR2(80);
    v\PYGZus{}status        INTEGER;
BEGIN
    v\PYGZus{}status := DBMS\PYGZus{}PIPE.RECEIVE\PYGZus{}MESSAGE(\PYGZsq{}pipe\PYGZsq{},1);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}RECEIVE\PYGZus{}MESSAGE status: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}status);
    DBMS\PYGZus{}PIPE.UNPACK\PYGZus{}MESSAGE(v\PYGZus{}item);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Item: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}item);
END;

RECEIVE\PYGZus{}MESSAGE status: 0
Item: Message \PYGZsh{}1
\end{sphinxVerbatim}

Purge the pipe:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
EXEC DBMS\PYGZus{}PIPE.PURGE(\PYGZsq{}pipe\PYGZsq{});
\end{sphinxVerbatim}

\newpage

Try to retrieve the next message. The RECEIVE\_MESSAGE call returns status code 1 indicating it timed out because no message was available.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    v\PYGZus{}item          VARCHAR2(80);
    v\PYGZus{}status        INTEGER;
BEGIN
    v\PYGZus{}status := DBMS\PYGZus{}PIPE.RECEIVE\PYGZus{}MESSAGE(\PYGZsq{}pipe\PYGZsq{},1);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}RECEIVE\PYGZus{}MESSAGE status: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}status);
END;

RECEIVE\PYGZus{}MESSAGE status: 1
\end{sphinxVerbatim}

\newpage


\subsection{\index{RECEIVE\_MESSAGE}RECEIVE\_MESSAGE}
\label{\detokenize{receive_message::doc}}\label{\detokenize{receive_message:receive-message}}
The \sphinxcode{RECEIVE\_MESSAGE} function obtains a message from a specified pipe.
\begin{quote}

\sphinxcode{\textless{}status\textgreater{} INTEGER RECEIVE\_MESSAGE(\textless{}pipename\textgreater{} VARCHAR2}
\begin{quote}

\sphinxcode{{[}, \textless{}timeout\textgreater{} INTEGER {]})}
\end{quote}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}pipename\textgreater{}}
\begin{quote}

Name of the pipe.
\end{quote}

\sphinxcode{\textless{}timeout\textgreater{}}
\begin{quote}

Wait time (seconds). Default is 86400000 (1000 days).
\end{quote}

\sphinxcode{\textless{}status\textgreater{}}
\begin{quote}

Status code returned by the operation.
\end{quote}

The possible status codes are:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|\Y{0.5}|\Y{0.5}|}
\hline

Status Code
&
Description
\\
\hline
0
&
Success
\\
\hline
1
&
Time out
\\
\hline
2
&
Message too large .for the buffer
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\newpage


\subsection{\index{REMOVE\_PIPE}REMOVE\_PIPE}
\label{\detokenize{remove_pipe::doc}}\label{\detokenize{remove_pipe:remove-pipe}}
The \sphinxcode{REMOVE\_PIPE} function deletes an explicit private or explicit public
pipe.

\sphinxcode{\textless{}status\textgreater{} INTEGER REMOVE\_PIPE(\textless{}pipename\textgreater{} VARCHAR2)}

Use the \sphinxcode{REMOVE\_PIPE} function to delete explicitly created pipes \textendash{} i.e.,
pipes created with the \sphinxcode{CREATE\_PIPE} function.

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}pipename\textgreater{}}
\begin{quote}

Name of the pipe.
\end{quote}

\sphinxcode{\textless{}status\textgreater{}}
\begin{quote}

Status code returned by the operation. A status code of 0 is returned
even if the named pipe is non-existent.
\end{quote}

\sphinxstylestrong{Examples}

Two messages are sent on a pipe:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    v\PYGZus{}status        INTEGER;
BEGIN
    v\PYGZus{}status := DBMS\PYGZus{}PIPE.CREATE\PYGZus{}PIPE(\PYGZsq{}pipe\PYGZsq{});
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}CREATE\PYGZus{}PIPE status : \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}status);

    DBMS\PYGZus{}PIPE.PACK\PYGZus{}MESSAGE(\PYGZsq{}Message \PYGZsh{}1\PYGZsq{});
    v\PYGZus{}status := DBMS\PYGZus{}PIPE.SEND\PYGZus{}MESSAGE(\PYGZsq{}pipe\PYGZsq{});
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}SEND\PYGZus{}MESSAGE status: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}status);

    DBMS\PYGZus{}PIPE.PACK\PYGZus{}MESSAGE(\PYGZsq{}Message \PYGZsh{}2\PYGZsq{});
    v\PYGZus{}status := DBMS\PYGZus{}PIPE.SEND\PYGZus{}MESSAGE(\PYGZsq{}pipe\PYGZsq{});
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}SEND\PYGZus{}MESSAGE status: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}status);
END;

CREATE\PYGZus{}PIPE status : 0
SEND\PYGZus{}MESSAGE status: 0
SEND\PYGZus{}MESSAGE status: 0
\end{sphinxVerbatim}

Receive the first message and unpack it:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    v\PYGZus{}item          VARCHAR2(80);
    v\PYGZus{}status        INTEGER;
BEGIN
    v\PYGZus{}status := DBMS\PYGZus{}PIPE.RECEIVE\PYGZus{}MESSAGE(\PYGZsq{}pipe\PYGZsq{},1);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}RECEIVE\PYGZus{}MESSAGE status: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}status);
    DBMS\PYGZus{}PIPE.UNPACK\PYGZus{}MESSAGE(v\PYGZus{}item);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Item: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}item);
END;

RECEIVE\PYGZus{}MESSAGE status: 0
Item: Message \PYGZsh{}1
\end{sphinxVerbatim}

\newpage

Remove the pipe:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
SELECT DBMS\PYGZus{}PIPE.REMOVE\PYGZus{}PIPE(\PYGZsq{}pipe\PYGZsq{}) FROM DUAL;



remove\PYGZus{}pipe

\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
          0

(1 row)
\end{sphinxVerbatim}

Try to retrieve the next message. The \sphinxcode{RECEIVE\_MESSAGE} call returns
status code 1 indicating it timed out because the pipe had been deleted.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    v\PYGZus{}item          VARCHAR2(80);
    v\PYGZus{}status        INTEGER;
BEGIN
    v\PYGZus{}status := DBMS\PYGZus{}PIPE.RECEIVE\PYGZus{}MESSAGE(\PYGZsq{}pipe\PYGZsq{},1);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}RECEIVE\PYGZus{}MESSAGE status: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}status);
END;

RECEIVE\PYGZus{}MESSAGE status: 1
\end{sphinxVerbatim}

\newpage


\subsection{\index{RESET\_BUFFER}RESET\_BUFFER}
\label{\detokenize{reset_buffer::doc}}\label{\detokenize{reset_buffer:reset-buffer}}
The \sphinxcode{RESET\_BUFFER} procedure resets a “pointer” to the session’s local
message buffer back to the beginning of the buffer. This has the effect
of causing subsequent \sphinxcode{PACK\_MESSAGE} calls to overwrite any data items
that existed in the message buffer prior to the \sphinxcode{RESET\_BUFFER} call.
\begin{quote}

\sphinxcode{RESET\_BUFFER}
\end{quote}

Examples

A message to John is written to the local message buffer. It is replaced
by a message to Bob by calling \sphinxcode{RESET\_BUFFER}. The message is sent on the
pipe.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    v\PYGZus{}status        INTEGER;
BEGIN
    DBMS\PYGZus{}PIPE.PACK\PYGZus{}MESSAGE(\PYGZsq{}Hi, John\PYGZsq{});
    DBMS\PYGZus{}PIPE.PACK\PYGZus{}MESSAGE(\PYGZsq{}Can you attend a meeting at 3:00, today?\PYGZsq{});
    DBMS\PYGZus{}PIPE.PACK\PYGZus{}MESSAGE(\PYGZsq{}If not, is tomorrow at 8:30 ok with you?\PYGZsq{});
    DBMS\PYGZus{}PIPE.RESET\PYGZus{}BUFFER;
    DBMS\PYGZus{}PIPE.PACK\PYGZus{}MESSAGE(\PYGZsq{}Hi, Bob\PYGZsq{});
    DBMS\PYGZus{}PIPE.PACK\PYGZus{}MESSAGE(\PYGZsq{}Can you attend a meeting at 9:30, tomorrow?\PYGZsq{});
    v\PYGZus{}status := DBMS\PYGZus{}PIPE.SEND\PYGZus{}MESSAGE(\PYGZsq{}pipe\PYGZsq{});
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}SEND\PYGZus{}MESSAGE status: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}status);
END;

SEND\PYGZus{}MESSAGE status: 0
\end{sphinxVerbatim}

The message to Bob is in the received message.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    v\PYGZus{}item          VARCHAR2(80);
    v\PYGZus{}status        INTEGER;
BEGIN
    v\PYGZus{}status := DBMS\PYGZus{}PIPE.RECEIVE\PYGZus{}MESSAGE(\PYGZsq{}pipe\PYGZsq{},1);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}RECEIVE\PYGZus{}MESSAGE status: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}status);
    DBMS\PYGZus{}PIPE.UNPACK\PYGZus{}MESSAGE(v\PYGZus{}item);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Item: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}item);
    DBMS\PYGZus{}PIPE.UNPACK\PYGZus{}MESSAGE(v\PYGZus{}item);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Item: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}item);
END;

RECEIVE\PYGZus{}MESSAGE status: 0
Item: Hi, Bob
Item: Can you attend a meeting at 9:30, tomorrow?
\end{sphinxVerbatim}

\newpage


\subsection{\index{SEND\_MESSAGE}SEND\_MESSAGE}
\label{\detokenize{send_message::doc}}\label{\detokenize{send_message:send-message}}
The \sphinxcode{SEND\_MESSAGE} function sends a message from the session’s local
message buffer to the specified pipe.
\begin{quote}

\sphinxcode{\textless{}status\textgreater{} SEND\_MESSAGE(\textless{}pipename\textgreater{} VARCHAR2 {[}, \textless{}timeout\textgreater{} INTEGER {]}}
\begin{quote}

\sphinxcode{{[}, \textless{}maxpipesize\textgreater{} INTEGER {]})}
\end{quote}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}pipename\textgreater{}}
\begin{quote}

Name of the pipe.
\end{quote}

\sphinxcode{\textless{}timeout\textgreater{}}
\begin{quote}

Wait time (seconds). Default is 86400000 (1000 days).
\end{quote}

\sphinxcode{\textless{}maxpipesize\textgreater{}}
\begin{quote}

Maximum capacity of the pipe in bytes. Default is 8192 bytes.
\end{quote}

\sphinxcode{\textless{}status\textgreater{}}
\begin{quote}

Status code returned by the operation.
\end{quote}

The possible status codes are:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|\Y{0.5}|\Y{0.5}|}
\hline

Status Code
&
Description
\\
\hline
0
&
Success
\\
\hline
1
&
Time out
\\
\hline
3
&
Function interrupted
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\newpage


\subsection{\index{UNIQUE\_SESSION\_NAME}UNIQUE\_SESSION\_NAME}
\label{\detokenize{unique_session_name::doc}}\label{\detokenize{unique_session_name:unique-session-name}}
The \sphinxcode{UNIQUE\_SESSION\_NAME} function returns a name, unique to the current
session.

\sphinxcode{\textless{}name\textgreater{} VARCHAR2 UNIQUE\_SESSION\_NAME}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}name\textgreater{}}

Unique session name.

\sphinxstylestrong{Examples}

The following anonymous block retrieves and displays a unique session
name.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    v\PYGZus{}session       VARCHAR2(30);
BEGIN
    v\PYGZus{}session := DBMS\PYGZus{}PIPE.UNIQUE\PYGZus{}SESSION\PYGZus{}NAME;
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Session Name: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}session);
END;

Session Name: PG\PYGZdl{}PIPE\PYGZdl{}5\PYGZdl{}2752
\end{sphinxVerbatim}

\newpage


\subsection{\index{UNPACK\_MESSAGE}UNPACK\_MESSAGE}
\label{\detokenize{unpack_message::doc}}\label{\detokenize{unpack_message:unpack-message}}
The \sphinxcode{UNPACK\_MESSAGE} procedure copies the data items of a message from
the local message buffer to a specified program variable. The message
must be placed in the local message buffer with the \sphinxcode{RECEIVE\_MESSAGE}
function before using \sphinxcode{UNPACK\_MESSAGE}.
\begin{quote}

\sphinxcode{UNPACK\_MESSAGE(\textless{}item\textgreater{} OUT \{ DATE \textbar{} NUMBER \textbar{} VARCHAR2 \textbar{} RAW \})}
\end{quote}

\sphinxstylestrong{Parameter}

\sphinxcode{\textless{}item\textgreater{}}

Type-compatible variable that receives a data item from the local
message buffer.

\newpage

\index{DBMS\_PIPE\_Comprehensive\_example}\ignorespaces 

\subsection{Comprehensive Example}
\label{\detokenize{comprehensive_example::doc}}\label{\detokenize{comprehensive_example:comprehensive-example}}\label{\detokenize{comprehensive_example:index-0}}
The following example uses a pipe as a “mailbox”. The procedures to
create the mailbox, add a multi-item message to the mailbox (up to three
items), and display the full contents of the mailbox are enclosed in a
package named, \sphinxcode{mailbox}.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
CREATE OR REPLACE PACKAGE mailbox
IS
    PROCEDURE create\PYGZus{}mailbox;
    PROCEDURE add\PYGZus{}message (
        p\PYGZus{}mailbox   VARCHAR2,
        p\PYGZus{}item\PYGZus{}1    VARCHAR2,
        p\PYGZus{}item\PYGZus{}2    VARCHAR2 DEFAULT \PYGZsq{}END\PYGZsq{},
        p\PYGZus{}item\PYGZus{}3    VARCHAR2 DEFAULT \PYGZsq{}END\PYGZsq{}
    );
    PROCEDURE empty\PYGZus{}mailbox (
        p\PYGZus{}mailbox   VARCHAR2,
        p\PYGZus{}waittime  INTEGER DEFAULT 10
    );
END mailbox;

CREATE OR REPLACE PACKAGE BODY mailbox
IS
    PROCEDURE create\PYGZus{}mailbox
    IS
        v\PYGZus{}mailbox   VARCHAR2(30);
        v\PYGZus{}status    INTEGER;
    BEGIN
        v\PYGZus{}mailbox := DBMS\PYGZus{}PIPE.UNIQUE\PYGZus{}SESSION\PYGZus{}NAME;
        v\PYGZus{}status := DBMS\PYGZus{}PIPE.CREATE\PYGZus{}PIPE(v\PYGZus{}mailbox,1000,FALSE);
        IF v\PYGZus{}status = 0 THEN
            DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Created mailbox: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}mailbox);
        ELSE
            DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}CREATE\PYGZus{}PIPE failed \PYGZhy{} status: \PYGZsq{} \textbar{}\textbar{}
                v\PYGZus{}status);
        END IF;
    END create\PYGZus{}mailbox;

    PROCEDURE add\PYGZus{}message (
        p\PYGZus{}mailbox   VARCHAR2,
        p\PYGZus{}item\PYGZus{}1    VARCHAR2,
        p\PYGZus{}item\PYGZus{}2    VARCHAR2 DEFAULT \PYGZsq{}END\PYGZsq{},
        p\PYGZus{}item\PYGZus{}3    VARCHAR2 DEFAULT \PYGZsq{}END\PYGZsq{}
    )
    IS
        v\PYGZus{}item\PYGZus{}cnt  INTEGER := 0;
        v\PYGZus{}status    INTEGER;
    BEGIN
        DBMS\PYGZus{}PIPE.PACK\PYGZus{}MESSAGE(p\PYGZus{}item\PYGZus{}1);
        v\PYGZus{}item\PYGZus{}cnt := 1;
        IF p\PYGZus{}item\PYGZus{}2 != \PYGZsq{}END\PYGZsq{} THEN
            DBMS\PYGZus{}PIPE.PACK\PYGZus{}MESSAGE(p\PYGZus{}item\PYGZus{}2);
            v\PYGZus{}item\PYGZus{}cnt := v\PYGZus{}item\PYGZus{}cnt + 1;
        END IF;
        IF p\PYGZus{}item\PYGZus{}3 != \PYGZsq{}END\PYGZsq{} THEN
            DBMS\PYGZus{}PIPE.PACK\PYGZus{}MESSAGE(p\PYGZus{}item\PYGZus{}3);
            v\PYGZus{}item\PYGZus{}cnt := v\PYGZus{}item\PYGZus{}cnt + 1;
        END IF;
        v\PYGZus{}status := DBMS\PYGZus{}PIPE.SEND\PYGZus{}MESSAGE(p\PYGZus{}mailbox);
        IF v\PYGZus{}status = 0 THEN
            DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Added message with \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}item\PYGZus{}cnt \textbar{}\textbar{}
                \PYGZsq{} item(s) to mailbox \PYGZsq{} \textbar{}\textbar{} p\PYGZus{}mailbox);
        ELSE
            DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}SEND\PYGZus{}MESSAGE in add\PYGZus{}message failed \PYGZhy{} \PYGZsq{} \textbar{}\textbar{}
                \PYGZsq{}status: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}status);
        END IF;
    END add\PYGZus{}message;

    PROCEDURE empty\PYGZus{}mailbox (
        p\PYGZus{}mailbox   VARCHAR2,
        p\PYGZus{}waittime  INTEGER DEFAULT 10
    )
    IS
        v\PYGZus{}msgno     INTEGER DEFAULT 0;
        v\PYGZus{}itemno    INTEGER DEFAULT 0;
        v\PYGZus{}item      VARCHAR2(100);
        v\PYGZus{}status    INTEGER;
    BEGIN
        v\PYGZus{}status := DBMS\PYGZus{}PIPE.RECEIVE\PYGZus{}MESSAGE(p\PYGZus{}mailbox,p\PYGZus{}waittime);
        WHILE v\PYGZus{}status = 0 LOOP
            v\PYGZus{}msgno := v\PYGZus{}msgno + 1;
            DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}****** Start message \PYGZsh{}\PYGZsq{} \textbar{}\textbar{} v\PYGZus{}msgno \textbar{}\textbar{}
                \PYGZsq{} ******\PYGZsq{});
            BEGIN
                LOOP
                    v\PYGZus{}status := DBMS\PYGZus{}PIPE.NEXT\PYGZus{}ITEM\PYGZus{}TYPE;
                    EXIT WHEN v\PYGZus{}status = 0;
                    DBMS\PYGZus{}PIPE.UNPACK\PYGZus{}MESSAGE(v\PYGZus{}item);
                    v\PYGZus{}itemno := v\PYGZus{}itemno + 1;
                    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Item \PYGZsh{}\PYGZsq{} \textbar{}\textbar{} v\PYGZus{}itemno \textbar{}\textbar{} \PYGZsq{}: \PYGZsq{} \textbar{}\textbar{}
                        v\PYGZus{}item);
                END LOOP;
                DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}******* End message \PYGZsh{}\PYGZsq{} \textbar{}\textbar{} v\PYGZus{}msgno \textbar{}\textbar{}
                    \PYGZsq{} *******\PYGZsq{});
                DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}*\PYGZsq{});
                v\PYGZus{}itemno := 0;
                v\PYGZus{}status := DBMS\PYGZus{}PIPE.RECEIVE\PYGZus{}MESSAGE(p\PYGZus{}mailbox,1);
            END;
        END LOOP;
        DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Number of messages received: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}msgno);
        v\PYGZus{}status := DBMS\PYGZus{}PIPE.REMOVE\PYGZus{}PIPE(p\PYGZus{}mailbox);
        IF v\PYGZus{}status = 0 THEN
            DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Deleted mailbox \PYGZsq{} \textbar{}\textbar{} p\PYGZus{}mailbox);
        ELSE
            DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Could not delete mailbox \PYGZhy{} status: \PYGZsq{}
                \textbar{}\textbar{} v\PYGZus{}status);
        END IF;
    END empty\PYGZus{}mailbox;
END mailbox;
\end{sphinxVerbatim}

\newpage

The following demonstrates the execution of the procedures in \sphinxcode{mailbox}.
The first procedure creates a public pipe using a name generated by the
\sphinxcode{UNIQUE\_SESSION\_NAME} function.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
EXEC mailbox.create\PYGZus{}mailbox;
Created mailbox: PG\PYGZdl{}PIPE\PYGZdl{}13\PYGZdl{}3940
\end{sphinxVerbatim}

Using the mailbox name, any user in the same database with access to the
\sphinxcode{mailbox} package and \sphinxcode{DBMS\_PIPE} package can add messages:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
EXEC mailbox.add\PYGZus{}message(\PYGZsq{}PG\PYGZdl{}PIPE\PYGZdl{}13\PYGZdl{}3940\PYGZsq{},\PYGZsq{}Hi, John\PYGZsq{},\PYGZsq{}Can you attend a meeting at 3:00, today?\PYGZsq{},\PYGZsq{}\PYGZhy{}\PYGZhy{} Mary\PYGZsq{});

Added message with 3 item(s) to mailbox PG\PYGZdl{}PIPE\PYGZdl{}13\PYGZdl{}3940

EXEC mailbox.add\PYGZus{}message(\PYGZsq{}PG\PYGZdl{}PIPE\PYGZdl{}13\PYGZdl{}3940\PYGZsq{},\PYGZsq{}Don\PYGZsq{}\PYGZsq{}t forget to submit your report\PYGZsq{},\PYGZsq{}Thanks,\PYGZsq{},\PYGZsq{}\PYGZhy{}\PYGZhy{} Joe\PYGZsq{});

Added message with 3 item(s) to mailbox PG\PYGZdl{}PIPE\PYGZdl{}13\PYGZdl{}3940
\end{sphinxVerbatim}

Finally, the contents of the mailbox can be emptied:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
EXEC mailbox.empty\PYGZus{}mailbox(\PYGZsq{}PG\PYGZdl{}PIPE\PYGZdl{}13\PYGZdl{}3940\PYGZsq{});

****** Start message \PYGZsh{}1 ******
Item \PYGZsh{}1: Hi, John
Item \PYGZsh{}2: Can you attend a meeting at 3:00, today?
Item \PYGZsh{}3: \PYGZhy{}\PYGZhy{} Mary
******* End message \PYGZsh{}1 *******
*
****** Start message \PYGZsh{}2 ******
Item \PYGZsh{}1: Don\PYGZsq{}t forget to submit your report
Item \PYGZsh{}2: Thanks,
Item \PYGZsh{}3: Joe
******* End message \PYGZsh{}2 *******
*
Number of messages received: 2
Deleted mailbox PG\PYGZdl{}PIPE\PYGZdl{}13\PYGZdl{}3940
\end{sphinxVerbatim}

\newpage


\section{\index{DBMS\_PROFILER}DBMS\_PROFILER}
\label{\detokenize{dbms_profiler::doc}}\label{\detokenize{dbms_profiler:dbms-profiler}}
The \sphinxcode{DBMS\_PROFILER} package collects and stores performance information
about the PL/pgSQL and SPL statements that are executed during a
performance profiling session; use the functions and procedures listed
below to control the profiling tool.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

Function/Procedure
&
Return Type
&
Description
\\
\hline
\sphinxcode{FLUSH\_DATA}
&
Status Code or Exception
&
Flushes performance data collected in the current session without terminating the session (profiling continues).
\\
\hline
\sphinxcode{GET\_VERSION(\textless{}major\textgreater{} OUT, \textless{}minor\textgreater{} OUT)}
&
n/a
&
Returns the version number of this package.
\\
\hline
\sphinxcode{INTERNAL\_VERSION\_CHECK}
&
Status Code
&
Confirms that the current version of the profiler will work with the current database.
\\
\hline
\sphinxcode{PAUSE\_PROFILER}
&
Status Code or Exception
&
Pause data collection.
\\
\hline
\sphinxcode{RESUME\_PROFILER}
&
Status Code or Exception
&
Resume data collection.
\\
\hline
\sphinxcode{START\_PROFILER(\textless{}run\_comment\textgreater{}, \textless{}run\_comment1\textgreater{} {[}, \textless{}run\_number\textgreater{} OUT {]})}
&
Status Code or Exception
&
Start data collection.
\\
\hline
\sphinxcode{STOP\_PROFILER}
&
Status Code or Exception
&
Stop data collection and flush performance data to the \sphinxcode{PLSQL\_PROFILER\_RAWDATA} table.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

The functions within the \sphinxcode{DBMS\_PROFILER} package return a status code to
indicate success or failure; the \sphinxcode{DBMS\_PROFILER} procedures raise an
exception only if they encounter a failure. The status codes and
messages returned by the functions, and the exceptions raised by the
procedures are listed in the table below.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Status Code
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Message
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Exception
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Description
\unskip}\relax \\
\hline
\sphinxcode{-1}
&
\sphinxcode{error version}
&
\sphinxcode{version\_mismatch}
&
The profiler version and the database are incompatible.
\\
\hline
\sphinxcode{0}
&
\sphinxcode{success}
&
n/a
&
The operation completed successfully.
\\
\hline
\sphinxcode{1}
&
\sphinxcode{error\_param}
&
\sphinxcode{profiler\_error}
&
The operation received an incorrect parameter.
\\
\hline
\sphinxcode{2}
&
\sphinxcode{error\_io}
&
\sphinxcode{profiler\_error}
&
The data flush operation has failed.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\newpage


\subsection{\index{FLUSH\_DATA}FLUSH\_DATA}
\label{\detokenize{dbms_profiler:flush-data}}
The \sphinxcode{FLUSH\_DATA} function/procedure flushes the data collected in the
current session without terminating the profiler session. The data is
flushed to the tables described in the Advanced Server Performance
Features Guide. The function and procedure signatures are:
\begin{quote}

\sphinxcode{\textless{}status\textgreater{} INTEGER FLUSH\_DATA}

\sphinxcode{FLUSH\_DATA}
\end{quote}

\sphinxstylestrong{Parameter}

\sphinxcode{\textless{}status\textgreater{}}
\begin{quote}

Status code returned by the operation.
\end{quote}


\subsection{\index{GET\_VERSION}GET\_VERSION}
\label{\detokenize{dbms_profiler:get-version}}
The \sphinxcode{GET\_VERSION} procedure returns the version of \sphinxcode{DBMS\_PROFILER}. The
procedure signature is:

\sphinxcode{GET\_VERSION(\textless{}major\textgreater{} OUT INTEGER, \textless{}minor\textgreater{} OUT INTEGER)}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}major\textgreater{}}
\begin{quote}

The major version number of \sphinxcode{DBMS\_PROFILER}.
\end{quote}

\sphinxcode{\textless{}minor\textgreater{}}
\begin{quote}

The minor version number of \sphinxcode{DBMS\_PROFILER}.
\end{quote}


\subsection{\index{INTERNAL\_VERSION\_CHECK}INTERNAL\_VERSION\_CHECK}
\label{\detokenize{dbms_profiler:internal-version-check}}
The \sphinxcode{INTERNAL\_VERSION\_CHECK} function confirms that the current version
of \sphinxcode{DBMS\_PROFILER} will work with the current database. The function
signature is:
\begin{quote}

\sphinxcode{\textless{}status\textgreater{} INTEGER INTERNAL\_VERSION\_CHECK}
\end{quote}

\sphinxstylestrong{Parameter}

\sphinxcode{\textless{}status\textgreater{}}

Status code returned by the operation.


\subsection{\index{PAUSE\_PROFILER}PAUSE\_PROFILER}
\label{\detokenize{dbms_profiler:pause-profiler}}
The \sphinxcode{PAUSE\_PROFILER} function/procedure pauses a profiling session. The
function and procedure signatures are:
\begin{quote}

\sphinxcode{\textless{}status\textgreater{} INTEGER PAUSE\_PROFILER}

\sphinxcode{PAUSE\_PROFILER}
\end{quote}

\sphinxstylestrong{Parameter}

\sphinxcode{\textless{}status\textgreater{}}
\begin{quote}

Status code returned by the operation.
\end{quote}


\subsection{\index{RESUME\_PROFILER}RESUME\_PROFILER}
\label{\detokenize{dbms_profiler:resume-profiler}}
The \sphinxcode{RESUME\_PROFILER} function/procedure pauses a profiling session. The
function and procedure signatures are:
\begin{quote}

\sphinxcode{\textless{}status\textgreater{} INTEGER RESUME\_PROFILER}

\sphinxcode{RESUME\_PROFILER}
\end{quote}

\sphinxstylestrong{Parameter}

\sphinxcode{\textless{}status\textgreater{}}
\begin{quote}

Status code returned by the operation.
\end{quote}


\subsection{\index{START\_PROFILER}START\_PROFILER}
\label{\detokenize{dbms_profiler:start-profiler}}
The \sphinxcode{START\_PROFILER} function/procedure starts a data collection session.
The function and procedure signatures are:
\begin{quote}

\sphinxcode{\textless{}status\textgreater{} INTEGER START\_PROFILER(\textless{}run\_comment\textgreater{} TEXT := SYSDATE},
\begin{quote}

\sphinxcode{\textless{}run\_comment1\textgreater{} TEXT := '{'} {[}, \textless{}run\_number\textgreater{} OUT INTEGER {]})}
\end{quote}

\sphinxcode{START\_PROFILER(\textless{}run\_comment\textgreater{} TEXT := SYSDATE,}
\begin{quote}

\sphinxcode{\textless{}run\_comment1\textgreater{} TEXT := '{'} {[}, \textless{}run\_number\textgreater{} OUT INTEGER {]})}
\end{quote}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}run\_comment\textgreater{}}
\begin{quote}

A user-defined comment for the profiler session. The default value is
\sphinxcode{SYSDATE}.
\end{quote}

\sphinxcode{\textless{}run\_comment1\textgreater{}}
\begin{quote}

An additional user-defined comment for the profiler session. The default
value is ‘’.
\end{quote}

\sphinxcode{\textless{}run\_number\textgreater{}}
\begin{quote}

The session number of the profiler session.
\end{quote}

\sphinxcode{\textless{}status\textgreater{}}
\begin{quote}

Status code returned by the operation.
\end{quote}


\subsection{\index{STOP\_PROFILER}STOP\_PROFILER}
\label{\detokenize{dbms_profiler:stop-profiler}}
The \sphinxcode{STOP\_PROFILER} function/procedure stops a profiling session and
flushes the performance information to the \sphinxcode{DBMS\_PROFILER} tables and
view. The function and procedure signatures are:
\begin{quote}

\sphinxcode{\textless{}status\textgreater{} INTEGER STOP\_PROFILER}

\sphinxcode{STOP\_PROFILER}
\end{quote}

\sphinxstylestrong{Parameter}

\sphinxcode{\textless{}status\textgreater{}}
\begin{quote}

Status code returned by the operation.
\end{quote}

\newpage


\subsection{\index{Using DBMS\_PROFILER}Using DBMS\_PROFILER}
\label{\detokenize{dbms_profiler:using-dbms-profiler}}
The \sphinxcode{DBMS\_PROFILER} package collects and stores performance information
about the PL/pgSQL and SPL statements that are executed during a
profiling session; you can review the performance information in the
tables and views provided by the profiler.

\sphinxcode{DBMS\_PROFILER} works by recording a set of performance-related counters
and timers for each line of PL/pgSQL or SPL statement that executes
within a profiling session. The counters and timers are stored in a
table named \sphinxcode{SYS.PLSQL\_PROFILER\_DATA}. When you complete a profiling
session, \sphinxcode{DBMS\_PROFILER} will write a row to the performance statistics
table for each line of PL/pgSQL or SPL code that executed within the
session. For example, if you execute the following function:

\sphinxcode{1 - CREATE OR REPLACE FUNCTION getBalance(acctNumber INTEGER)}

\sphinxcode{2 - RETURNS NUMERIC AS \$\$}

\sphinxcode{3 - DECLARE}

\sphinxcode{4 - result NUMERIC;}

\sphinxcode{5 - BEGIN}

\sphinxcode{6 - SELECT INTO result balance FROM acct WHERE id = acctNumber;}

\sphinxcode{7 -}

\sphinxcode{8 - IF (result IS NULL) THEN}

\sphinxcode{9 -     RAISE INFO 'Balance is null';}

\sphinxcode{10- END IF;}

\sphinxcode{11-}

\sphinxcode{12- RETURN result;}

\sphinxcode{13- END;}

\sphinxcode{14- \$\$ LANGUAGE 'plpgsql';}

\sphinxcode{DBMS\_PROFILER} adds one \sphinxcode{PLSQL\_PROFILER\_DATA} entry for each line of
code within the \sphinxcode{getBalance()} function (including blank lines and
comments). The entry corresponding to the \sphinxcode{SELECT} statement executed
exactly one time; and required a very small amount of time to execute.
On the other hand, the entry corresponding to the \sphinxcode{RAISE INFO} statement
executed once or not at all (depending on the value for the \sphinxcode{balance}
column).

Some of the lines in this function contain no executable code so the
performance statistics for those lines will always contain zero values.

To start a profiling session, invoke the \sphinxcode{DBMS\_PROFILER.START\_PROFILER}
function (or procedure). Once you’ve invoked \sphinxcode{START\_PROFILER}, Advanced
Server will profile every PL/pgSQL or SPL function, procedure, trigger,
or anonymous block that your session executes until you either stop or
pause the profiler (by calling \sphinxcode{STOP\_PROFILER} or \sphinxcode{PAUSE\_PROFILER}).

It is important to note that when you start (or resume) the profiler,
the profiler will only gather performance statistics for
functions/procedures/triggers that start after the call to
\sphinxcode{START\_PROFILER} (or \sphinxcode{RESUME\_PROFILER}).

While the profiler is active, Advanced Server records a large set of
timers and counters in memory; when you invoke the \sphinxcode{STOP\_PROFILER} (or
\sphinxcode{FLUSH\_DATA}) function/procedure, \sphinxcode{DBMS\_PROFILER} writes those timers and
counters to a set of three tables:
\begin{itemize}
\item {} 
\sphinxcode{SYS.PLSQL\_PROFILER\_RAWDATA}

Contains the performance counters and timers for each statement
executed within the session.

\item {} 
\sphinxcode{SYS.PLSQL\_PROFILER\_RUNS}

Contains a summary of each run (aggregating the information found
in \sphinxcode{PLSQL\_PROFILER\_RAWDATA}).

\item {} 
\sphinxcode{SYS.PLSQL\_PROFILER\_UNITS}

Contains a summary of each code unit (function, procedure, trigger,
or anonymous block) executed within a session.

\end{itemize}

In addition, \sphinxcode{DBMS\_PROFILER} defines a view, \sphinxcode{SYS.PLSQL\_PROFILER\_DATA},
which contains a subset of the \sphinxcode{PLSQL\_PROFILER\_RAWDATA} table.

Please note that a non-superuser may gather profiling information, but
may not view that profiling information unless a superuser grants
specific privileges on the profiling tables (stored in the \sphinxcode{SYS} schema).
This permits a non-privileged user to gather performance statistics
without exposing information that the administrator may want to keep
secret.

\newpage


\subsubsection{Querying the DBMS\_PROFILER Tables and View}
\label{\detokenize{dbms_profiler:querying-the-dbms-profiler-tables-and-view}}
The following step-by-step example uses \sphinxcode{DBMS\_PROFILER} to retrieve
performance information for procedures, functions, and triggers included
in the sample data distributed with Advanced Server.
\begin{enumerate}
\item {} 
Open the EDB-PSQL command line, and establish a connection to the
Advanced Server database. Use an \sphinxcode{EXEC} statement to start the
profiling session:

\end{enumerate}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
acctg=\PYGZsh{} EXEC dbms\PYGZus{}profiler.start\PYGZus{}profiler(\PYGZsq{}profile list\PYGZus{}emp\PYGZsq{});

EDB\PYGZhy{}SPL Procedure successfully completed
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
(The call to \sphinxcode{start\_profiler()} includes a comment that
\sphinxcode{DBMS\_PROFILER} associates with the profiler session).
\end{sphinxadmonition}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
Then call the \sphinxcode{list\_emp} function:

\end{enumerate}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
acctg=\PYGZsh{} SELECT list\PYGZus{}emp();
INFO:  EMPNO    ENAME
INFO:  \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}    \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
INFO:  7369     SMITH
INFO:  7499     ALLEN
INFO:  7521     WARD
INFO:  7566     JONES
INFO:  7654     MARTIN
INFO:  7698     BLAKE
INFO:  7782     CLARK
INFO:  7788     SCOTT
INFO:  7839     KING
INFO:  7844     TURNER
INFO:  7876     ADAMS
INFO:  7900     JAMES
INFO:  7902     FORD
INFO:  7934     MILLER
 list\PYGZus{}emp
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}

(1 row)
\end{sphinxVerbatim}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
Stop the profiling session with a call to
\sphinxcode{dbms\_profiler.stop\_profiler:}

\end{enumerate}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
acctg=\PYGZsh{} EXEC dbms\PYGZus{}profiler.stop\PYGZus{}profiler;

EDB\PYGZhy{}SPL Procedure successfully completed
\end{sphinxVerbatim}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
Start a new session with the \sphinxcode{dbms\_profiler.start\_profiler} function
(followed by a new comment):

\end{enumerate}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
acctg=\PYGZsh{} EXEC dbms\PYGZus{}profiler.start\PYGZus{}profiler(\PYGZsq{}profile get\PYGZus{}dept\PYGZus{}name and
emp\PYGZus{}sal\PYGZus{}trig\PYGZsq{});

EDB\PYGZhy{}SPL Procedure successfully completed
\end{sphinxVerbatim}

\newpage
\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
Invoke the \sphinxcode{get\_dept\_name} function:

\end{enumerate}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
acctg=\PYGZsh{} SELECT get\PYGZus{}dept\PYGZus{}name(10);
 get\PYGZus{}dept\PYGZus{}name
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
 ACCOUNTING
(1 row)
\end{sphinxVerbatim}
\begin{enumerate}
\setcounter{enumi}{5}
\item {} 
Execute an \sphinxcode{UPDATE} statement that causes a trigger to execute:

\end{enumerate}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
acctg=\PYGZsh{} UPDATE memp SET sal = 500 WHERE empno = 7902;
INFO: Updating employee 7902
INFO: ..Old salary: 3000.00
INFO: ..New salary: 500.00
INFO: ..Raise: \PYGZhy{}2500.00
INFO: User enterprisedb updated employee(s) on 04\PYGZhy{}FEB\PYGZhy{}14
UPDATE 1
\end{sphinxVerbatim}
\begin{enumerate}
\setcounter{enumi}{6}
\item {} 
Terminate the profiling session and flush the performance information
to the profiling tables:

\end{enumerate}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
acctg=\PYGZsh{} EXEC dbms\PYGZus{}profiler.stop\PYGZus{}profiler;

EDB\PYGZhy{}SPL Procedure successfully completed
\end{sphinxVerbatim}
\begin{enumerate}
\setcounter{enumi}{7}
\item {} 
Now, query the \sphinxcode{plsql\_profiler\_runs} table to view a list of the
profiling sessions, arranged by \sphinxcode{runid:}

\end{enumerate}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
acctg=\PYGZsh{} SELECT * FROM plsql\PYGZus{}profiler\PYGZus{}runs;
 runid \textbar{} related\PYGZus{}run \textbar{}  run\PYGZus{}owner   \textbar{}         run\PYGZus{}date          \textbar{}              run\PYGZus{}comment
\textbar{}run\PYGZus{}total\PYGZus{}time \textbar{} run\PYGZus{}system\PYGZus{}info \textbar{} run\PYGZus{}comment1 \textbar{} spare1
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
     1 \textbar{}             \textbar{} enterprisedb \textbar{} 04\PYGZhy{}FEB\PYGZhy{}14 09:32:48.874315 \textbar{} profile list\PYGZus{}emp                       \textbar{}           4154 \textbar{}                 \textbar{}              \textbar{}
     2 \textbar{}             \textbar{} enterprisedb \textbar{} 04\PYGZhy{}FEB\PYGZhy{}14 09:41:30.546503 \textbar{} profile get\PYGZus{}dept\PYGZus{}name and emp\PYGZus{}sal\PYGZus{}trig \textbar{}           2088 \textbar{}                 \textbar{}              \textbar{}
(2 rows)
\end{sphinxVerbatim}
\begin{enumerate}
\setcounter{enumi}{8}
\item {} 
Query the \sphinxcode{plsql\_profiler\_units} table to view the amount of time
consumed by each unit (each function, procedure, or trigger):

\end{enumerate}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
acctg=\PYGZsh{} SELECT * FROM plsql\PYGZus{}profiler\PYGZus{}units;
 runid \textbar{} unit\PYGZus{}number \textbar{} unit\PYGZus{}type \textbar{}  unit\PYGZus{}owner  \textbar{}            unit\PYGZus{}name            \textbar{} unit\PYGZus{}timestamp \textbar{} total\PYGZus{}time \textbar{} spare1 \textbar{} spare2
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
     1 \textbar{}       16999 \textbar{} FUNCTION  \textbar{} enterprisedb \textbar{} list\PYGZus{}emp()                      \textbar{}                \textbar{}          4 \textbar{}        \textbar{}
     2 \textbar{}       17002 \textbar{} FUNCTION  \textbar{} enterprisedb \textbar{} user\PYGZus{}audit\PYGZus{}trig()               \textbar{}                \textbar{}          1 \textbar{}        \textbar{}
     2 \textbar{}       17000 \textbar{} FUNCTION  \textbar{} enterprisedb \textbar{} get\PYGZus{}dept\PYGZus{}name(p\PYGZus{}deptno numeric) \textbar{}                \textbar{}          1 \textbar{}        \textbar{}
     2 \textbar{}       17004 \textbar{} FUNCTION  \textbar{} enterprisedb \textbar{} emp\PYGZus{}sal\PYGZus{}trig()                  \textbar{}                \textbar{}          1 \textbar{}        \textbar{}
(4 rows)
\end{sphinxVerbatim}
\begin{enumerate}
\setcounter{enumi}{9}
\item {} 
Query the \sphinxcode{plsql\_profiler\_rawdata} table to view a list of the wait event counters and wait event times:

\end{enumerate}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
acctg=\PYGZsh{} SELECT runid, sourcecode, func\PYGZus{}oid, line\PYGZus{}number, exec\PYGZus{}count, tuples\PYGZus{}returned, time\PYGZus{}total FROM plsql\PYGZus{}profiler\PYGZus{}rawdata;

 runid \textbar{}                            sourcecode                           \textbar{} func\PYGZus{}oid \textbar{} line\PYGZus{}number \textbar{} exec\PYGZus{}count \textbar{} tuples\PYGZus{}returned \textbar{} time\PYGZus{}total
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
    1 \textbar{} DECLARE                                                          \textbar{}    16999 \textbar{}           1 \textbar{}          0 \textbar{}               0 \textbar{}          0
    1 \textbar{}     v\PYGZus{}empno         NUMERIC(4);                                  \textbar{}    16999 \textbar{}           2 \textbar{}          0 \textbar{}               0 \textbar{}          0
    1 \textbar{}     v\PYGZus{}ename         VARCHAR(10);                                 \textbar{}    16999 \textbar{}           3 \textbar{}          0 \textbar{}               0 \textbar{}          0
    1 \textbar{}     emp\PYGZus{}cur CURSOR FOR                                           \textbar{}    16999 \textbar{}           4 \textbar{}          0 \textbar{}               0 \textbar{}          0
    1 \textbar{}         SELECT empno, ename FROM memp ORDER BY empno;            \textbar{}    16999 \textbar{}           5 \textbar{}          0 \textbar{}               0 \textbar{}          0
    1 \textbar{} BEGIN                                                            \textbar{}    16999 \textbar{}           6 \textbar{}          0 \textbar{}               0 \textbar{}          0
    1 \textbar{}     OPEN emp\PYGZus{}cur;                                                \textbar{}    16999 \textbar{}           7 \textbar{}          0 \textbar{}               0 \textbar{}          0
    1 \textbar{}     RAISE INFO \PYGZsq{}EMPNO    ENAME\PYGZsq{};                                 \textbar{}    16999 \textbar{}           8 \textbar{}          1 \textbar{}               0 \textbar{}   0.001621
    1 \textbar{}     RAISE INFO \PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}    \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZsq{};                               \textbar{}    16999 \textbar{}           9 \textbar{}          1 \textbar{}               0 \textbar{}   0.000301
    1 \textbar{}     LOOP                                                         \textbar{}    16999 \textbar{}          10 \textbar{}          1 \textbar{}               0 \textbar{}    4.6e\PYGZhy{}05
    1 \textbar{}         FETCH emp\PYGZus{}cur INTO v\PYGZus{}empno, v\PYGZus{}ename;                     \textbar{}    16999 \textbar{}          11 \textbar{}          1 \textbar{}               0 \textbar{}   0.001114
    1 \textbar{}         EXIT WHEN NOT FOUND;                                     \textbar{}    16999 \textbar{}          12 \textbar{}         15 \textbar{}               0 \textbar{}   0.000206
    1 \textbar{}         RAISE INFO \PYGZsq{}\PYGZpc{}     \PYGZpc{}\PYGZsq{}, v\PYGZus{}empno, v\PYGZus{}ename;                  \textbar{}    16999 \textbar{}          13 \textbar{}         15 \textbar{}               0 \textbar{}    8.3e\PYGZhy{}05
    1 \textbar{}     END LOOP;                                                    \textbar{}    16999 \textbar{}          14 \textbar{}         14 \textbar{}               0 \textbar{}   0.000773
    1 \textbar{}     CLOSE emp\PYGZus{}cur;                                               \textbar{}    16999 \textbar{}          15 \textbar{}          0 \textbar{}               0 \textbar{}          0
    1 \textbar{}     RETURN;                                                      \textbar{}    16999 \textbar{}          16 \textbar{}          1 \textbar{}               0 \textbar{}      1e\PYGZhy{}05
    1 \textbar{} END;                                                             \textbar{}    16999 \textbar{}          17 \textbar{}          1 \textbar{}               0 \textbar{}          0
    1 \textbar{}                                                                  \textbar{}    16999 \textbar{}          18 \textbar{}          0 \textbar{}               0 \textbar{}          0
    2 \textbar{} DECLARE                                                          \textbar{}    17002 \textbar{}           1 \textbar{}          0 \textbar{}               0 \textbar{}          0
    2 \textbar{}     v\PYGZus{}action        VARCHAR(24);                                 \textbar{}    17002 \textbar{}           2 \textbar{}          0 \textbar{}               0 \textbar{}          0
    2 \textbar{}     v\PYGZus{}text          TEXT;                                        \textbar{}    17002 \textbar{}           3 \textbar{}          0 \textbar{}               0 \textbar{}          0
    2 \textbar{} BEGIN                                                            \textbar{}    17002 \textbar{}           4 \textbar{}          0 \textbar{}               0 \textbar{}          0
    2 \textbar{}     IF TG\PYGZus{}OP = \PYGZsq{}INSERT\PYGZsq{} THEN                                     \textbar{}    17002 \textbar{}           5 \textbar{}          0 \textbar{}               0 \textbar{}          0
    2 \textbar{}         v\PYGZus{}action := \PYGZsq{} added employee(s) on \PYGZsq{};                    \textbar{}    17002 \textbar{}           6 \textbar{}          1 \textbar{}               0 \textbar{}   0.000143
    2 \textbar{}     ELSIF TG\PYGZus{}OP = \PYGZsq{}UPDATE\PYGZsq{} THEN                                  \textbar{}    17002 \textbar{}           7 \textbar{}          0 \textbar{}               0 \textbar{}          0
    2 \textbar{}         v\PYGZus{}action := \PYGZsq{} updated employee(s) on \PYGZsq{};                  \textbar{}    17002 \textbar{}           8 \textbar{}          0 \textbar{}               0 \textbar{}          0
    2 \textbar{}     ELSIF TG\PYGZus{}OP = \PYGZsq{}DELETE\PYGZsq{} THEN                                  \textbar{}    17002 \textbar{}           9 \textbar{}          1 \textbar{}               0 \textbar{}    3.2e\PYGZhy{}05
    2 \textbar{}         v\PYGZus{}action := \PYGZsq{} deleted employee(s) on \PYGZsq{};                  \textbar{}    17002 \textbar{}          10 \textbar{}          0 \textbar{}               0 \textbar{}          0
    2 \textbar{}     END IF;                                                      \textbar{}    17002 \textbar{}          11 \textbar{}          0 \textbar{}               0 \textbar{}          0
    2 \textbar{}     v\PYGZus{}text := \PYGZsq{}User \PYGZsq{} \textbar{}\textbar{} USER \textbar{}\textbar{} v\PYGZus{}action \textbar{}\textbar{} CURRENT\PYGZus{}DATE;       \textbar{}    17002 \textbar{}          12 \textbar{}          0 \textbar{}               0 \textbar{}          0
    2 \textbar{}     RAISE INFO \PYGZsq{} \PYGZpc{}\PYGZsq{}, v\PYGZus{}text;                                     \textbar{}    17002 \textbar{}          13 \textbar{}          1 \textbar{}               0 \textbar{}   0.000383
    2 \textbar{}     RETURN NULL;                                                 \textbar{}    17002 \textbar{}          14 \textbar{}          1 \textbar{}               0 \textbar{}    6.3e\PYGZhy{}05
    2 \textbar{} END;                                                             \textbar{}    17002 \textbar{}          15 \textbar{}          1 \textbar{}               0 \textbar{}    3.6e\PYGZhy{}05
    2 \textbar{}                                                                  \textbar{}    17002 \textbar{}          16 \textbar{}          0 \textbar{}               0 \textbar{}          0
    2 \textbar{} DECLARE                                                          \textbar{}    17000 \textbar{}           1 \textbar{}          0 \textbar{}               0 \textbar{}          0
    2 \textbar{}     v\PYGZus{}dname         VARCHAR(14);                                 \textbar{}    17000 \textbar{}           2 \textbar{}          0 \textbar{}               0 \textbar{}          0
    2 \textbar{} BEGIN                                                            \textbar{}    17000 \textbar{}           3 \textbar{}          0 \textbar{}               0 \textbar{}          0
    2 \textbar{}     SELECT INTO v\PYGZus{}dname dname FROM dept WHERE deptno = p\PYGZus{}deptno; \textbar{}    17000 \textbar{}           4 \textbar{}          0 \textbar{}               0 \textbar{}          0
    2 \textbar{}     RETURN v\PYGZus{}dname;                                              \textbar{}    17000 \textbar{}           5 \textbar{}          1 \textbar{}               0 \textbar{}   0.000647
    2 \textbar{}     IF NOT FOUND THEN                                            \textbar{}    17000 \textbar{}           6 \textbar{}          1 \textbar{}               0 \textbar{}    2.6e\PYGZhy{}05
    2 \textbar{}         RAISE INFO \PYGZsq{}Invalid department number \PYGZpc{}\PYGZsq{}, p\PYGZus{}deptno;      \textbar{}    17000 \textbar{}           7 \textbar{}          0 \textbar{}               0 \textbar{}          0
    2 \textbar{}         RETURN \PYGZsq{}\PYGZsq{};                                               \textbar{}    17000 \textbar{}           8 \textbar{}          0 \textbar{}               0 \textbar{}          0
    2 \textbar{}     END IF;                                                      \textbar{}    17000 \textbar{}           9 \textbar{}          0 \textbar{}               0 \textbar{}          0
    2 \textbar{} END;                                                             \textbar{}    17000 \textbar{}          10 \textbar{}          0 \textbar{}               0 \textbar{}          0
    2 \textbar{}                                                                  \textbar{}    17000 \textbar{}          11 \textbar{}          0 \textbar{}               0 \textbar{}          0
    2 \textbar{} DECLARE                                                          \textbar{}    17004 \textbar{}           1 \textbar{}          0 \textbar{}               0 \textbar{}          0
    2 \textbar{}     sal\PYGZus{}diff       NUMERIC(7,2);                                 \textbar{}    17004 \textbar{}           2 \textbar{}          0 \textbar{}               0 \textbar{}          0
    2 \textbar{} BEGIN                                                            \textbar{}    17004 \textbar{}           3 \textbar{}          0 \textbar{}               0 \textbar{}          0
    2 \textbar{}     IF TG\PYGZus{}OP = \PYGZsq{}INSERT\PYGZsq{} THEN                                     \textbar{}    17004 \textbar{}           4 \textbar{}          0 \textbar{}               0 \textbar{}          0
    2 \textbar{}         RAISE INFO \PYGZsq{}Inserting employee \PYGZpc{}\PYGZsq{}, NEW.empno;            \textbar{}    17004 \textbar{}           5 \textbar{}          1 \textbar{}               0 \textbar{}    8.4e\PYGZhy{}05
    2 \textbar{}         RAISE INFO \PYGZsq{}..New salary: \PYGZpc{}\PYGZsq{}, NEW.sal;                   \textbar{}    17004 \textbar{}           6 \textbar{}          0 \textbar{}               0 \textbar{}          0
    2 \textbar{}         RETURN NEW;                                              \textbar{}    17004 \textbar{}           7 \textbar{}          0 \textbar{}               0 \textbar{}          0
    2 \textbar{}     END IF;                                                      \textbar{}    17004 \textbar{}           8 \textbar{}          0 \textbar{}               0 \textbar{}          0
    2 \textbar{}     IF TG\PYGZus{}OP = \PYGZsq{}UPDATE\PYGZsq{} THEN                                     \textbar{}    17004 \textbar{}           9 \textbar{}          0 \textbar{}               0 \textbar{}          0
    2 \textbar{}         sal\PYGZus{}diff := NEW.sal \PYGZhy{} OLD.sal;                           \textbar{}    17004 \textbar{}          10 \textbar{}          1 \textbar{}               0 \textbar{}   0.000355
    2 \textbar{}         RAISE INFO \PYGZsq{}Updating employee \PYGZpc{}\PYGZsq{}, OLD.empno;             \textbar{}    17004 \textbar{}          11 \textbar{}          1 \textbar{}               0 \textbar{}   0.000177
    2 \textbar{}         RAISE INFO \PYGZsq{}..Old salary: \PYGZpc{}\PYGZsq{}, OLD.sal;                   \textbar{}    17004 \textbar{}          12 \textbar{}          1 \textbar{}               0 \textbar{}    5.5e\PYGZhy{}05
    2 \textbar{}         RAISE INFO \PYGZsq{}..New salary: \PYGZpc{}\PYGZsq{}, NEW.sal;                   \textbar{}    17004 \textbar{}          13 \textbar{}          1 \textbar{}               0 \textbar{}    3.1e\PYGZhy{}05
    2 \textbar{}         RAISE INFO \PYGZsq{}..Raise     : \PYGZpc{}\PYGZsq{}, sal\PYGZus{}diff;                  \textbar{}    17004 \textbar{}          14 \textbar{}          1 \textbar{}               0 \textbar{}    2.8e\PYGZhy{}05
    2 \textbar{}         RETURN NEW;                                              \textbar{}    17004 \textbar{}          15 \textbar{}          1 \textbar{}               0 \textbar{}    2.7e\PYGZhy{}05
    2 \textbar{}     END IF;                                                      \textbar{}    17004 \textbar{}          16 \textbar{}          1 \textbar{}               0 \textbar{}      1e\PYGZhy{}06
    2 \textbar{}     IF TG\PYGZus{}OP = \PYGZsq{}DELETE\PYGZsq{} THEN                                     \textbar{}    17004 \textbar{}          17 \textbar{}          0 \textbar{}               0 \textbar{}          0
    2 \textbar{}         RAISE INFO \PYGZsq{}Deleting employee \PYGZpc{}\PYGZsq{}, OLD.empno;             \textbar{}    17004 \textbar{}          18 \textbar{}          0 \textbar{}               0 \textbar{}          0
    2 \textbar{}         RAISE INFO \PYGZsq{}..Old salary: \PYGZpc{}\PYGZsq{}, OLD.sal;                   \textbar{}    17004 \textbar{}          19 \textbar{}          0 \textbar{}               0 \textbar{}          0
    2 \textbar{}         RETURN OLD;                                              \textbar{}    17004 \textbar{}          20 \textbar{}          0 \textbar{}               0 \textbar{}          0
    2 \textbar{}     END IF;                                                      \textbar{}    17004 \textbar{}          21 \textbar{}          0 \textbar{}               0 \textbar{}          0
    2 \textbar{} END;                                                             \textbar{}    17004 \textbar{}          22 \textbar{}          0 \textbar{}               0 \textbar{}          0
    2 \textbar{}                                                                  \textbar{}    17004 \textbar{}          23 \textbar{}          0 \textbar{}               0 \textbar{}          0
 (68 rows)
\end{sphinxVerbatim}
\begin{enumerate}
\setcounter{enumi}{10}
\item {} 
Query the \sphinxcode{plsql\_profiler\_data} view to review a subset of the information found in \sphinxcode{plsql\_profiler\_rawdata} table:

\end{enumerate}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
acctg=\PYGZsh{} SELECT * FROM plsql\PYGZus{}profiler\PYGZus{}data;
runid \textbar{} unit\PYGZus{}number \textbar{} line\PYGZsh{} \textbar{} total\PYGZus{}occur \textbar{} total\PYGZus{}time \textbar{} min\PYGZus{}time \textbar{} max\PYGZus{}time \textbar{} spare1 \textbar{} spare2 \textbar{} spare3 \textbar{} spare4
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
     1 \textbar{}       16999 \textbar{}     1 \textbar{}           0 \textbar{}          0 \textbar{}        0 \textbar{}        0 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     1 \textbar{}       16999 \textbar{}     2 \textbar{}           0 \textbar{}          0 \textbar{}        0 \textbar{}        0 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     1 \textbar{}       16999 \textbar{}     3 \textbar{}           0 \textbar{}          0 \textbar{}        0 \textbar{}        0 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     1 \textbar{}       16999 \textbar{}     4 \textbar{}           0 \textbar{}          0 \textbar{}        0 \textbar{}        0 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     1 \textbar{}       16999 \textbar{}     5 \textbar{}           0 \textbar{}          0 \textbar{}        0 \textbar{}        0 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     1 \textbar{}       16999 \textbar{}     6 \textbar{}           0 \textbar{}          0 \textbar{}        0 \textbar{}        0 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     1 \textbar{}       16999 \textbar{}     7 \textbar{}           0 \textbar{}          0 \textbar{}        0 \textbar{}        0 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     1 \textbar{}       16999 \textbar{}     8 \textbar{}           1 \textbar{}   0.001621 \textbar{} 0.001621 \textbar{} 0.001621 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     1 \textbar{}       16999 \textbar{}     9 \textbar{}           1 \textbar{}   0.000301 \textbar{} 0.000301 \textbar{} 0.000301 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     1 \textbar{}       16999 \textbar{}    10 \textbar{}           1 \textbar{}    4.6e\PYGZhy{}05 \textbar{}  4.6e\PYGZhy{}05 \textbar{}  4.6e\PYGZhy{}05 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     1 \textbar{}       16999 \textbar{}    11 \textbar{}           1 \textbar{}   0.001114 \textbar{} 0.001114 \textbar{} 0.001114 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     1 \textbar{}       16999 \textbar{}    12 \textbar{}          15 \textbar{}   0.000206 \textbar{}    5e\PYGZhy{}06 \textbar{}  7.8e\PYGZhy{}05 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     1 \textbar{}       16999 \textbar{}    13 \textbar{}          15 \textbar{}    8.3e\PYGZhy{}05 \textbar{}    2e\PYGZhy{}06 \textbar{}  4.7e\PYGZhy{}05 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     1 \textbar{}       16999 \textbar{}    14 \textbar{}          14 \textbar{}   0.000773 \textbar{}  4.7e\PYGZhy{}05 \textbar{} 0.000116 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     1 \textbar{}       16999 \textbar{}    15 \textbar{}           0 \textbar{}          0 \textbar{}        0 \textbar{}        0 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     1 \textbar{}       16999 \textbar{}    16 \textbar{}           1 \textbar{}      1e\PYGZhy{}05 \textbar{}    1e\PYGZhy{}05 \textbar{}    1e\PYGZhy{}05 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     1 \textbar{}       16999 \textbar{}    17 \textbar{}           1 \textbar{}          0 \textbar{}        0 \textbar{}        0 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     1 \textbar{}       16999 \textbar{}    18 \textbar{}           0 \textbar{}          0 \textbar{}        0 \textbar{}        0 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17002 \textbar{}     1 \textbar{}           0 \textbar{}          0 \textbar{}        0 \textbar{}        0 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17002 \textbar{}     2 \textbar{}           0 \textbar{}          0 \textbar{}        0 \textbar{}        0 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17002 \textbar{}     3 \textbar{}           0 \textbar{}          0 \textbar{}        0 \textbar{}        0 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17002 \textbar{}     4 \textbar{}           0 \textbar{}          0 \textbar{}        0 \textbar{}        0 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17002 \textbar{}     5 \textbar{}           0 \textbar{}          0 \textbar{}        0 \textbar{}        0 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17002 \textbar{}     6 \textbar{}           1 \textbar{}   0.000143 \textbar{} 0.000143 \textbar{} 0.000143 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17002 \textbar{}     7 \textbar{}           0 \textbar{}          0 \textbar{}        0 \textbar{}        0 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17002 \textbar{}     8 \textbar{}           0 \textbar{}          0 \textbar{}        0 \textbar{}        0 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17002 \textbar{}     9 \textbar{}           1 \textbar{}    3.2e\PYGZhy{}05 \textbar{}  3.2e\PYGZhy{}05 \textbar{}  3.2e\PYGZhy{}05 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17002 \textbar{}    10 \textbar{}           0 \textbar{}          0 \textbar{}        0 \textbar{}        0 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17002 \textbar{}    11 \textbar{}           0 \textbar{}          0 \textbar{}        0 \textbar{}        0 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17002 \textbar{}    12 \textbar{}           0 \textbar{}          0 \textbar{}        0 \textbar{}        0 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17002 \textbar{}    13 \textbar{}           1 \textbar{}   0.000383 \textbar{} 0.000383 \textbar{} 0.000383 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17002 \textbar{}    14 \textbar{}           1 \textbar{}    6.3e\PYGZhy{}05 \textbar{}  6.3e\PYGZhy{}05 \textbar{}  6.3e\PYGZhy{}05 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17002 \textbar{}    15 \textbar{}           1 \textbar{}    3.6e\PYGZhy{}05 \textbar{}  3.6e\PYGZhy{}05 \textbar{}  3.6e\PYGZhy{}05 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17002 \textbar{}    16 \textbar{}           0 \textbar{}          0 \textbar{}        0 \textbar{}        0 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17000 \textbar{}     1 \textbar{}           0 \textbar{}          0 \textbar{}        0 \textbar{}        0 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17000 \textbar{}     2 \textbar{}           0 \textbar{}          0 \textbar{}        0 \textbar{}        0 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17000 \textbar{}     3 \textbar{}           0 \textbar{}          0 \textbar{}        0 \textbar{}        0 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17000 \textbar{}     4 \textbar{}           0 \textbar{}          0 \textbar{}        0 \textbar{}        0 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17000 \textbar{}     5 \textbar{}           1 \textbar{}   0.000647 \textbar{} 0.000647 \textbar{} 0.000647 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17000 \textbar{}     6 \textbar{}           1 \textbar{}    2.6e\PYGZhy{}05 \textbar{}  2.6e\PYGZhy{}05 \textbar{}  2.6e\PYGZhy{}05 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17000 \textbar{}     7 \textbar{}           0 \textbar{}          0 \textbar{}        0 \textbar{}        0 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17000 \textbar{}     8 \textbar{}           0 \textbar{}          0 \textbar{}        0 \textbar{}        0 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17000 \textbar{}     9 \textbar{}           0 \textbar{}          0 \textbar{}        0 \textbar{}        0 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17000 \textbar{}    10 \textbar{}           0 \textbar{}          0 \textbar{}        0 \textbar{}        0 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17000 \textbar{}    11 \textbar{}           0 \textbar{}          0 \textbar{}        0 \textbar{}        0 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17004 \textbar{}     1 \textbar{}           0 \textbar{}          0 \textbar{}        0 \textbar{}        0 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17004 \textbar{}     2 \textbar{}           0 \textbar{}          0 \textbar{}        0 \textbar{}        0 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17004 \textbar{}     3 \textbar{}           0 \textbar{}          0 \textbar{}        0 \textbar{}        0 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17004 \textbar{}     4 \textbar{}           0 \textbar{}          0 \textbar{}        0 \textbar{}        0 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17004 \textbar{}     5 \textbar{}           1 \textbar{}    8.4e\PYGZhy{}05 \textbar{}  8.4e\PYGZhy{}05 \textbar{}  8.4e\PYGZhy{}05 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17004 \textbar{}     6 \textbar{}           0 \textbar{}          0 \textbar{}        0 \textbar{}        0 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17004 \textbar{}     7 \textbar{}           0 \textbar{}          0 \textbar{}        0 \textbar{}        0 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17004 \textbar{}     8 \textbar{}           0 \textbar{}          0 \textbar{}        0 \textbar{}        0 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17004 \textbar{}     9 \textbar{}           0 \textbar{}          0 \textbar{}        0 \textbar{}        0 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17004 \textbar{}    10 \textbar{}           1 \textbar{}   0.000355 \textbar{} 0.000355 \textbar{} 0.000355 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17004 \textbar{}    11 \textbar{}           1 \textbar{}   0.000177 \textbar{} 0.000177 \textbar{} 0.000177 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17004 \textbar{}    12 \textbar{}           1 \textbar{}    5.5e\PYGZhy{}05 \textbar{}  5.5e\PYGZhy{}05 \textbar{}  5.5e\PYGZhy{}05 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17004 \textbar{}    13 \textbar{}           1 \textbar{}    3.1e\PYGZhy{}05 \textbar{}  3.1e\PYGZhy{}05 \textbar{}  3.1e\PYGZhy{}05 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17004 \textbar{}    14 \textbar{}           1 \textbar{}    2.8e\PYGZhy{}05 \textbar{}  2.8e\PYGZhy{}05 \textbar{}  2.8e\PYGZhy{}05 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17004 \textbar{}    15 \textbar{}           1 \textbar{}    2.7e\PYGZhy{}05 \textbar{}  2.7e\PYGZhy{}05 \textbar{}  2.7e\PYGZhy{}05 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17004 \textbar{}    16 \textbar{}           1 \textbar{}      1e\PYGZhy{}06 \textbar{}    1e\PYGZhy{}06 \textbar{}    1e\PYGZhy{}06 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17004 \textbar{}    17 \textbar{}           0 \textbar{}          0 \textbar{}        0 \textbar{}        0 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17004 \textbar{}    18 \textbar{}           0 \textbar{}          0 \textbar{}        0 \textbar{}        0 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17004 \textbar{}    19 \textbar{}           0 \textbar{}          0 \textbar{}        0 \textbar{}        0 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17004 \textbar{}    20 \textbar{}           0 \textbar{}          0 \textbar{}        0 \textbar{}        0 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17004 \textbar{}    21 \textbar{}           0 \textbar{}          0 \textbar{}        0 \textbar{}        0 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17004 \textbar{}    22 \textbar{}           0 \textbar{}          0 \textbar{}        0 \textbar{}        0 \textbar{}        \textbar{}        \textbar{}        \textbar{}
     2 \textbar{}       17004 \textbar{}    23 \textbar{}           0 \textbar{}          0 \textbar{}        0 \textbar{}        0 \textbar{}        \textbar{}        \textbar{}        \textbar{}
(68 rows)
\end{sphinxVerbatim}

\newpage


\subsubsection{\index{DBMS\_PROFILER - Reference}DBMS\_PROFILER - Reference}
\label{\detokenize{dbms_profiler:dbms-profiler-reference}}
The Advanced Server installer creates the following tables and views
that you can query to review PL/SQL performance profile information:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|\Y{0.3}|\Y{0.7}|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Table Name
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Description
\unskip}\relax \\
\hline
\sphinxcode{PLSQL\_PROFILER\_RUNS}
&
Table containing information about all profiler runs, organized by \sphinxcode{runid}.
\\
\hline
\sphinxcode{PLSQL\_PROFILER\_UNITS}
&
Table containing information about all profiler runs, organized by unit.
\\
\hline
\sphinxcode{PLSQL\_PROFILER\_DATA}
&
View containing performance statistics.
\\
\hline
\sphinxcode{PLSQL\_PROFILER\_RAWDATA}
&
Table containing the performance statistics \sphinxcode{and} the extended performance statistics for DRITA counters and timers.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\paragraph{\index{PLSQL\_PROFILER\_RUNS}PLSQL\_PROFILER\_RUNS}
\label{\detokenize{dbms_profiler:plsql-profiler-runs}}
The \sphinxcode{PLSQL\_PROFILER\_RUNS} table contains the following columns:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|\Y{0.3}|\Y{0.3}|\Y{0.4}|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Column
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Data Type
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Description
\unskip}\relax \\
\hline
\sphinxcode{runid}
&
\sphinxcode{INTEGER (NOT NULL)}
&
Unique identifier (\sphinxcode{plsql\_profiler\_runnumber})
\\
\hline
\sphinxcode{related\_run}
&
\sphinxcode{INTEGER}
&
The \sphinxcode{runid} of a related run.
\\
\hline
\sphinxcode{run\_owner}
&
\sphinxcode{TEXT}
&
The role that recorded the profiling session.
\\
\hline
\sphinxcode{run\_date}
&
\sphinxcode{TIMESTAMP WITHOUT TIME ZONE}
&
The profiling session start time.
\\
\hline
\sphinxcode{run\_comment}
&
\sphinxcode{TEXT}
&
User comments relevant to this run
\\
\hline
\sphinxcode{run\_total\_time}
&
\sphinxcode{BIGINT}
&
Run time (in microseconds)
\\
\hline
\sphinxcode{run\_system\_info}
&
\sphinxcode{TEXT}
&
Currently Unused
\\
\hline
\sphinxcode{run\_comment1}
&
\sphinxcode{TEXT}
&
Additional user comments
\\
\hline
\sphinxcode{spare1}
&
\sphinxcode{TEXT}
&
Currently Unused
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\paragraph{\index{PLSQL\_PROFILER\_UNITS}PLSQL\_PROFILER\_UNITS}
\label{\detokenize{dbms_profiler:plsql-profiler-units}}
The \sphinxcode{PLSQL\_PROFILER\_UNITS} table contains the following columns:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|\Y{0.3}|\Y{0.3}|\Y{0.4}|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Column
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Data Type
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Description
\unskip}\relax \\
\hline
\sphinxcode{runid}
&
\sphinxcode{INTEGER}
&
Unique identifier (\sphinxcode{plsql\_profiler\_runnumber})
\\
\hline
\sphinxcode{unit\_number}
&
\sphinxcode{OID}
&
Corresponds to the OID of the row in the pg\_proc table that identifies the unit.
\\
\hline
\sphinxcode{unit\_type}
&
\sphinxcode{TEXT}
&
PL/SQL function, procedure, trigger or anonymous block
\\
\hline
\sphinxcode{unit\_owner}
&
\sphinxcode{TEXT}
&
The identity of the role that owns the unit.
\\
\hline
\sphinxcode{unit\_name}
&
\sphinxcode{TEXT}
&
The complete signature of the unit.
\\
\hline
\sphinxcode{unit\_timestamp}
&
\sphinxcode{TIMESTAMP WITHOUT TIME ZONE}
&
Creation date of the unit (currently NULL).
\\
\hline
\sphinxcode{total\_time}
&
\sphinxcode{BIGINT}
&
Time spent within the unit (in milliseconds)
\\
\hline
\sphinxcode{spare1}
&
\sphinxcode{BIGINT}
&
Currently Unused
\\
\hline
\sphinxcode{spare2}
&
\sphinxcode{BIGINT}
&
Currently Unused
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\paragraph{\index{PLSQL\_PROFILER\_DATA}PLSQL\_PROFILER\_DATA}
\label{\detokenize{dbms_profiler:plsql-profiler-data}}
The \sphinxcode{PLSQL\_PROFILER\_DATA} view contains the following columns:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|\Y{0.3}|\Y{0.3}|\Y{0.4}|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Column
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Data Type
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Description
\unskip}\relax \\
\hline
\sphinxcode{runid}
&
\sphinxcode{INTEGER}
&
Unique identifier (\sphinxcode{plsql\_profiler\_runnumber})
\\
\hline
\sphinxcode{unit\_number}
&
\sphinxcode{OID}
&
Object ID of the unit that contains the current line.
\\
\hline
\sphinxcode{line\#}
&
\sphinxcode{INTEGER}
&
Current line number of the profiled workload.
\\
\hline
\sphinxcode{total\_occur}
&
\sphinxcode{BIGINT}
&
The number of times that the line was executed.
\\
\hline
\sphinxcode{total\_time}
&
\sphinxcode{DOUBLE PRECISION}
&
The amount of time spent executing the line (in seconds)
\\
\hline
\sphinxcode{min\_time}
&
\sphinxcode{DOUBLE PRECISION}
&
The minimum execution time for the line.
\\
\hline
\sphinxcode{max\_time}
&
\sphinxcode{DOUBLE PRECISION}
&
The maximum execution time for the line.
\\
\hline
\sphinxcode{spare1}
&
\sphinxcode{NUMBER}
&
Currently Unused
\\
\hline
\sphinxcode{spare2}
&
\sphinxcode{NUMBER}
&
Currently Unused
\\
\hline
\sphinxcode{spare3}
&
\sphinxcode{NUMBER}
&
Currently Unused
\\
\hline
\sphinxcode{spare4}
&
\sphinxcode{NUMBER}
&
Currently Unused
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\paragraph{\index{PLSQL\_PROFILER\_RAWDATA}PLSQL\_PROFILER\_RAWDATA}
\label{\detokenize{dbms_profiler:plsql-profiler-rawdata}}
The \sphinxcode{PLSQL\_PROFILER\_RAWDATA} table contains the statistical and wait
events information that is found in the \sphinxcode{PLSQL\_PROFILER\_DATA} view, as
well as the performance statistics returned by the DRITA counters and
timers.


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}{|\Y{0.3}|\Y{0.3}|\Y{0.4}|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Column
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Data Type
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Description
\unskip}\relax \\
\hline
\endfirsthead

\multicolumn{3}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Column
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Data Type
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Description
\unskip}\relax \\
\hline
\endhead

\hline
\multicolumn{3}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot

\sphinxcode{runid}
&
\sphinxcode{INTEGER}
&
The run identifier (plsql\_profiler\_runnumber).
\\
\hline
\sphinxcode{sourcecode}
&
\sphinxcode{TEXT}
&
The individual line of profiled code.
\\
\hline
\sphinxcode{func\_oid}
&
\sphinxcode{OID}
&
Object ID of the unit that contains the current line.
\\
\hline
\sphinxcode{line\_number}
&
\sphinxcode{INTEGER}
&
Current line number of the profiled workload.
\\
\hline
\sphinxcode{exec\_count}
&
\sphinxcode{BIGINT}
&
The number of times that the line was executed.
\\
\hline
\sphinxcode{tuples\_returned}
&
\sphinxcode{BIGINT}
&
Currently Unused
\\
\hline
\sphinxcode{time\_total}
&
\sphinxcode{DOUBLE PRECISION}
&
The amount of time spent executing the line (in seconds)
\\
\hline
\sphinxcode{time\_shortest}
&
\sphinxcode{DOUBLE PRECISION}
&
The minimum execution time for the line.
\\
\hline
\sphinxcode{time\_longest}
&
\sphinxcode{DOUBLE PRECISION}
&
The maximum execution time for the line.
\\
\hline
\sphinxcode{num\_scans}
&
\sphinxcode{BIGINT}
&
Currently Unused
\\
\hline
\sphinxcode{tuples\_fetched}
&
\sphinxcode{BIGINT}
&
Currently Unused
\\
\hline
\sphinxcode{tuples\_inserted}
&
\sphinxcode{BIGINT}
&
Currently Unused
\\
\hline
\sphinxcode{tuples\_updated}
&
\sphinxcode{BIGINT}
&
Currently Unused
\\
\hline
\sphinxcode{tuples\_deleted}
&
\sphinxcode{BIGINT}
&
Currently Unused
\\
\hline
\sphinxcode{blocks\_fetched}
&
\sphinxcode{BIGINT}
&
Currently Unused
\\
\hline
\sphinxcode{blocks\_hit}
&
\sphinxcode{BIGINT}
&
Currently Unused
\\
\hline
\sphinxcode{wal\_write}
&
\sphinxcode{BIGINT}
&
A server has waited for a write to the write-ahead log buffer (expect this value to be high).
\\
\hline
\sphinxcode{wal\_flush}
&
\sphinxcode{BIGINT}
&
A server has waited for the write-ahead log to flush to disk.
\\
\hline
\sphinxcode{wal\_file\_sync}
&
\sphinxcode{BIGINT}
&
A server has waited for the write-ahead log to sync to disk (related to the wal\_sync\_method parameter which, by default, is ‘fsync’ - better performance can be gained by changing this parameter to open\_sync).
\\
\hline
\sphinxcode{db\_file\_read}
&
\sphinxcode{BIGINT}
&
A server has waited for the completion of a read (from disk).
\\
\hline
\sphinxcode{db\_file\_write}
&
\sphinxcode{BIGINT}
&
A server has waited for the completion of a write (to disk).
\\
\hline
\sphinxcode{db\_file\_sync}
&
\sphinxcode{BIGINT}
&
A server has waited for the operating system to flush all changes to disk.
\\
\hline
\sphinxcode{db\_file\_extend}
&
\sphinxcode{BIGINT}
&
A server has waited for the operating system while adding a new page to the end of a file.
\\
\hline
\sphinxcode{sql\_parse}
&
\sphinxcode{BIGINT}
&
Currently Unused.
\\
\hline
\sphinxcode{query\_plan}
&
\sphinxcode{BIGINT}
&
A server has generated a query plan.
\\
\hline
\sphinxcode{other\_lwlock\_acquire}
&
\sphinxcode{BIGINT}
&
A server has waited for other light-weight lock to protect data.
\\
\hline
\sphinxcode{shared\_plan\_cache\_collision}
&
\sphinxcode{BIGINT}
&
A server has waited for the completion of the \sphinxcode{shared\_plan\_cache\_collision} event.
\\
\hline
\sphinxcode{shared\_plan\_cache\_insert}
&
\sphinxcode{BIGINT}
&
A server has waited for the completion of the \sphinxcode{shared\_plan\_cache\_insert} event.
\\
\hline
\sphinxcode{shared\_plan\_cache\_hit}
&
\sphinxcode{BIGINT}
&
A server has waited for the completion of the \sphinxcode{shared\_plan\_cache\_hit} event.
\\
\hline
\sphinxcode{shared\_plan\_cache\_miss}
&
\sphinxcode{BIGINT}
&
A server has waited for the completion of the \sphinxcode{shared\_plan\_cache\_miss} event.
\\
\hline
\sphinxcode{shared\_plan\_cache\_lock}
&
\sphinxcode{BIGINT}
&
A server has waited for the completion of the \sphinxcode{shared\_plan\_cache\_lock} event.
\\
\hline
\sphinxcode{shared\_plan\_cache\_busy}
&
\sphinxcode{BIGINT}
&
A server has waited for the completion of the \sphinxcode{shared\_plan\_cache\_busy} event.
\\
\hline
\sphinxcode{shmemindexlock}
&
\sphinxcode{BIGINT}
&
A server has waited to find or allocate space in the shared memory.
\\
\hline
\sphinxcode{oidgenlock}
&
\sphinxcode{BIGINT}
&
A server has waited to allocate or assign an OID.
\\
\hline
\sphinxcode{xidgenlock}
&
\sphinxcode{BIGINT}
&
A server has waited to allocate or assign a transaction ID.
\\
\hline
\sphinxcode{procarraylock}
&
\sphinxcode{BIGINT}
&
A server has waited to get a snapshot or clearing a transaction ID at transaction end.
\\
\hline
\sphinxcode{sinvalreadlock}
&
\sphinxcode{BIGINT}
&
A server has waited to retrieve or remove messages from shared invalidation queue.
\\
\hline
\sphinxcode{sinvalwritelock}
&
\sphinxcode{BIGINT}
&
A server has waited to add a message to the shared invalidation queue.
\\
\hline
\sphinxcode{walbufmappinglock}
&
\sphinxcode{BIGINT}
&
A server has waited to replace a page in WAL buffers.
\\
\hline
\sphinxcode{walwritelock}
&
\sphinxcode{BIGINT}
&
A server has waited for WAL buffers to be written to disk.
\\
\hline
\sphinxcode{controlfilelock}
&
\sphinxcode{BIGINT}
&
A server has waited to read or update the control file or creation of a new WAL file.
\\
\hline
\sphinxcode{checkpointlock}
&
\sphinxcode{BIGINT}
&
A server has waited to perform a checkpoint.
\\
\hline
\sphinxcode{clogcontrollock}
&
\sphinxcode{BIGINT}
&
A server has waited to read or update the transaction status.
\\
\hline
\sphinxcode{subtranscontrollock}
&
\sphinxcode{BIGINT}
&
A server has waited to read or update the sub-transaction information.
\\
\hline
\sphinxcode{multixactgenlock}
&
\sphinxcode{BIGINT}
&
A server has waited to read or update the shared multixact state.
\\
\hline
\sphinxcode{multixactoffsetcontrollock}
&
\sphinxcode{BIGINT}
&
A server has waited to read or update multixact offset mappings.
\\
\hline
\sphinxcode{multixactmembercontrollock}
&
\sphinxcode{BIGINT}
&
A server has waited to read or update multixact member mappings.
\\
\hline
\sphinxcode{relcacheinitlock}
&
\sphinxcode{BIGINT}
&
A server has waited to read or write the relation cache initialization file.
\\
\hline
\sphinxcode{checkpointercommlock}
&
\sphinxcode{BIGINT}
&
A server has waited to manage the fsync requests.
\\
\hline
\sphinxcode{twophasestatelock}
&
\sphinxcode{BIGINT}
&
A server has waited to read or update the state of prepared transactions.
\\
\hline
\sphinxcode{tablespacecreatelock}
&
\sphinxcode{BIGINT}
&
A server has waited to create or drop the tablespace.
\\
\hline
\sphinxcode{btreevacuumlock}
&
\sphinxcode{BIGINT}
&
A server has waited to read or update the vacuum related information for a B-tree index.
\\
\hline
\sphinxcode{addinshmeminitlock}
&
\sphinxcode{BIGINT}
&
A server has waited to manage space allocation in shared memory.
\\
\hline
\sphinxcode{autovacuumlock}
&
\sphinxcode{BIGINT}
&
The autovacuum launcher waiting to read or update the current state of autovacuum workers.
\\
\hline
\sphinxcode{autovacuumschedulelock}
&
\sphinxcode{BIGINT}
&
A server has waited to ensure that the table selected for a vacuum still needs vacuuming.
\\
\hline
\sphinxcode{syncscanlock}
&
\sphinxcode{BIGINT}
&
A server has waited to get the start location of a scan on a table for synchronized scans.
\\
\hline
\sphinxcode{relationmappinglock}
&
\sphinxcode{BIGINT}
&
A server has waited to update the relation map file used to store catalog to file node mapping.
\\
\hline
\sphinxcode{asyncctllock}
&
\sphinxcode{BIGINT}
&
A server has waited to read or update shared notification state.
\\
\hline
\sphinxcode{asyncqueuelock}
&
\sphinxcode{BIGINT}
&
A server has waited to read or update the notification messages.
\\
\hline
\sphinxcode{serializablexacthashlock}
&
\sphinxcode{BIGINT}
&
A server has waited to retrieve or store information about serializable transactions.
\\
\hline
\sphinxcode{serializablefinishedlistlock}
&
\sphinxcode{BIGINT}
&
A server has waited to access the list of finished serializable transactions.
\\
\hline
\sphinxcode{serializablepredicatelocklistlock}
&
\sphinxcode{BIGINT}
&
A server has waited to perform an operation on a list of locks held by serializable transactions.
\\
\hline
\sphinxcode{oldserxidlock}
&
\sphinxcode{BIGINT}
&
A server has waited to read or record the conflicting serializable transactions.
\\
\hline
\sphinxcode{syncreplock}
&
\sphinxcode{BIGINT}
&
A server has waited to read or update information about synchronous replicas.
\\
\hline
\sphinxcode{backgroundworkerlock}
&
\sphinxcode{BIGINT}
&
A server has waited to read or update the background worker state.
\\
\hline
\sphinxcode{dynamicsharedmemorycontrollock}
&
\sphinxcode{BIGINT}
&
A server has waited to read or update the dynamic shared memory state.
\\
\hline
\sphinxcode{autofilelock}
&
\sphinxcode{BIGINT}
&
A server has waited to update the \sphinxcode{postgresql.auto.conf} file.
\\
\hline
\sphinxcode{replicationslotallocationlock}
&
\sphinxcode{BIGINT}
&
A server has waited to allocate or free a replication slot.
\\
\hline
\sphinxcode{replicationslotcontrollock}
&
\sphinxcode{BIGINT}
&
A server has waited to read or update replication slot state.
\\
\hline
\sphinxcode{committscontrollock}
&
\sphinxcode{BIGINT}
&
A server has waited to read or update transaction commit timestamps.
\\
\hline
\sphinxcode{committslock}
&
\sphinxcode{BIGINT}
&
A server has waited to read or update the last value set for the transaction timestamp.
\\
\hline
\sphinxcode{replicationoriginlock}
&
\sphinxcode{BIGINT}
&
A server has waited to set up, drop, or use replication origin.
\\
\hline
\sphinxcode{multixacttruncationlock}
&
\sphinxcode{BIGINT}
&
A server has waited to read or truncate multixact information.
\\
\hline
\sphinxcode{oldsnapshottimemaplock}
&
\sphinxcode{BIGINT}
&
A server has waited to read or update old snapshot control information.
\\
\hline
\sphinxcode{backendrandomlock}
&
\sphinxcode{BIGINT}
&
A server has waited to generate a random number.
\\
\hline
\sphinxcode{logicalrepworkerlock}
&
\sphinxcode{BIGINT}
&
A server has waited for the action on logical replication worker to finish.
\\
\hline
\sphinxcode{clogtruncationlock}
&
\sphinxcode{BIGINT}
&
A server has waited to truncate the write-ahead log or waiting for write-ahead log truncation to finish.
\\
\hline
\sphinxcode{bulkloadlock}
&
\sphinxcode{BIGINT}
&
A server has waited for the \sphinxcode{bulkloadlock} to bulk upload the data.
\\
\hline
\sphinxcode{edbresourcemanagerlock}
&
\sphinxcode{BIGINT}
&
The \sphinxcode{edbresourcemanagerlock} provides detail about edb resource manager lock module.
\\
\hline
\sphinxcode{wal\_write\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for a \sphinxcode{wal\_write} wait event to write to the write-ahead log buffer (expect this value to be high).
\\
\hline
\sphinxcode{wal\_flush\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for a \sphinxcode{wal\_flush} wait event to write-ahead log to flush to disk.
\\
\hline
\sphinxcode{wal\_file\_sync\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for a \sphinxcode{wal\_file\_sync} wait event to write-ahead log to sync to disk (related to the wal\_sync\_method parameter which, by default, is ‘fsync’ - better performance can be gained by changing this parameter to open\_sync).
\\
\hline
\sphinxcode{db\_file\_read\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{db\_file\_read} wait event for completion of a read (from disk).
\\
\hline
\sphinxcode{db\_file\_write\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{db\_file\_write} wait event for completion of a write (to disk).
\\
\hline
\sphinxcode{db\_file\_sync\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{db\_file\_sync} wait event to sync all changes to disk.
\\
\hline
\sphinxcode{db\_file\_extend\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{db\_file\_extend} wait event while adding a new page to the end of a file.
\\
\hline
\sphinxcode{sql\_parse\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{sql\_parse} wait event to parse a SQL statement.
\\
\hline
\sphinxcode{query\_plan\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{query\_plan} wait event to compute the execution plan for a SQL statement.
\\
\hline
\sphinxcode{other\_lwlock\_acquire\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{other\_lwlock\_acquire} wait event to protect data.
\\
\hline
\sphinxcode{shared\_plan\_cache\_collision\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{shared\_plan\_cache\_collision} wait event.
\\
\hline
\sphinxcode{shared\_plan\_cache\_insert\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{shared\_plan\_cache\_insert} wait event.
\\
\hline
\sphinxcode{shared\_plan\_cache\_hit\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{shared\_plan\_cache\_hit} wait event.
\\
\hline
\sphinxcode{shared\_plan\_cache\_miss\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{shared\_plan\_cache\_miss} wait event.
\\
\hline
\sphinxcode{shared\_plan\_cache\_lock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{shared\_plan\_cache\_lock} wait event.
\\
\hline
\sphinxcode{shared\_plan\_cache\_busy\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{shared\_plan\_cache\_busy} wait event.
\\
\hline
\sphinxcode{shmemindexlock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{shmemindexlock} wait event to find or allocate space in the shared memory.
\\
\hline
\sphinxcode{oidgenlock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{oidgenlock} wait event to allocate or assign an OID.
\\
\hline
\sphinxcode{xidgenlock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for \sphinxcode{xidgenlock} wait event to allocate or assign a transaction ID.
\\
\hline
\sphinxcode{procarraylock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for a \sphinxcode{procarraylock} wait event to clear a transaction ID at transaction end.
\\
\hline
\sphinxcode{sinvalreadlock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for a \sphinxcode{sinvalreadlock} wait event to retrieve or remove messages from shared invalidation queue.
\\
\hline
\sphinxcode{sinvalwritelock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for a \sphinxcode{sinvalwritelock} wait event to add a message to the shared invalidation queue.
\\
\hline
\sphinxcode{walbufmappinglock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for a \sphinxcode{walbufmappinglock} wait event to replace a page in WAL buffers.
\\
\hline
\sphinxcode{walwritelock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for a \sphinxcode{walwritelock} wait event to write the WAL buffers to disk.
\\
\hline
\sphinxcode{controlfilelock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for a \sphinxcode{controlfilelock} wait event to read or update the control file or to create a new WAL file.
\\
\hline
\sphinxcode{checkpointlock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for a \sphinxcode{checkpointlock} wait event to perform a checkpoint.
\\
\hline
\sphinxcode{clogcontrollock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for a \sphinxcode{clogcontrollock} wait event to read or update the transaction status.
\\
\hline
\sphinxcode{subtranscontrollock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{subtranscontrollock} wait event to read or update the sub-transaction information.
\\
\hline
\sphinxcode{multixactgenlock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{multixactgenlock} wait event to read or update the shared multixact state.
\\
\hline
\sphinxcode{multixactoffsetcontrollock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{multixactoffsetcontrollock} wait event to read or update multixact offset mappings.
\\
\hline
\sphinxcode{multixactmembercontrollock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{multixactmembercontrollock} wait event to read or update multixact member mappings.
\\
\hline
\sphinxcode{relcacheinitlock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{relcacheinitlock} wait event to read or write the relation cache initialization file.
\\
\hline
\sphinxcode{checkpointercommlock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{checkpointercommlock} wait event to manage the fsync requests.
\\
\hline
\sphinxcode{twophasestatelock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{twophasestatelock} wait event to read or update the state of prepared transactions.
\\
\hline
\sphinxcode{tablespacecreatelock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{tablespacecreatelock} wait event to create or drop the tablespace.
\\
\hline
\sphinxcode{btreevacuumlock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{btreevacuumlock} wait event to read or update the vacuum related information for a B-tree index.
\\
\hline
\sphinxcode{addinshmeminitlock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{addinshmeminitlock} wait event to manage space allocation in shared memory.
\\
\hline
\sphinxcode{autovacuumlock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{autovacuumlock} wait event to read or update the current state of autovacuum workers.
\\
\hline
\sphinxcode{autovacuumschedulelock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{autovacuumschedulelock} wait event to ensure that the table selected for a vacuum still needs vacuuming.
\\
\hline
\sphinxcode{syncscanlock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{syncscanlock} wait event to get the start location of a scan on a table for synchronized scans.
\\
\hline
\sphinxcode{relationmappinglock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{relationmappinglock} wait event to update the relation map file used to store catalog to file node mapping.
\\
\hline
\sphinxcode{asyncctllock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{asyncctllock} wait event to read or update shared notification state.
\\
\hline
\sphinxcode{asyncqueuelock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{asyncqueuelock} wait event to read or update the notification messages.
\\
\hline
\sphinxcode{serializablexacthashlock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{serializablexacthashlock} wait event to retrieve or store information about serializable transactions.
\\
\hline
\sphinxcode{serializablefinishedlistlock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{serializablefinishedlistlock} wait event to access the list of finished serializable transactions.
\\
\hline
\sphinxcode{serializablepredicatelocklistlock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{serializablepredicatelocklistlock} wait event to perform an operation on a list of locks held by serializable transactions.
\\
\hline
\sphinxcode{oldserxidlock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{oldserxidlock} wait event to read or record the conflicting serializable transactions.
\\
\hline
\sphinxcode{syncreplock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{syncreplock} wait event to read or update information about synchronous replicas.
\\
\hline
\sphinxcode{backgroundworkerlock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{backgroundworkerlock} wait event to read or update the background worker state.
\\
\hline
\sphinxcode{dynamicsharedmemorycontrollock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{dynamicsharedmemorycontrollock} wait event to read or update the dynamic shared memory state.
\\
\hline
\sphinxcode{autofilelock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{autofilelock} wait event to update the \sphinxcode{postgresql.auto.conf} file.
\\
\hline
\sphinxcode{replicationslotallocationlock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{replicationslotallocationlock} wait event to allocate or free a replication slot.
\\
\hline
\sphinxcode{replicationslotcontrollock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{replicationslotcontrollock} wait event to read or update replication slot state.
\\
\hline
\sphinxcode{committscontrollock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{committscontrollock} wait event to read or update transaction commit timestamps.
\\
\hline
\sphinxcode{committslock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{committslock} wait event to read or update the last value set for the transaction timestamp.
\\
\hline
\sphinxcode{replicationoriginlock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{replicationoriginlock} wait event to set up, drop, or use replication origin.
\\
\hline
\sphinxcode{multixacttruncationlock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{multixacttruncationlock} wait event to read or truncate multixact information.
\\
\hline
\sphinxcode{oldsnapshottimemaplock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{oldsnapshottimemaplock} wait event to read or update old snapshot control information.
\\
\hline
\sphinxcode{backendrandomlock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{backendrandomlock} wait event to generate a random number.
\\
\hline
\sphinxcode{logicalrepworkerlock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{logicalrepworkerlock} wait event for an action on logical replication worker to finish.
\\
\hline
\sphinxcode{clogtruncationlock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{clogtruncationlock} wait event to truncate the write-ahead log or waiting for write-ahead log truncation to finish.
\\
\hline
\sphinxcode{bulkloadlock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{bulkloadlock} wait event to bulk upload the data.
\\
\hline
\sphinxcode{edbresourcemanagerlock\_time}
&
\sphinxcode{BIGINT}
&
The amount of time that the server has waited for the \sphinxcode{edbresourcemanagerlock} wait event.
\\
\hline
\sphinxcode{totalwaits}
&
\sphinxcode{BIGINT}
&
The total number of event waits.
\\
\hline
\sphinxcode{totalwaittime}
&
\sphinxcode{BIGINT}
&
The total time spent waiting for an event.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}

\newpage


\section{\index{DBMS\_RANDOM}DBMS\_RANDOM}
\label{\detokenize{dbms_random::doc}}\label{\detokenize{dbms_random:dbms-random}}
The \sphinxcode{DBMS\_RANDOM} package provides a number of methods to generate random
values. The procedures and functions available in the \sphinxcode{DBMS\_RANDOM}
package are listed in the following table.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|\Y{0.3}|\Y{0.2}|\Y{0.5}|}
\hline

Function/Procedure
&
Return Type
&
Description
\\
\hline
\sphinxcode{INITIALIZE(\textless{}val\textgreater{})}
&
n/a
&
Initializes the \sphinxcode{DBMS\_RANDOM} package with the specified seed \sphinxcode{\textless{}value\textgreater{}}. Deprecated, but supported for backward compatibility.
\\
\hline
\sphinxcode{NORMAL()}
&
\sphinxcode{NUMBER}
&
Returns a random \sphinxcode{NUMBER}.
\\
\hline
\sphinxcode{RANDOM}
&
\sphinxcode{INTEGER}
&
Returns a random \sphinxcode{INTEGER} with a value greater than or equal to -2\textasciicircum{}31 and less than 2\textasciicircum{}31. Deprecated, but supported for backward compatibility
\\
\hline
\sphinxcode{SEED(\textless{}val\textgreater{})}
&
n/a
&
Resets the seed with the specified \sphinxcode{\textless{}value\textgreater{}}.
\\
\hline
\sphinxcode{SEED(\textless{}val\textgreater{})}
&
n/a
&
Resets the seed with the specified \sphinxcode{\textless{}value\textgreater{}}.
\\
\hline
\sphinxcode{STRING(\textless{}opt\textgreater{}, \textless{}len\textgreater{})}
&
\sphinxcode{VARCHAR2}
&
Returns a random string.
\\
\hline
\sphinxcode{TERMINATE}
&
n/a
&
\sphinxcode{TERMINATE} has no effect. Deprecated, but supported for backward compatibility.
\\
\hline
\sphinxcode{VALUE}
&
\sphinxcode{NUMBER}
&
Returns a random number with a value greater than or equal to \sphinxcode{0} and less than \sphinxcode{1}, with 38 digit precision.
\\
\hline
\sphinxcode{VALUE(\textless{}low\textgreater{}, \textless{}high\textgreater{})}
&
\sphinxcode{NUMBER}
&
Returns a random number with a value greater than or equal to \sphinxcode{\textless{}low\textgreater{}} and less than \sphinxcode{\textless{}high\textgreater{}}.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{\index{INITIALIZE}INITIALIZE}
\label{\detokenize{dbms_random:initialize}}
The \sphinxcode{INITIALIZE} procedure initializes the \sphinxcode{DBMS\_RANDOM} package with a
seed value. The signature is:
\begin{quote}

\sphinxcode{INITIALIZE(\textless{}val\textgreater{} IN INTEGER)}
\end{quote}

This procedure should be considered deprecated; it is included for
backward compatibility only.

\sphinxstylestrong{Parameter}

\sphinxcode{\textless{}val\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}val\textgreater{}} is the seed value used by the \sphinxcode{DBMS\_RANDOM} package algorithm.
\end{quote}

\sphinxstylestrong{Example}

The following code snippet demonstrates a call to the \sphinxcode{INITIALIZE}
procedure that initializes the \sphinxcode{DBMS\_RANDOM} package with the seed value,
\sphinxcode{6475}.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DBMS\PYGZus{}RANDOM.INITIALIZE(6475);
\end{sphinxVerbatim}


\subsection{\index{NORMAL}NORMAL}
\label{\detokenize{dbms_random:normal}}
The \sphinxcode{NORMAL} function returns a random number of type \sphinxcode{NUMBER}. The
signature is:
\begin{quote}

\sphinxcode{\textless{}result\textgreater{} NUMBER NORMAL()}
\end{quote}

\sphinxstylestrong{Parameter}

\sphinxcode{\textless{}result\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}result\textgreater{}} is a random value of type \sphinxcode{NUMBER}.
\end{quote}

\sphinxstylestrong{Example}

The following code snippet demonstrates a call to the \sphinxcode{NORMAL} function:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
x:= DBMS\PYGZus{}RANDOM.NORMAL();
\end{sphinxVerbatim}


\subsection{\index{RANDOM}RANDOM}
\label{\detokenize{dbms_random:random}}
The \sphinxcode{RANDOM} function returns a random \sphinxcode{INTEGER} value that is greater than
or equal to -2 \textasciicircum{}31 and less than 2 \textasciicircum{}31. The signature is:
\begin{quote}

\sphinxcode{\textless{}result\textgreater{} INTEGER RANDOM()}
\end{quote}

This function should be considered deprecated; it is included for
backward compatibility only.

\sphinxstylestrong{Parameter}

\sphinxcode{\textless{}result\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}result\textgreater{}} is a random value of type INTEGER.
\end{quote}

\sphinxstylestrong{Example}

The following code snippet demonstrates a call to the \sphinxcode{RANDOM} function.
The call returns a random number:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
x := DBMS\PYGZus{}RANDOM.RANDOM();
\end{sphinxVerbatim}


\subsection{\index{SEED}SEED}
\label{\detokenize{dbms_random:seed}}
The first form of the \sphinxcode{SEED} procedure resets the seed value for the
\sphinxcode{DBMS\_RANDOM} package with an \sphinxcode{INTEGER} value. The \sphinxcode{SEED} procedure is
available in two forms; the signature of the first form is:
\begin{quote}

\sphinxcode{SEED(\textless{}val\textgreater{} IN INTEGER)}
\end{quote}

\sphinxstylestrong{Parameter}

\sphinxcode{\textless{}val\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}val\textgreater{}} is the seed value used by the \sphinxcode{DBMS\_RANDOM} package algorithm.
\end{quote}

\sphinxstylestrong{Example}

The following code snippet demonstrates a call to the \sphinxcode{SEED} procedure;
the call sets the seed value at \sphinxcode{8495}.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DBMS\PYGZus{}RANDOM.SEED(8495);
\end{sphinxVerbatim}


\subsection{\index{SEED}SEED}
\label{\detokenize{dbms_random:id1}}
The second form of the \sphinxcode{SEED} procedure resets the seed value for the
\sphinxcode{DBMS\_RANDOM} package with a string value. The \sphinxcode{SEED} procedure is
available in two forms; the signature of the second form is:

\sphinxcode{SEED(\textless{}val\textgreater{} IN VARCHAR2)}

\sphinxstylestrong{Parameter}

\sphinxcode{\textless{}val\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}val\textgreater{}} is the seed value used by the \sphinxcode{DBMS\_RANDOM} package algorithm.
\end{quote}

\sphinxstylestrong{Example}

The following code snippet demonstrates a call to the \sphinxcode{SEED} procedure;
the call sets the seed value to \sphinxcode{abc123}.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DBMS\PYGZus{}RANDOM.SEED(\PYGZsq{}abc123\PYGZsq{});
\end{sphinxVerbatim}


\subsection{\index{STRING}STRING}
\label{\detokenize{dbms_random:string}}
The \sphinxcode{STRING} function returns a random \sphinxcode{VARCHAR2} string in a user-specified
format. The signature of the \sphinxcode{STRING} function is:
\begin{quote}

\sphinxcode{\textless{}result\textgreater{} VARCHAR2 STRING(\textless{}opt\textgreater{} IN CHAR, \textless{}len\textgreater{} IN NUMBER)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}opt\textgreater{}}
\begin{quote}

Formatting option for the returned string. \sphinxcode{\textless{}option\textgreater{}} may be:
\end{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|\Y{0.4}|\Y{0.6}|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
\sphinxstylestrong{Option}
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
\sphinxstylestrong{Specifies Formatting Option}
\unskip}\relax \\
\hline
\sphinxcode{u} or \sphinxcode{U}
&
Uppercase alpha string
\\
\hline
\sphinxcode{l} or \sphinxcode{L}
&
Lowercase alpha string
\\
\hline
\sphinxcode{a} or \sphinxcode{A}
&
Mixed case string
\\
\hline
\sphinxcode{x} or \sphinxcode{X}
&
Uppercase alpha-numeric string
\\
\hline
\sphinxcode{p} or \sphinxcode{P}
&
Any printable characters
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxcode{\textless{}len\textgreater{}}
\begin{quote}

The length of the returned string.
\end{quote}

\sphinxcode{\textless{}result\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}result\textgreater{}} is a random value of type \sphinxcode{VARCHAR2}.
\end{quote}

\sphinxstylestrong{Example}

The following code snippet demonstrates a call to the \sphinxcode{STRING} function;
the call returns a random alpha-numeric character string that is 10
characters long.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
x := DBMS\PYGZus{}RANDOM.STRING(\PYGZsq{}X\PYGZsq{}, 10);
\end{sphinxVerbatim}


\subsection{\index{TERMINATE}TERMINATE}
\label{\detokenize{dbms_random:terminate}}
The \sphinxcode{TERMINATE} procedure has no effect. The signature is:
\begin{quote}

\sphinxcode{TERMINATE}
\end{quote}

The \sphinxcode{TERMINATE} procedure should be considered deprecated; the procedure
is supported for compatibility only.

\index{DBMS\_RANDOM\_VALUE\_FIRST\_FORM}\ignorespaces 

\subsection{VALUE}
\label{\detokenize{dbms_random:index-8}}\label{\detokenize{dbms_random:value}}
The \sphinxcode{VALUE} function returns a random \sphinxcode{NUMBER} that is greater than or equal
to 0, and less than 1, with 38 digit precision. The \sphinxcode{VALUE} function has
two forms; the signature of the first form is:
\begin{quote}

\sphinxcode{\textless{}result\textgreater{} NUMBER VALUE()}
\end{quote}

\sphinxstylestrong{Parameter}

\sphinxcode{\textless{}result\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}result\textgreater{}} is a random value of type \sphinxcode{NUMBER}.
\end{quote}

\sphinxstylestrong{Example}

The following code snippet demonstrates a call to the \sphinxcode{VALUE} function.
The call returns a random \sphinxcode{NUMBER}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
x := DBMS\PYGZus{}RANDOM.VALUE();
\end{sphinxVerbatim}

\index{DBMS\_RANDOM\_VALUE\_SECOND\_FORM}\ignorespaces 

\subsection{VALUE}
\label{\detokenize{dbms_random:id2}}\label{\detokenize{dbms_random:index-9}}
The \sphinxcode{VALUE} function returns a random \sphinxcode{NUMBER} with a value that is between
user-specified boundaries. The \sphinxcode{VALUE} function has two forms; the
signature of the second form is:
\begin{quote}

\sphinxcode{\textless{}result\textgreater{} NUMBER VALUE(\textless{}low\textgreater{} IN NUMBER, \textless{}high\textgreater{} IN NUMBER)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}low\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}low\textgreater{}} specifies the lower boundary for the random value. The random
value may be equal to \sphinxcode{\textless{}low\textgreater{}}.
\end{quote}

\sphinxcode{\textless{}high\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}high\textgreater{}} specifies the upper boundary for the random value; the random
value will be less than \sphinxcode{\textless{}high\textgreater{}}.
\end{quote}

\sphinxcode{\textless{}result\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}result\textgreater{}} is a random value of type \sphinxcode{NUMBER}.
\end{quote}

\sphinxstylestrong{Example}

The following code snippet demonstrates a call to the \sphinxcode{VALUE} function.
The call returns a random \sphinxcode{NUMBER} with a value that is greater than or
equal to 1 and less than 100:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
x := DBMS\PYGZus{}RANDOM.VALUE(1, 100);
\end{sphinxVerbatim}

\newpage


\section{\index{DBMS\_REDACT}DBMS\_REDACT}
\label{\detokenize{dbms_redact::doc}}\label{\detokenize{dbms_redact:dbms-redact}}
The \sphinxcode{DBMS\_REDACT} package enables the redacting or masking of data
returned by a query. The \sphinxcode{DBMS\_REDACT} package provides a procedure to
create policies, alter policies, enable policies, disable policies, and
drop policies. The procedures available in the \sphinxcode{DBMS\_REDACT} package are
listed in the following table.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|\Y{0.6}|\Y{0.1}|\Y{0.1}|\Y{0.2}|}
\hline

Function/Procedure
&
Function or Procedure
&
Return Type
&
Description
\\
\hline
\sphinxcode{ADD\_POLICY(\textless{}object\_schema\textgreater{}, \textless{}object\_name\textgreater{}, \textless{}policy\_name\textgreater{}, \textless{}policy\_description\textgreater{}, \textless{}column\_name\textgreater{}, \textless{}column\_description\textgreater{}, \textless{}function\_type\textgreater{}, \textless{}function\_parameters\textgreater{}, \textless{}expression\textgreater{}, \textless{}enable\textgreater{}, \textless{}regexp\_pattern\textgreater{}, \textless{}regexp\_replace\_string\textgreater{}, \textless{}regexp\_position\textgreater{}, \textless{}regexp\_occurence\textgreater{}, \textless{}regexp\_match\_parameter\textgreater{}, \textless{}custom\_function\_expression\textgreater{})}
&
Procedure
&
n/a
&
Adds a data redaction policy.
\\
\hline
\sphinxcode{ALTER\_POLICY(\textless{}object\_schema\textgreater{}, \textless{}object\_name\textgreater{}, \textless{}policy\_name\textgreater{}, \textless{}action\textgreater{}, \textless{}column\_name\textgreater{}, \textless{}function\_type\textgreater{}, \textless{}function\_parameters\textgreater{}, \textless{}expression\textgreater{}, \textless{}regexp\_pattern\textgreater{}, \textless{}regexp\_replace\_string\textgreater{}, \textless{}regexp\_position\textgreater{}, \textless{}regexp\_occurence\textgreater{}, \textless{}regexp\_match\_parameter\textgreater{}, \textless{}policy\_description\textgreater{}, \textless{}column\_description\textgreater{}, \textless{}custom\_function\_expression\textgreater{})}
&
Procedure
&
n/a
&
Alters the existing data redaction policy.
\\
\hline
\sphinxcode{DISABLE\_POLICY(\textless{}object\_schema\textgreater{}, \textless{}object\_name\textgreater{}, \textless{}policy\_name\textgreater{})}
&
Procedure
&
n/a
&
Disables the existing data redaction policy.
\\
\hline
\sphinxcode{ENABLE\_POLICY(\textless{}object\_schema,\textgreater{} \textless{}object\_name\textgreater{}, \textless{}policy\_name\textgreater{})}
&
Procedure
&
n/a
&
Enables a previously disabled data redaction policy.
\\
\hline
\sphinxcode{DROP\_POLICY(\textless{}object\_schema\textgreater{}, \textless{}object\_name\textgreater{}, \textless{}policy\_name\textgreater{})}
&
Procedure
&
n/a
&
Drops a data redaction policy.
\\
\hline
\sphinxcode{UPDATE\_FULL\_REDACTION\_VALUES(\textless{}number\_val\textgreater{}, \textless{}binfloat\_val\textgreater{}, \textless{}bindouble\_val\textgreater{}, \textless{}char\_val\textgreater{}, \textless{}varchar\_val\textgreater{}, \textless{}nchar\_val\textgreater{}, \textless{}nvarchar\_val\textgreater{}, \textless{}datecol\_val\textgreater{}, \textless{}ts\_val\textgreater{}, \textless{}tswtz\_val\textgreater{}, \textless{}blob\_val\textgreater{}, \textless{}clob\_val\textgreater{}, \textless{}nclob\_val\textgreater{})}
&
Procedure
&
n/a
&
Updates the full redaction default values for the specified datatype.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

The data redaction feature uses the \sphinxcode{DBMS\_REDACT} package to define
policies or conditions to redact data in a column based on the table
column type and redaction type.

Note that you must be the owner of the table to create or change the
data redaction policies. The users are exempted from all the column
redaction policies, which the table owner or super-user is by default.

\newpage


\subsection{\index{Using DBMS\_REDACT Constants and Function Parameters}Using DBMS\_REDACT Constants and Function Parameters}
\label{\detokenize{dbms_redact:using-dbms-redact-constants-and-function-parameters}}
The \sphinxcode{DBMS\_REDACT} package uses the constants and redacts the column data
by using any one of the data redaction types. The redaction type can be
decided based on the function\_type parameter of
\sphinxcode{dbms\_redact.add\_policy} and \sphinxcode{dbms\_redact.alter\_policy} procedure. The
below table highlights the values for function\_type parameters of
\sphinxcode{dbms\_redact.add\_policy} and \sphinxcode{dbms\_redact.alter\_policy}.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|\Y{0.2}|\Y{0.2}|\Y{0.1}|\Y{0.5}|}
\hline

\sphinxstylestrong{Constant}
&
\sphinxstylestrong{Type}
&
\sphinxstylestrong{Value}
&
\sphinxstylestrong{Description}
\\
\hline
\sphinxcode{NONE}
&
\sphinxcode{INTEGER}
&
\sphinxcode{0}
&
No redaction, zero effect on the result of a query against table.
\\
\hline
\sphinxcode{FULL}
&
\sphinxcode{INTEGER}
&
\sphinxcode{1}
&
Full redaction, redacts full values of the column data.
\\
\hline
\sphinxcode{PARTIAL}
&
\sphinxcode{INTEGER}
&
\sphinxcode{2}
&
Partial redaction, redacts a portion of the column data.
\\
\hline
\sphinxcode{RANDOM}
&
\sphinxcode{INTEGER}
&
\sphinxcode{4}
&
Random redaction, each query results in a different random value depending on the datatype of the column.
\\
\hline
\sphinxcode{REGEXP}
&
\sphinxcode{INTEGER}
&
\sphinxcode{5}
&
Regular Expression based redaction, searches for the pattern of data to redact.
\\
\hline
\sphinxcode{CUSTOM}
&
\sphinxcode{INTEGER}
&
\sphinxcode{99}
&
Custom redaction type.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

The following table shows the values for the \sphinxcode{action} parameter of
\sphinxcode{dbms\_redact.alter\_policy}.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|\Y{0.3}|\Y{0.3}|\Y{0.1}|\Y{0.4}|}
\hline

Constant
&
Type
&
Value
&
Description
\\
\hline
\sphinxcode{ADD\_COLUMN}
&
\sphinxcode{INTEGER}
&
\sphinxcode{1}
&
Adds a column to the redaction policy.
\\
\hline
\sphinxcode{DROP\_COLUMN}
&
\sphinxcode{INTEGER}
&
\sphinxcode{2}
&
Drops a column from the redaction policy.
\\
\hline
\sphinxcode{MODIFY\_EXPRESSION}
&
\sphinxcode{INTEGER}
&
\sphinxcode{3}
&
Modifies the expression of a redaction policy. The redaction is applied when the expression evaluates to the \sphinxcode{BOOLEAN} value to \sphinxcode{TRUE}.
\\
\hline
\sphinxcode{MODIFY\_COLUMN}
&
\sphinxcode{INTEGER}
&
\sphinxcode{4}
&
Modifies a column in the redaction policy to change the redaction function type or function parameter.
\\
\hline
\sphinxcode{SET\_POLICY\_DESCRIPTION}
&
\sphinxcode{INTEGER}
&
\sphinxcode{5}
&
Sets the redaction policy description.
\\
\hline
\sphinxcode{SET\_COLUMN\_DESCRIPTION}
&
\sphinxcode{INTEGER}
&
\sphinxcode{6}
&
Sets a description for the redaction performed on the column.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

The partial data redaction enables you to redact only a portion of the
column data. To use partial redaction, you must set the
\sphinxcode{dbms\_redact.add\_policy} procedure \sphinxcode{function\_type} parameter to
\sphinxcode{dbms\_redact.partial} and use the \sphinxcode{function\_parameters} parameter to
specify the partial redaction behavior.

The data redaction feature provides a predefined format to configure
policies that use the following datatype:
\begin{itemize}
\item {} 
\sphinxcode{Character}

\item {} 
\sphinxcode{Number}

\item {} 
\sphinxcode{Datetime}

\end{itemize}

The following table highlights the format descriptor for partial
redaction with respect to datatype. The example described below shows
how to perform a redaction for a string datatype (in this scenario, a
Social Security Number (SSN)), a \sphinxcode{Number} datatype, and a \sphinxcode{DATE} datatype.

\newpage


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}{|\X{2}{16}|\X{6}{16}|\X{3}{16}|\X{5}{16}|}
\hline

\endfirsthead

\multicolumn{4}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{4}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot

Datatype
&
Format Descriptor
&
Description
&
Examples
\\
\hline
Character
&
\sphinxcode{REDACT\_PARTIAL\_INPUT\_FORMAT}
&
Specifies the input format. Enter \sphinxcode{V} for each character from the input string to be possibly redacted. Enter \sphinxcode{F} for each character from the input string that can be considered as a separator such as blank spaces or hyphens.
&
Consider \sphinxcode{'VVVFVVFVVVV,VVV-VV-VVVV,X,1,5'} for masking first 5 digits of SSN strings such as \sphinxcode{123-45-6789}, adding hyphen to format it and thereby resulting in strings such as \sphinxcode{XXX-6789.}
The field value \sphinxcode{VVVFVVFVVVV} for matching SSN strings such as \sphinxcode{123-45-6789}.
\\
\hline&
\sphinxcode{REDACT\_PARTIAL\_OUTPUT\_FORMAT}
&
Specifies the output format. Enter \sphinxcode{V} for each character from the input string to be possibly redacted. Replace each \sphinxcode{F} character from the input format with a character such as a hyphen or any other separator.
&
The field value \sphinxcode{VVV-VV-VVVV} can be used to redact SSN strings into \sphinxcode{XXX-XX-6789} where \sphinxcode{X} comes from \sphinxcode{REDACT\_PARTIAL\_MASKCHAR} field.
\\
\hline&
\sphinxcode{REDACT\_PARTIAL\_MASKCHAR}
&
Specifies the character to be used for redaction.
&
The value \sphinxcode{X} for redacting SSN strings into \sphinxcode{XXX-XX-6789}.
\\
\hline&
\sphinxcode{REDACT\_PARTIAL\_MASKFROM}
&
Specifies which \sphinxcode{V} within the input format from which to start the redaction.
&
The value \sphinxcode{1} for redacting SSN strings starting at the first \sphinxcode{V} of the input format of \sphinxcode{VVVFVVFVVVV} into strings such as \sphinxcode{XXX-XX-6789}.
\\
\hline&
\sphinxcode{REDACT\_PARTIAL\_MASKTO}
&
Specifies which \sphinxcode{V} within the input format at which to end the redaction.
&
The value 5 for redacting SSN strings up to and including the fifth \sphinxcode{V} within the input format of \sphinxcode{VVVFVVFVVVV} into strings such as \sphinxcode{XXX-XX-6789}.
\\
\hline
Number
&
\sphinxcode{REDACT\_PARTIAL\_MASKCHAR}
&
Specifies the character to be displayed in the range between 0 and 9.
&
\sphinxcode{‘9, 1, 5’} for redacting the first five digits of the Social Security Number \sphinxcode{123456789} into \sphinxcode{999996789}.
\\
\hline&
\sphinxcode{REDACT\_PARTIAL\_MASKFROM}
&
Specifies the start digit position for redaction.
&\\
\hline&
\sphinxcode{REDACT\_PARTIAL\_MASKTO}
&
Specifies the end digit position for redaction.
&\\
\hline
Datetime
&
\sphinxcode{REDACT\_PARTIAL\_DATE\_MONTH}
&
\sphinxcode{‘m’} redacts the month. To mask a specific month, specify \sphinxcode{‘m\#’} where \# indicates the month specified by its number between \sphinxcode{1} and \sphinxcode{12}.
&
\sphinxcode{m3} displays as March.
\\
\hline&
\sphinxcode{REDACT\_PARTIAL\_DATE\_DAY}
&
\sphinxcode{‘d’} redacts the day of the month. To mask with a day of the month, append \sphinxcode{1-31} to a lowercase \sphinxcode{d}.
&
\sphinxcode{d3} displays as \sphinxcode{03}.
\\
\hline&
\sphinxcode{REDACT\_PARTIAL\_DATE\_YEAR}
&
\sphinxcode{‘y’} redacts the year. To mask with a year, append \sphinxcode{1-9999} to a lowercase \sphinxcode{y}.
&
\sphinxcode{y1960} displays as \sphinxcode{60}.
\\
\hline&
\sphinxcode{REDACT\_PARTIAL\_DATE\_HOUR}
&
\sphinxcode{‘h’} redacts the hour. To mask with an hour, append \sphinxcode{0-23} to a lowercase \sphinxcode{h}.
&
\sphinxcode{h18} displays as \sphinxcode{18}.
\\
\hline&
\sphinxcode{REDACT\_PARTIAL\_DATE\_MINUTE}
&
\sphinxcode{‘m’} redacts the minute. To mask with a minute, append \sphinxcode{0-59} to a lowercase \sphinxcode{m}.
&
\sphinxcode{m20} displays as \sphinxcode{20}.
\\
\hline&
\sphinxcode{REDACT\_PARTIAL\_DATE\_SECOND}
&
\sphinxcode{‘s’} redacts the second. To mask with a second, append \sphinxcode{0-59} to a lowercase \sphinxcode{s}.
&
\sphinxcode{s40} displays as \sphinxcode{40}.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}

The following table represents \sphinxcode{function\_parameters} values that can be used in partial redaction.


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}{|\X{12}{34}|\X{4}{34}|\X{9}{34}|\X{9}{34}|}
\hline

\endfirsthead

\multicolumn{4}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{4}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot

Function Parameter
&
Data Type
&
Value
&
Description
\\
\hline
\sphinxcode{REDACT\_US\_SSN\_F5}
&
\sphinxcode{VARCHAR2}
&
\sphinxcode{'VVVFVVFVVVV,VVV-VV-VVVV,X,1,5'}
&
Redacts the first 5 numbers of SSN.

\sphinxstylestrong{Example:} The number \sphinxcode{123-45-6789} becomes \sphinxcode{XXX-XX-6789}.
\\
\hline
\sphinxcode{REDACT\_US\_SSN\_L4}
&
\sphinxcode{VARCHAR2}
&
\sphinxcode{'VVVFVVFVVVV,VVV-VV-VVVV,X,6,9'}
&
Redacts the last 4 numbers of SSN.

\sphinxstylestrong{Example:} The number \sphinxcode{123-45-6789} becomes \sphinxcode{123-45-XXXX}.
\\
\hline
\sphinxcode{REDACT\_US\_SSN\_ENTIRE}
&
\sphinxcode{VARCHAR2}
&
\sphinxcode{'VVVFVVFVVVV,VVV-VV-VVVV,X,1,9'}
&
Redacts the entire SSN.

\sphinxstylestrong{Example:} The number \sphinxcode{123-45-6789} becomes \sphinxcode{XXX-XX-XXXX}.
\\
\hline
\sphinxcode{REDACT\_NUM\_US\_SSN\_F5}
&
\sphinxcode{VARCHAR2}
&
\sphinxcode{'9,1,5'}
&
Redacts the first 5 numbers of SSN when the column is a number datatype.

\sphinxstylestrong{Example:} The number \sphinxcode{123456789} becomes \sphinxcode{999996789}.
\\
\hline
\sphinxcode{REDACT\_NUM\_US\_SSN\_L4}
&
\sphinxcode{VARCHAR2}
&
\sphinxcode{'9,6,9'}
&
Redacts the last four numbers of SSN when the column is a number datatype.

\sphinxstylestrong{Example:} The number \sphinxcode{123456789} becomes \sphinxcode{123459999}.
\\
\hline
\sphinxcode{REDACT\_NUM\_US\_SSN\_ENTIRE}
&
\sphinxcode{VARCHAR2}
&
\sphinxcode{'9,1,9'}
&
Redacts the entire SSN when the column is a number datatype.

\sphinxstylestrong{Example:} The number \sphinxcode{123456789} becomes \sphinxcode{999999999}.
\\
\hline
\sphinxcode{REDACT\_ZIP\_CODE}
&
\sphinxcode{VARCHAR2}
&
\sphinxcode{'VVVVV,VVVVV,X,1,5'}
&
Redacts a 5 digit zip code.

\sphinxstylestrong{Example:} \sphinxcode{12345} becomes \sphinxcode{XXXXX}.
\\
\hline
\sphinxcode{REDACT\_NUM\_ZIP\_CODE}
&
\sphinxcode{VARCHAR2}
&
\sphinxcode{'9,1,5'}
&
Redacts a 5 digit zip code when the column is a number datatype.

\sphinxstylestrong{Example:} \sphinxcode{12345} becomes \sphinxcode{99999}.
\\
\hline
\sphinxcode{REDACT\_CCN16\_F12}
&
\sphinxcode{VARCHAR2}
&
\sphinxcode{'VVVVFVVVVFVVVVFVVVV,VVVV-VVVV-VVVV-VVVV,*,1,12'}
&
Redacts a 16 digit credit card number and displays only 4 digits.

\sphinxstylestrong{Example:} \sphinxcode{1234} 5678 9000 2358 becomes \sphinxcode{****-****-****-2358}.
\\
\hline
\sphinxcode{REDACT\_DATE\_MILLENNIUM}
&
\sphinxcode{VARCHAR2}
&
\sphinxcode{'m1d1y2000'}
&
Redacts a date that is in the \sphinxcode{DD-MM-YY} format.

\sphinxstylestrong{Example:} Redacts all date to \sphinxcode{01-JAN-2000}.
\\
\hline
\sphinxcode{REDACT\_DATE\_EPOCH}
&
\sphinxcode{VARCHAR2}
&
\sphinxcode{'m1d1y1970'}
&
Redacts all dates to \sphinxcode{01-JAN-70}.
\\
\hline
\sphinxcode{REDACT\_AMEX\_CCN\_FORMATTED}
&
\sphinxcode{VARCHAR2}
&
\sphinxcode{'VVVVFVVVVVVFVVVVV,VVVV-VVVVVV-VVVVV,*,1,10'}
&
Redacts the Amercian Express credit card number and replaces the digit with * except for the last 5 digits.

\sphinxstylestrong{Example:} The credit card number \sphinxcode{1234 567890 34500} becomes \sphinxcode{**** ****** 34500}.
\\
\hline
\sphinxcode{REDACT\_AMEX\_CCN\_NUMBER}
&
\sphinxcode{VARCHAR2}
&
\sphinxcode{'0,1,10'}
&
Redacts the Amercian Express credit card number and replaces the digit with 0 except the last 5 digits.

\sphinxstylestrong{Example:} The credit card number \sphinxcode{1234 567890 34500} becomes \sphinxcode{0000 000000 34500}.
\\
\hline
\sphinxcode{REDACT\_SIN\_FORMATTED}
&
\sphinxcode{VARCHAR2}
&
\sphinxcode{'VVVFVVVFVVV,VVV-VVV-VVV,*,1,6'}
&
Redacts the Social Insurance Number by replacing the first 6 digits by *
\sphinxstylestrong{Example:} \sphinxcode{123-456-789} becomes \sphinxcode{***-***-789}.
\\
\hline
\sphinxcode{REDACT\_SIN\_NUMBER}
&
\sphinxcode{VARCHAR2}
&
\sphinxcode{'9,1,6'}
&
Redacts the Social Insurance Number by replacing the first 6 digits by \sphinxcode{9}.

\sphinxstylestrong{Example:} \sphinxcode{123456789} becomes \sphinxcode{999999789}.
\\
\hline
\sphinxcode{REDACT\_SIN\_UNFORMATTED}
&
\sphinxcode{VARCHAR2}
&
\sphinxcode{'VVVVVVVVV,VVVVVVVVV,*,1,6'}
&
Redacts the Social Insurance Number by replacing the first 6 digits by *.

\sphinxstylestrong{Example:} \sphinxcode{123456789} becomes \sphinxcode{******789}.
\\
\hline
\sphinxcode{REDACT\_CCN\_FORMATTED}
&
\sphinxcode{VARCHAR2}
&
\sphinxcode{'VVVVFVVVVFVVVVFVVVV,VVVV-VVVV-VVVV-VVVV,*,1,12'}
&
Redacts a credit card number by * and displays only 4 digits.

\sphinxstylestrong{Example:} The credit card number \sphinxcode{1234-5678-9000-4671} becomes \sphinxcode{****-****-****-4671}.
\\
\hline
\sphinxcode{REDACT\_CCN\_NUMBER}
&
\sphinxcode{VARCHAR2}
&
\sphinxcode{'9,1,12'}
&
Redacts a credit card number by \sphinxcode{0} except the last 4 digits.

\sphinxstylestrong{Example:} The credit card number \sphinxcode{1234567890004671} becomes \sphinxcode{0000000000004671.}
\\
\hline
\sphinxcode{REDACT\_NA\_PHONE\_FORMATTED}
&
\sphinxcode{VARCHAR2}
&
\sphinxcode{‘VVVFVVVFVVVV,VVV-VVV-VVVV,X,4,10'}
&
Redacts the North American phone number by \sphinxcode{X} leaving the area code.

\sphinxstylestrong{Example:} \sphinxcode{123-456-7890} becomes \sphinxcode{123-XXX-XXXX}.
\\
\hline
\sphinxcode{REDACT\_NA\_PHONE\_NUMBER}
&
\sphinxcode{VARCHAR2}
&
\sphinxcode{'0,4,10'}
&
Redacts the North American phone number by \sphinxcode{0} leaving the area code.

\sphinxstylestrong{Example:} \sphinxcode{1234567890} becomes \sphinxcode{1230000000}.
\\
\hline
\sphinxcode{REDACT\_NA\_PHONE\_UNFORMATTED}
&
\sphinxcode{VARCHAR2}
&
\sphinxcode{'VVVVVVVVVV,VVVVVVVVVV,X,4,10'}
&
Redacts the North American phone number by \sphinxcode{X} leaving the area code.

\sphinxstylestrong{Example:} \sphinxcode{1234567890} becomes \sphinxcode{123XXXXXXX}.
\\
\hline
\sphinxcode{REDACT\_UK\_NIN\_FORMATTED}
&
\sphinxcode{VARCHAR2}
&
\sphinxcode{'VVFVVFVVFVVFV,VV VV VV VV V,X,3,8'}
&
Redacts the UK National Insurance Number by \sphinxcode{X} but leaving the alphabetic characters.

\sphinxstylestrong{Example:} \sphinxcode{NY 22 01 34 D} becomes \sphinxcode{NY XX XX XX D}.
\\
\hline
\sphinxcode{REDACT\_UK\_NIN\_UNFORMATTED}
&
\sphinxcode{VARCHAR2}
&
\sphinxcode{'VVVVVVVVV,VVVVVVVVV,X,3,8'}
&
Redacts the UK National Insurance Number by \sphinxcode{X} but leaving the alphabetic characters.

\sphinxstylestrong{Example:} \sphinxcode{NY220134D} becomes \sphinxcode{NYXXXXXXD}.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}

A regular expression-based redaction searches for patterns of data to redact. The \sphinxcode{regexp\_pattern} search the values in order for the \sphinxcode{regexp\_replace\_string} to change the value. The following table illustrates the \sphinxcode{regexp\_pattern} values that you can use during \sphinxcode{REGEXP} based redaction.


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}{|\X{22}{60}|\X{8}{60}|\X{30}{60}|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
\sphinxstylestrong{Function Parameter and Description}
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
\sphinxstylestrong{Data Type}
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
\sphinxstylestrong{Value}
\unskip}\relax \\
\hline
\endfirsthead

\multicolumn{3}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
\sphinxstylestrong{Function Parameter and Description}
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
\sphinxstylestrong{Data Type}
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
\sphinxstylestrong{Value}
\unskip}\relax \\
\hline
\endhead

\hline
\multicolumn{3}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{RE\_PATTERN\_CC\_L6\_T4}: Searches for the middle digits of a credit card number that includes 6 leading digits and 4 trailing digits.
\item[] The regexp\_replace\_string setting to use with the format is RE\_REDACT\_CC\_MIDDLE\_DIGITS that replaces the identified pattern with the characters specified by the RE\_REDACT\_CC\_MIDDLE\_DIGITS parameter.
\end{DUlineblock}
&
VARCHAR2
&
‘(dddddd)(ddd*)(dddd)’
\\
\hline
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{RE\_PATTERN\_ANY\_DIGITs}: Searches for any digit and replaces the identified pattern with the characters specified by the following values of the regexp\_replace\_string parameter.
\item[] regexp\_replace\_string=\textgreater{} RE\_REDACT\_WITH\_SINGLE\_X
\item[] (replaces any matched digit with the X character).
\item[] regexp\_replace\_string=\textgreater{} RE\_REDACT\_WITH\_SINGLE\_1
\item[] (replaces any matched digit with the 1 character).
\end{DUlineblock}
&
VARCHAR2
&
‘d’
\\
\hline
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{RE\_PATTERN\_US\_PHONE}: Searches for the U.S phone number and replaces the identified pattern with the characters specified by the regexp\_replace\_string parameter.
\item[] regexp\_replace\_string=\textgreater{} RE\_REDACT\_US\_PHONE\_L7
\item[] (searches the phone number and then replaces the last 7 digits).
\end{DUlineblock}
&
VARCHAR2
&
‘((ddd)\textbar{}ddd)-(ddd)-(dddd)’
\\
\hline
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{RE\_PATTERN\_EMAIL\_ADDRESS}: Searches for the email address and replaces the identified pattern with the characters specified by the following values of the regexp\_replace\_string parameter.
\item[] regexp\_replace\_string=\textgreater{} RE\_REDACT\_EMAIL\_NAME
\item[] (finds the email address and redacts the email username).
\item[] regexp\_replace\_string=\textgreater{} RE\_REDACT\_EMAIL\_DOMAIN
\item[] (finds the email address and redacts the email domain).
\item[] regexp\_replace\_string=\textgreater{} RE\_REDACT\_EMAIL\_ENTIRE
\item[] (finds the email address and redacts the entire email address).
\end{DUlineblock}
&
VARCHAR2
&
‘({[}A-Za-z0-9.\_\%+-{]}+)@({[}A-Za-z0-9.-{]}+.{[}A-Za-z{]}\{2,4\})’
\\
\hline
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{RE\_PATTERN\_IP\_ADDRESS}: Searches for an IP address and replaces the identified pattern with the characters specified by the regexp\_replace\_string parameter. The regexp\_replace\_string parameter to be used is RE\_REDACT\_IP\_L3 that replaces the last section of an IP address with 999 and indicates it is redacted.
\end{DUlineblock}
&
VARCHAR2
&
‘(d\{1,3\}.d\{1,3\}.d\{1,3\}).d\{1,3\}’
\\
\hline
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{RE\_PATTERN\_AMEX\_CCN}: Searches for the American Express credit card number. The regexp\_replace\_string parameter to be used is RE\_REDACT\_AMEX\_CCN that redacts all of the digits except the last 5.
\end{DUlineblock}
&
VARCHAR2
&
‘.*(ddddd)\$’
\\
\hline
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{RE\_PATTERN\_CCN}: Searches for the credit card number other than American Express credit cards. The regexp\_replace\_string parameter to be used is RE\_REDACT\_CCN that redacts all of the digits except the last 4.
\end{DUlineblock}
&
VARCHAR2
&
‘.*(dddd)\$’
\\
\hline
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{RE\_PATTERN\_US\_SSN}: Searches the SSN number and replaces the identified pattern with the characters specified by the regexp\_replace\_string parameter.
\item[] ‘1-XXX-XXXX’ or ‘XXX-XXX-3’ will return  123-XXX-XXXX or XXX-XXX-6789 for the value ‘123-45-6789’ respectively.
\end{DUlineblock}
&
VARCHAR2
&
‘(ddd)-(dd)-(dddd)’
\\
\hline
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{RE\_REDACT\_CC\_MIDDLE\_DIGITS}: Redacts the middle digits of a credit card number according to the regexp\_pattern parameter with the RE\_PATTERN\_CC\_L6\_T4 format and replaces each redacted character with an X.
\item[] Example: The credit card number 1234 5678 9000 2490 becomes 1234 56XX XXXX 2490.
\end{DUlineblock}
&
VARCHAR2
&
‘1XXXXXX3’
\\
\hline
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{RE\_REDACT\_WITH\_SINGLE\_X}: Replaces the data with a single X character for each matching pattern as specified by setting
\end{DUlineblock}
&
VARCHAR2
&
‘X’
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}

The below table illustrates the \sphinxcode{regexp\_replace\_string} values that you
can use during \sphinxcode{REGEXP} based redaction.


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}{|\X{9}{24}|\X{3}{24}|\X{4}{24}|\X{8}{24}|}
\hline

\endfirsthead

\multicolumn{4}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{4}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot

Function Parameter
&
Data Type
&
Value
&
Description
\\
\hline
RE\_REDACT\_CC\_MIDDLE\_DIGITS
&
VARCHAR2
&
‘1XXXXXX3’
&
Redacts the middle digits of a credit card number according to the regexp\_pattern parameter with the RE\_PATTERN\_CC\_L6\_T4 format and replaces each redacted character with an X.

\sphinxstylestrong{Example:} The credit card number 1234 5678 9000 2490 becomes 1234 56XX XXXX 2490.
\\
\hline
RE\_REDACT\_WITH\_SINGLE\_X
&
VARCHAR2
&
‘X’
&
Replaces the data with a single X character for each matching pattern as specified by setting the regexp\_pattern parameter with the RE\_PATTERN\_ANY\_DIGIT format.

\sphinxstylestrong{Example:} The credit card number 1234 5678 9000 2490 becomes XXXX XXXX XXXX XXXX.
\\
\hline
RE\_REDACT\_WITH\_SINGLE\_1
&
VARCHAR2
&
‘1’
&
Replaces the data with a single 1 digit for each of the data digits as specified by setting the regexp\_pattern parameter with the RE\_PATTERN\_ANY\_DIGIT format.

\sphinxstylestrong{Example:} The credit card number 1234 5678 9000 2490 becomes 1111 1111 1111 1111.
\\
\hline
RE\_REDACT\_US\_PHONE\_L7
&
VARCHAR2
&
‘1-XXX-XXXX’
&
Redacts the last 7 digits of U.S phone number according to the regexp\_pattern parameter with the RE\_PATTERN\_US\_PHONE format and replaces each redacted character with an X.

\sphinxstylestrong{Example:} The phone number 123-444-5900 becomes 123-XXX-XXXX.
\\
\hline
RE\_REDACT\_EMAIL\_NAME
&
VARCHAR2
&
\sphinxhref{mailto:'xxxx@2}{‘xxxx@2}’
&
Redacts the email name according to the regexp\_pattern parameter with the RE\_PATTERN\_EMAIL\_ADDRESS format and replaces the email username with the four x characters.

\sphinxstylestrong{Example:} The email address s\sphinxhref{mailto:john@example.com}{john@example.com} becomes \sphinxhref{mailto:xxxx@example.com}{xxxx@example.com}.
\\
\hline
RE\_REDACT\_EMAIL\_DOMAIN
&
VARCHAR2
&
\sphinxhref{mailto:'1@xxxxx.com}{‘1@xxxxx.com}’
&
Redacts the email domain name according to the regexp\_pattern parameter with the RE\_PATTERN\_EMAIL\_ADDRESS format and replaces the domain with the five x characters.

\sphinxstylestrong{Example:} The email address s\sphinxhref{mailto:john@example.com}{john@example.com} becomes \sphinxhref{mailto:sjohn@xxxxx.com}{sjohn@xxxxx.com}.
\\
\hline
RE\_REDACT\_EMAIL\_ENTIRE
&
VARCHAR2
&
\sphinxhref{mailto:'xxxx@xxxxx.com}{‘xxxx@xxxxx.com}’
&
Redacts the entire email address according to the regexp\_pattern parameter with the RE\_PATTERN\_EMAIL\_ADDRESS format and replaces the email address with the x characters.

\sphinxstylestrong{Example:} The email address s\sphinxhref{mailto:john@example.com}{john@example.com} becomes \sphinxhref{mailto:xxxx@xxxxx.com}{xxxx@xxxxx.com}.
\\
\hline
RE\_REDACT\_IP\_L3
&
VARCHAR2
&
‘1.999’
&
Redacts the last 3 digits of an IP address according to the regexp\_pattern parameter with the RE\_PATTERN\_IP\_ADDRESS format.

\sphinxstylestrong{Example:} The IP address 172.0.1.258 becomes 172.0.1.999, which is an invalid IP address.
\\
\hline
RE\_REDACT\_AMEX\_CCN
&
VARCHAR2
&
‘\sphinxstylestrong{******}1’
&
Redacts the first 10 digits of an American Express credit card number according to the regexp\_pattern parameter with the RE\_PATTERN\_AMEX\_CCN format.
\sphinxstylestrong{Example:} 123456789062816 becomes **********62816.
\\
\hline
RE\_REDACT\_CCN
&
VARCHAR2
&
‘\sphinxstylestrong{********}1’
&
Redacts the first 12 digits of a credit card number as specified by the regexp\_pattern parameter with the RE\_PATTERN\_CCN format.

\sphinxstylestrong{Example:} 8749012678345671 becomes ************5671.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}

The following tables show the \sphinxcode{regexp\_position} value and \sphinxcode{regexp\_occurence} values that you can use during \sphinxcode{REGEXP} based redaction.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|\Y{0.2}|\Y{0.15}|\Y{0.1}|\Y{0.5}|}
\hline

Function Parameter
&
Data Type
&
Value
&
Description
\\
\hline
RE\_BEGINNING
&
INTEGER
&
1
&
Specifies the position of a character where search must begin. By default, the value is 1 that indicates the search begins at the first character of source\_char.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|\Y{0.2}|\Y{0.15}|\Y{0.1}|\Y{0.5}|}
\hline

Function Parameter
&
Data Type
&
Value
&
Description
\\
\hline
RE\_ALL
&
INTEGER
&
0
&
Specifies the replacement occurrence of a substring. If the value is 0, then the replacement of each matching substring occurs.
\\
\hline
RE\_FIRST
&
INTEGER
&
1
&
Specifies the replacement occurrence of a substring. If the value is 1, then the replacement of the first matching substring occurs.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

The following table shows the \sphinxcode{regexp\_match\_parameter} values that you
can use during \sphinxcode{REGEXP} based redaction which lets you change the default
matching behavior of a function.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|\Y{0.3}|\Y{0.2}|\Y{0.1}|\Y{0.4}|}
\hline

Function Parameter
&
Data Type
&
Value
&
Description
\\
\hline
RE\_CASE\_SENSITIVE
&
VARCHAR2
&
‘c’
&
Specifies the case-sensitive matching.
\\
\hline
RE\_CASE\_INSENSITIVE
&
VARCHAR2
&
‘i’
&
Specifies the case-insensitive matching.
\\
\hline
RE\_MULTIPLE\_LINES
&
VARCHAR2
&
‘m’
&
Treats the source string as multiple lines but if you omit this parameter, then it indicates as a single line.
\\
\hline
RE\_NEWLINE\_WILDCARD
&
VARCHAR2
&
‘n’
&
Specifies the period (.), but if you omit this parameter, then the period does not match the newline character.
\\
\hline
RE\_IGNORE\_WHITESPACE
&
VARCHAR2
&
‘x’
&
Ignores the whitespace characters.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{sphinxadmonition}{note}{Note:}
If you create a redaction policy based on a numeric type column, then make sure that the result after redaction is a number and accordingly set the replacement string to avoid runtime errors.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
If you create a redaction policy based on a character type column, then make sure that a length of the result after redaction is compatible with the column type and accordingly set the replacement string to avoid runtime errors.
\end{sphinxadmonition}

\newpage

\index{DBMS\_REDACT\_ADD\_POLICY}\ignorespaces 

\subsection{ADD\_POLICY}
\label{\detokenize{dbms_redact:add-policy}}\label{\detokenize{dbms_redact:index-2}}
The \sphinxcode{add\_policy} procedure creates a new data redaction policy for a
table.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
PROCEDURE add\PYGZus{}policy (
object\PYGZus{}schema                     IN VARCHAR2 DEFAULT NULL,
object\PYGZus{}name                       IN VARCHAR2,
policy\PYGZus{}name                       IN VARCHAR2,
policy\PYGZus{}description                IN VARCHAR2 DEFAULT NULL,
column\PYGZus{}name                       IN VARCHAR2 DEFAULT NULL,
column\PYGZus{}description                IN VARCHAR2 DEFAULT NULL,
function\PYGZus{}type             IN INTEGER DEFAULT DBMS\PYGZus{}REDACT.FULL,
function\PYGZus{}parameters               IN VARCHAR2 DEFAULT NULL,
expression                        IN VARCHAR2,
enable                            IN BOOLEAN DEFAULT TRUE,
regexp\PYGZus{}pattern                    IN VARCHAR2 DEFAULT NULL,
regexp\PYGZus{}replace\PYGZus{}string             IN VARCHAR2 DEFAULT NULL,
regexp\PYGZus{}position    IN INTEGER DEFAULT DBMS\PYGZus{}REDACT.RE\PYGZus{}BEGINNING,
regexp\PYGZus{}occurrence IN INTEGER DEFAULT       DBMS\PYGZus{}REDACT.RE\PYGZus{}ALL,
regexp\PYGZus{}match\PYGZus{}parameter            IN VARCHAR2 DEFAULT NULL,
custom\PYGZus{}function\PYGZus{}expression        IN VARCHAR2 DEFAULT NULL
)
\end{sphinxVerbatim}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}object\_schema\textgreater{}}
\begin{quote}

Specifies the name of the schema in which the object resides and on
which the data redaction policy will be applied. If you specify \sphinxcode{NULL}
then the given object is searched by the order specified by \sphinxcode{search\_path}
setting.
\end{quote}

\sphinxcode{\textless{}object\_name\textgreater{}}
\begin{quote}

Name of the table on which the data redaction policy is created.
\end{quote}

\sphinxcode{\textless{}policy\_name\textgreater{}}
\begin{quote}

Name of the policy to be added. Ensure that the \sphinxcode{policy\_name} is unique
for the table on which the policy is created.
\end{quote}

\sphinxcode{\textless{}policy\_description\textgreater{}}
\begin{quote}

Specify the description of a redaction policy.
\end{quote}

\sphinxcode{\textless{}column\_name\textgreater{}}
\begin{quote}

Name of the column to which the redaction policy applies. To redact more
than one column, use the \sphinxcode{alter\_policy} procedure to add additional
columns.
\end{quote}

\sphinxcode{\textless{}column\_description\textgreater{}}
\begin{quote}

Description of the column to be redacted. The \sphinxcode{column\_description} is not
supported, but if you specify the description for a column then, you
will get a warning message.
\end{quote}

\sphinxcode{\textless{}function\_type\textgreater{}}
\begin{quote}

The type of redaction function to be used. The possible values are \sphinxcode{NONE,
FULL, PARTIAL, RANDOM, REGEXP}, and \sphinxcode{CUSTOM}.
\end{quote}

\sphinxcode{\textless{}function\_parameters\textgreater{}}
\begin{quote}

Specifies the function parameters for the partition redaction and is
applicable only for partial redaction.
\end{quote}

\newpage

\sphinxcode{\textless{}expression\textgreater{}}
\begin{quote}

Specifies the Boolean expression for the table and determines how the
policy is to be applied. The redaction occurs if this policy expression
is evaluated to \sphinxcode{TRUE}.
\end{quote}

\sphinxcode{\textless{}enable\textgreater{}}
\begin{quote}

When set to \sphinxcode{TRUE}, the policy is enabled upon creation. The default is
set as \sphinxcode{TRUE}. When set to \sphinxcode{FALSE}, the policy is disabled but the policy
can be enabled by calling the \sphinxcode{enable\_policy} procedure.
\end{quote}

\sphinxcode{\textless{}regexp\_pattern\textgreater{}}
\begin{quote}

Specifies the regular expression pattern to redact data. If the
\sphinxcode{regexp\_pattern} does not match, then the \sphinxcode{NULL} value is returned.
\end{quote}

\sphinxcode{\textless{}regexp\_replace\_string\textgreater{}}
\begin{quote}

Specifies the replacement string value.
\end{quote}

\sphinxcode{\textless{}regexp\_position\textgreater{}}
\begin{quote}

Specifies the position of a character where search must begin. By
default, the function parameter is \sphinxcode{RE\_BEGINNING}.
\end{quote}

\sphinxcode{\textless{}regexp\_occurrence\textgreater{}}
\begin{quote}

Specifies the replacement occurrence of a substring. If the constant is
\sphinxcode{RE\_ALL}, then the replacement of each matching substring occurs. If the
constant is \sphinxcode{RE\_FIRST}, then the replacement of the first matching
substring occurs.
\end{quote}

\sphinxcode{\textless{}regexp\_match\_parameter\textgreater{}}
\begin{quote}

Changes the default matching behavior of a function. The possible
regexp\_match\_parameter constants can be \sphinxcode{‘RE\_CASE\_SENSITIVE’,
‘RE\_CASE\_INSENSITIVE’, ‘RE\_MULTIPLE\_LINES’, ‘RE\_NEWLINE\_WILDCARD’,
‘RE\_IGNORE\_WHITESPACE’}.

\begin{sphinxadmonition}{note}{Note:}
For more information on \sphinxcode{constants}, \sphinxcode{function\_parameters}, or \sphinxcode{regexp} (regular expressions) see, Using \sphinxcode{DBMS\_REDACT Constants} and \sphinxcode{Function Parameters}.
\end{sphinxadmonition}
\end{quote}

\sphinxcode{\textless{}custom\_function\_expression\textgreater{}}
\begin{quote}

The \sphinxcode{custom\_function\_expression} is applicable only for the \sphinxcode{CUSTOM}
redaction type. The \sphinxcode{custom\_function\_expression} is a function
expression that is, schema-qualified function with a parameter such as
\sphinxcode{schema\_name.function\_name (argument1, …})that allows a user to use
their redaction logic to redact the column data.
\end{quote}

\sphinxstylestrong{Example}

The following example illustrates how to create a policy and use full
redaction for values in the \sphinxcode{payment\_details\_tab} table \sphinxcode{customer id}
column.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
edb=\PYGZsh{} CREATE TABLE payment\PYGZus{}details\PYGZus{}tab (
customer\PYGZus{}id NUMBER       NOT NULL,
card\PYGZus{}string VARCHAR2(19) NOT NULL);
CREATE TABLE

edb=\PYGZsh{} BEGIN
  INSERT INTO payment\PYGZus{}details\PYGZus{}tab VALUES (4000, \PYGZsq{}1234\PYGZhy{}1234\PYGZhy{}1234\PYGZhy{}1234\PYGZsq{});
  INSERT INTO payment\PYGZus{}details\PYGZus{}tab VALUES (4001, \PYGZsq{}2345\PYGZhy{}2345\PYGZhy{}2345\PYGZhy{}2345\PYGZsq{});
END;

EDB\PYGZhy{}SPL Procedure successfully completed

edb=\PYGZsh{} CREATE USER redact\PYGZus{}user;
CREATE ROLE
edb=\PYGZsh{} GRANT SELECT ON payment\PYGZus{}details\PYGZus{}tab TO redact\PYGZus{}user;
GRANT

\PYGZbs{}c edb base\PYGZus{}user

BEGIN
  DBMS\PYGZus{}REDACT.add\PYGZus{}policy(
    object\PYGZus{}schema              =\PYGZgt{} \PYGZsq{}public\PYGZsq{},
    object\PYGZus{}name                =\PYGZgt{} \PYGZsq{}payment\PYGZus{}details\PYGZus{}tab\PYGZsq{},
    policy\PYGZus{}name                =\PYGZgt{} \PYGZsq{}redactPolicy\PYGZus{}001\PYGZsq{},
    policy\PYGZus{}description         =\PYGZgt{} \PYGZsq{}redactPolicy\PYGZus{}001 for payment\PYGZus{}details\PYGZus{}tab table\PYGZsq{},
    column\PYGZus{}name                =\PYGZgt{} \PYGZsq{}customer\PYGZus{}id\PYGZsq{},
    function\PYGZus{}type          =\PYGZgt{} DBMS\PYGZus{}REDACT.full,
    expression                 =\PYGZgt{} \PYGZsq{}1=1\PYGZsq{},
    enable                     =\PYGZgt{} TRUE);
END;
\end{sphinxVerbatim}

Redacted Result:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
edb=\PYGZsh{} \PYGZbs{}c edb redact\PYGZus{}user
You are now connected to database \PYGZdq{}edb\PYGZdq{} as user \PYGZdq{}redact\PYGZus{}user\PYGZdq{}.

edb=\PYGZgt{} select customer\PYGZus{}id from payment\PYGZus{}details\PYGZus{}tab order by 1;
 customer\PYGZus{}id
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
           0
           0
(2 rows)
\end{sphinxVerbatim}

\newpage


\subsection{\index{ALTER\_POLICY}ALTER\_POLICY}
\label{\detokenize{dbms_redact:alter-policy}}
The \sphinxcode{alter\_policy} procedure alters or modifies an existing data redaction policy for a table.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
PROCEDURE alter\PYGZus{}policy (
object\PYGZus{}schema                          IN VARCHAR2 DEFAULT NULL,
object\PYGZus{}name                            IN VARCHAR2,
policy\PYGZus{}name                            IN VARCHAR2,
action                    IN INTEGER DEFAULT DBMS\PYGZus{}REDACT.ADD\PYGZus{}COLUMN,
column\PYGZus{}name                            IN VARCHAR2 DEFAULT NULL,
function\PYGZus{}type                          IN INTEGER DEFAULT DBMS\PYGZus{}REDACT.FULL,
function\PYGZus{}parameters              IN VARCHAR2 DEFAULT NULL,
expression                             IN VARCHAR2 DEFAULT NULL,
regexp\PYGZus{}pattern                 IN VARCHAR2 DEFAULT NULL,
regexp\PYGZus{}replace\PYGZus{}string                  IN VARCHAR2 DEFAULT NULL,
regexp\PYGZus{}position      IN INTEGER DEFAULT DBMS\PYGZus{}REDACT.RE\PYGZus{}BEGINNING,
regexp\PYGZus{}occurrence IN INTEGER DEFAULT DBMS\PYGZus{}REDACT.RE\PYGZus{}ALL,
regexp\PYGZus{}match\PYGZus{}parameter      IN VARCHAR2 DEFAULT NULL,
policy\PYGZus{}description                IN VARCHAR2 DEFAULT NULL,
column\PYGZus{}description                IN VARCHAR2 DEFAULT NULL,
custom\PYGZus{}function\PYGZus{}expression  IN VARCHAR2 DEFAULT NULL
)
\end{sphinxVerbatim}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}object\_schema\textgreater{}}
\begin{quote}

Specifies the name of the schema in which the object resides and on
which the data redaction policy will be altered. If you specify \sphinxcode{NULL}
then the given object is searched by the order specified by \sphinxcode{search\_path}
setting.
\end{quote}

\sphinxcode{\textless{}object\_name\textgreater{}}
\begin{quote}

Name of the table to which to alter a data redaction policy.
\end{quote}

\sphinxcode{\textless{}policy\_name\textgreater{}}
\begin{quote}

Name of the policy to be altered.
\end{quote}

\sphinxcode{\textless{}action\textgreater{}}
\begin{quote}

The action to perform. For more information about action parameters see,
{}`{}` DBMS\_REDACT Constants and Function Parameters{}`{}`.
\end{quote}

\sphinxcode{\textless{}column\_name\textgreater{}}
\begin{quote}

Name of the column to which the redaction policy applies.
\end{quote}

\sphinxcode{\textless{}function\_type\textgreater{}}
\begin{quote}

The type of redaction function to be used. The possible values are \sphinxcode{NONE,
FULL, PARTIAL, RANDOM, REGEXP}, and \sphinxcode{CUSTOM}.
\end{quote}

\sphinxcode{\textless{}function\_parameters\textgreater{}}
\begin{quote}

Specifies the function parameters for the redaction function.
\end{quote}

\sphinxcode{\textless{}expression\textgreater{}}
\begin{quote}

Specifies the Boolean expression for the table and determines how the
policy is to be applied. The redaction occurs if this policy expression
is evaluated to \sphinxcode{TRUE}.
\end{quote}

\newpage

\sphinxcode{\textless{}regexp\_pattern\textgreater{}}
\begin{quote}

Enables the use of regular expressions to redact data. If the
\sphinxcode{regexp\_pattern} does not match the data, then the \sphinxcode{NULL} value is
returned.
\end{quote}

\sphinxcode{\textless{}regexp\_replace\_string\textgreater{}}
\begin{quote}

Specifies the replacement string value.
\end{quote}

\sphinxcode{\textless{}regexp\_position\textgreater{}}
\begin{quote}

Specifies the position of a character where search must begin. By
default, the function parameter is \sphinxcode{RE\_BEGINNING}.
\end{quote}

\sphinxcode{\textless{}regexp\_occurence\textgreater{}}
\begin{quote}

Specifies the replacement occurrence of a substring. If the constant is
\sphinxcode{RE\_ALL}, then the replacement of each matching substring occurs. If the
constant is \sphinxcode{RE\_FIRST}, then the replacement of the first matching
substring occurs.
\end{quote}

\sphinxcode{\textless{}regexp\_match\_parameter\textgreater{}}
\begin{quote}

Changes the default matching behavior of a function. The possible
regexp\_match\_parameter constants can be \sphinxcode{‘RE\_CASE\_SENSITIVE’,
‘RE\_CASE\_INSENSITIVE’, ‘RE\_MULTIPLE\_LINES’, ‘RE\_NEWLINE\_WILDCARD’,
‘RE\_IGNORE\_WHITESPACE’}.
\begin{quote}

\begin{sphinxadmonition}{note}{Note:}
For more information on \sphinxcode{constants, function\_parameters}, or \sphinxcode{regexp} (regular expressions) see,  \sphinxcode{Using DBMS\_REDACT Constants and Function Parameters}.
\end{sphinxadmonition}
\end{quote}
\end{quote}

\sphinxcode{\textless{}policy\_description\textgreater{}}
\begin{quote}

Specify the description of a redaction policy.
\end{quote}

\sphinxcode{\textless{}column\_description\textgreater{}}
\begin{quote}

Description of the column to be redacted. The \sphinxcode{column\_description} is not
supported, but if you specify the description for a column then, you
will get a warning message.
\end{quote}

\sphinxcode{\textless{}custom\_function\_expression\textgreater{}}
\begin{quote}

The \sphinxcode{custom\_function\_expression} is applicable only for the \sphinxcode{CUSTOM}
redaction type. The \sphinxcode{custom\_function\_expression} is a function
expression that is, schema-qualified function with a parameter such as
\sphinxcode{schema\_name.function\_name (argument1}, …)that allows a user to use
their redaction logic to redact the column data.
\end{quote}

\sphinxstylestrong{Example}

The following example illustrates to alter a policy  partial
redaction for values in the \sphinxcode{payment\_details\_tab} table \sphinxcode{card\_string}
(usually a credit card number) column.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZbs{}c edb base \PYGZus{}user

    BEGIN
      DBMS\PYGZus{}REDACT.alter\PYGZus{}policy (
            object\PYGZus{}schema               =\PYGZgt{} \PYGZsq{}public\PYGZsq{},
            object\PYGZus{}name                 =\PYGZgt{} \PYGZsq{}payment\PYGZus{}details\PYGZus{}tab\PYGZsq{},
            policy\PYGZus{}name                 =\PYGZgt{} \PYGZsq{}redactPolicy\PYGZus{}001\PYGZsq{},
            action                      =\PYGZgt{} DBMS\PYGZus{}REDACT.ADD\PYGZus{}COLUMN,
            column\PYGZus{}name                 =\PYGZgt{} \PYGZsq{}card\PYGZus{}string\PYGZsq{},
            function\PYGZus{}type               =\PYGZgt{} DBMS\PYGZus{}REDACT.partial,
            function\PYGZus{}parameters         =\PYGZgt{} DBMS\PYGZus{}REDACT.REDACT\PYGZus{}CCN16\PYGZus{}F12);
    END;
\end{sphinxVerbatim}

Redacted Result:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
edb=\PYGZsh{} \PYGZbs{}c \PYGZhy{} redact\PYGZus{}user
You are now connected to database \PYGZdq{}edb\PYGZdq{} as user \PYGZdq{}redact\PYGZus{}user\PYGZdq{}.
edb=\PYGZgt{} SELECT * FROM payment\PYGZus{}details\PYGZus{}tab;
 customer\PYGZus{}id \textbar{}     card\PYGZus{}string
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
           0 \textbar{} ****\PYGZhy{}****\PYGZhy{}****\PYGZhy{}1234
           0 \textbar{} ****\PYGZhy{}****\PYGZhy{}****\PYGZhy{}2345
(2 rows)
\end{sphinxVerbatim}

\newpage


\subsection{\index{DISABLE\_POLICY}DISABLE\_POLICY}
\label{\detokenize{dbms_redact:disable-policy}}
The \sphinxcode{disable\_policy} procedure disables an existing data redaction
policy.

\sphinxcode{PROCEDURE disable\_policy} (
\begin{quote}

\sphinxcode{\textless{}object\_schema\textgreater{}     IN VARCHAR2 DEFAULT NULL,}

\sphinxcode{\textless{}object\_name\textgreater{}       IN VARCHAR2,}

\sphinxcode{\textless{}policy\_name\textgreater{}       IN VARCHAR2}

)
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}object\_schema\textgreater{}}
\begin{quote}

Specifies the name of the schema in which the object resides and on
which the data redaction policy will be applied. If you specify \sphinxcode{NULL}
then the given object is searched by the order specified by \sphinxcode{search\_path}
setting.
\end{quote}

\sphinxcode{\textless{}object\_name\textgreater{}}
\begin{quote}

Name of the table for which to disable a data redaction policy.
\end{quote}

\sphinxcode{\textless{}policy\_name\textgreater{}}
\begin{quote}

Name of the policy to be disabled.
\end{quote}

Example

The following example illustrates how to disable a policy.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZbs{}c edb base\PYGZus{}user

BEGIN
  DBMS\PYGZus{}REDACT.disable\PYGZus{}policy(
    object\PYGZus{}schema =\PYGZgt{} \PYGZsq{}public\PYGZsq{},
    object\PYGZus{}name =\PYGZgt{} \PYGZsq{}payment\PYGZus{}details\PYGZus{}tab\PYGZsq{},
    policy\PYGZus{}name =\PYGZgt{} \PYGZsq{}redactPolicy\PYGZus{}001\PYGZsq{});
END;
\end{sphinxVerbatim}

Redacted Result: Data is no longer redacted after disabling a policy.

\newpage

\index{DBMS\_REDACT\_ENABLE\_POLICY}\ignorespaces 

\subsection{ENABLE\_POLICY}
\label{\detokenize{dbms_redact:enable-policy}}\label{\detokenize{dbms_redact:index-5}}
The \sphinxcode{enable\_policy} procedure enables the previously disabled data
redaction policy.

\sphinxcode{PROCEDURE enable\_policy (}
\begin{quote}

\sphinxcode{\textless{}object\_schema\textgreater{} IN VARCHAR2 DEFAULT NULL,}

\sphinxcode{\textless{}object\_name\textgreater{} IN VARCHAR2,}

\sphinxcode{\textless{}policy\_name\textgreater{} IN VARCHAR2}

)
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}object\_schema\textgreater{}}
\begin{quote}

Specifies the name of the schema in which the object resides and on
which the data redaction policy will be applied. If you specify \sphinxcode{NULL}
then the given object is searched by the order specified by \sphinxcode{search\_path}
setting.
\end{quote}

\sphinxcode{\textless{}object\_name\textgreater{}}
\begin{quote}

Name of the table to which to enable a data redaction policy.
\end{quote}

\sphinxcode{\textless{}policy\_name\textgreater{}}
\begin{quote}

Name of the policy to be enabled.
\end{quote}

\sphinxstylestrong{Example}

The following example illustrates how to enable a policy.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZbs{}c edb base\PYGZus{}user

BEGIN
  DBMS\PYGZus{}REDACT.enable\PYGZus{}policy(
    object\PYGZus{}schema =\PYGZgt{} \PYGZsq{}public\PYGZsq{},
    object\PYGZus{}name =\PYGZgt{} \PYGZsq{}payment\PYGZus{}details\PYGZus{}tab\PYGZsq{},
    policy\PYGZus{}name =\PYGZgt{} \PYGZsq{}redactPolicy\PYGZus{}001\PYGZsq{});
END;
\end{sphinxVerbatim}

Redacted Result: Data is redacted after enabling a policy.

\newpage

\index{DBMS\_REDACT\_DROP\_POLICY}\ignorespaces 

\subsection{DROP\_POLICY}
\label{\detokenize{dbms_redact:drop-policy}}\label{\detokenize{dbms_redact:index-6}}
The \sphinxcode{drop\_policy} procedure drops a data redaction policy by removing the
masking policy from a table.

\sphinxcode{PROCEDURE drop\_policy} (
\begin{quote}

\sphinxcode{\textless{}object\_schema IN VARCHAR2 DEFAULT NULL},

\sphinxcode{\textless{}object\_name IN VARCHAR2},

\sphinxcode{\textless{}policy\_name IN VARCHAR2}

)
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}object\_schema\textgreater{}}
\begin{quote}

Specifies the name of the schema in which the object resides and on
which the data redaction policy will be applied. If you specify \sphinxcode{NULL}
then the given object is searched by the order specified by \sphinxcode{search\_path}
setting.
\end{quote}

\sphinxcode{\textless{}object\_name\textgreater{}}
\begin{quote}

Name of the table from which to drop a data redaction policy.
\end{quote}

\sphinxcode{\textless{}policy\_name\textgreater{}}
\begin{quote}

Name of the policy to be dropped.
\end{quote}

\sphinxstylestrong{Example}

The following example illustrates how to drop a policy.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZbs{}c edb base\PYGZus{}user

BEGIN
  DBMS\PYGZus{}REDACT.drop\PYGZus{}policy(
    object\PYGZus{}schema =\PYGZgt{} \PYGZsq{}public\PYGZsq{},
    object\PYGZus{}name =\PYGZgt{} \PYGZsq{}payment\PYGZus{}details\PYGZus{}tab\PYGZsq{},
    policy\PYGZus{}name =\PYGZgt{} \PYGZsq{}redactPolicy\PYGZus{}001\PYGZsq{});
\end{sphinxVerbatim}

Redacted Result: The server drops the specified policy.

\newpage


\subsection{\index{UPDATE\_FULL\_REDACTION\_VALUES}UPDATE\_FULL\_REDACTION\_VALUES}
\label{\detokenize{dbms_redact:update-full-redaction-values}}
The \sphinxcode{update\_full\_redaction\_values} procedure updates the default
displayed values for a data redaction policy and these default values
can be viewed using the \sphinxcode{redaction\_values\_for\_type\_full} view that use
the full redaction type.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
PROCEDURE update\PYGZus{}full\PYGZus{}redaction\PYGZus{}values (
number\PYGZus{}val          IN NUMBER                DEFAULT NULL,
binfloat\PYGZus{}val        IN FLOAT4                DEFAULT NULL,
bindouble\PYGZus{}val       IN FLOAT8                DEFAULT NULL,
char\PYGZus{}val            IN CHAR                  DEFAULT NULL,
varchar\PYGZus{}val         IN VARCHAR2              DEFAULT NULL,
nchar\PYGZus{}val           IN NCHAR                 DEFAULT NULL,
nvarchar\PYGZus{}val        IN NVARCHAR2             DEFAULT NULL,
datecol\PYGZus{}val         IN DATE                  DEFAULT NULL,
ts\PYGZus{}val              IN TIMESTAMP             DEFAULT NULL,
tswtz\PYGZus{}val           IN TIMESTAMPTZ           DEFAULT NULL,
blob\PYGZus{}val            IN BLOB                  DEFAULT NULL,
clob\PYGZus{}val            IN CLOB                  DEFAULT NULL,
nclob\PYGZus{}val           IN CLOB                  DEFAULT NULL
)
\end{sphinxVerbatim}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}number\_val\textgreater{}}
\begin{quote}

Updates the default value for columns of the \sphinxcode{NUMBER} datatype.
\end{quote}

\sphinxcode{\textless{}binfloat\_val\textgreater{}}
\begin{quote}

The \sphinxcode{FLOAT4} datatype is a random value. The binary float datatype is not
supported.
\end{quote}

\sphinxcode{\textless{}bindouble\_val\textgreater{}}
\begin{quote}

The \sphinxcode{FLOAT8} datatype is a random value. The binary double datatype is not
supported.
\end{quote}

\sphinxcode{\textless{}char\_val\textgreater{}}
\begin{quote}

Updates the default value for columns of the \sphinxcode{CHAR} datatype.
\end{quote}

\sphinxcode{\textless{}varchar\_val\textgreater{}}
\begin{quote}

Updates the default value for columns of the \sphinxcode{VARCHAR2} datatype.
\end{quote}

\sphinxcode{\textless{}nchar\_val\textgreater{}}
\begin{quote}

The \sphinxcode{nchar\_val} is mapped to \sphinxcode{CHAR} datatype and returns the \sphinxcode{CHAR} value.
\end{quote}

\sphinxcode{\textless{}nvarchar\_val\textgreater{}}
\begin{quote}

The \sphinxcode{nvarchar\_val} is mapped to \sphinxcode{VARCHAR2} datatype and returns the \sphinxcode{VARCHAR}
value.
\end{quote}

\sphinxcode{\textless{}datecol\_val\textgreater{}}
\begin{quote}

Updates the default value for columns of the \sphinxcode{DATE} datatype.
\end{quote}

\sphinxcode{\textless{}ts\_val\textgreater{}}
\begin{quote}

Updates the default value for columns of the \sphinxcode{TIMESTAMP} datatype.
\end{quote}

\sphinxcode{\textless{}tswtz\_val\textgreater{}}
\begin{quote}

Updates the default value for columns of the \sphinxcode{TIMESTAMPTZ} datatype.
\end{quote}

\newpage

\sphinxcode{\textless{}blob\_val\textgreater{}}
\begin{quote}

Updates the default value for columns of the \sphinxcode{BLOB} datatype.
\end{quote}

\sphinxcode{\textless{}clob\_val\textgreater{}}
\begin{quote}

Updates the default value for columns of the \sphinxcode{CLOB} datatype.
\end{quote}

\sphinxcode{\textless{}nclob\_val\textgreater{}}
\begin{quote}

The \sphinxcode{nclob\_val} is mapped to \sphinxcode{CLOB} datatype and returns the \sphinxcode{CLOB} value.
\end{quote}

\sphinxstylestrong{Example}

The following example illustrates how to update the full redaction
values but before updating the values, you can:

1. View the default values using \sphinxcode{redaction\_values\_for\_type\_full} view
as shown below:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
edb=\PYGZsh{} \PYGZbs{}x
Expanded display is on.
edb=\PYGZsh{} SELECT number\PYGZus{}value, char\PYGZus{}value, varchar\PYGZus{}value, date\PYGZus{}value,
       timestamp\PYGZus{}value, timestamp\PYGZus{}with\PYGZus{}time\PYGZus{}zone\PYGZus{}value, blob\PYGZus{}value, clob\PYGZus{}value
FROM redaction\PYGZus{}values\PYGZus{}for\PYGZus{}type\PYGZus{}full;
\PYGZhy{}[ RECORD 1 ]\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
number\PYGZus{}value                   \textbar{} 0
char\PYGZus{}value                     \textbar{}
varchar\PYGZus{}value                  \textbar{}
date\PYGZus{}value                     \textbar{} 01\PYGZhy{}JAN\PYGZhy{}01 00:00:00
timestamp\PYGZus{}value                \textbar{} 01\PYGZhy{}JAN\PYGZhy{}01 01:00:00
timestamp\PYGZus{}with\PYGZus{}time\PYGZus{}zone\PYGZus{}value \textbar{} 31\PYGZhy{}DEC\PYGZhy{}00 20:00:00 \PYGZhy{}05:00
blob\PYGZus{}value                     \textbar{} \PYGZbs{}x5b72656461637465645d
clob\PYGZus{}value                     \textbar{} [redacted]
(1 row)
\end{sphinxVerbatim}

2. Now, update the default values for full redaction type. The NULL values will be ignored.
c edb base\_user

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
edb=\PYGZsh{} BEGIN
    DBMS\PYGZus{}REDACT.update\PYGZus{}full\PYGZus{}redaction\PYGZus{}values (
    number\PYGZus{}val =\PYGZgt{} 9999999,
    char\PYGZus{}val =\PYGZgt{} \PYGZsq{}Z\PYGZsq{},
    varchar\PYGZus{}val =\PYGZgt{} \PYGZsq{}V\PYGZsq{},
    datecol\PYGZus{}val =\PYGZgt{} to\PYGZus{}date(\PYGZsq{}17/10/2018\PYGZsq{}, \PYGZsq{}DD/MM/YYYY\PYGZsq{}),
    ts\PYGZus{}val =\PYGZgt{} to\PYGZus{}timestamp(\PYGZsq{}17/10/2018 11:12:13\PYGZsq{}, \PYGZsq{}DD/MM/YYYY HH24:MI:SS\PYGZsq{}),
    tswtz\PYGZus{}val =\PYGZgt{} NULL,
    blob\PYGZus{}val =\PYGZgt{} \PYGZsq{}NEW REDACTED VALUE\PYGZsq{},
    clob\PYGZus{}val =\PYGZgt{} \PYGZsq{}NEW REDACTED VALUE\PYGZsq{});
END;
\end{sphinxVerbatim}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
You can now see the updated values using redaction\_values\_for\_type\_full view.

\end{enumerate}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
EDB\PYGZhy{}SPL Procedure successfully completed
edb=\PYGZsh{} SELECT number\PYGZus{}value, char\PYGZus{}value, varchar\PYGZus{}value, date\PYGZus{}value,
       timestamp\PYGZus{}value, timestamp\PYGZus{}with\PYGZus{}time\PYGZus{}zone\PYGZus{}value, blob\PYGZus{}value, clob\PYGZus{}value
FROM redaction\PYGZus{}values\PYGZus{}for\PYGZus{}type\PYGZus{}full;
\PYGZhy{}[ RECORD 1 ]\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
number\PYGZus{}value                   \textbar{} 9999999
char\PYGZus{}value                     \textbar{} Z
varchar\PYGZus{}value                  \textbar{} V
date\PYGZus{}value                     \textbar{} 17\PYGZhy{}OCT\PYGZhy{}18 00:00:00
timestamp\PYGZus{}value                \textbar{} 17\PYGZhy{}OCT\PYGZhy{}18 11:12:13
timestamp\PYGZus{}with\PYGZus{}time\PYGZus{}zone\PYGZus{}value \textbar{} 31\PYGZhy{}DEC\PYGZhy{}00 20:00:00 \PYGZhy{}05:00
blob\PYGZus{}value                     \textbar{} \PYGZbs{}x4e45572052454441435445442056414c5545
clob\PYGZus{}value                     \textbar{} NEW REDACTED VALUE
(1 row)
\end{sphinxVerbatim}

Redacted Result:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
edb=\PYGZsh{} \PYGZbs{}c edb redact\PYGZus{}user
You are now connected to database \PYGZdq{}edb\PYGZdq{} as user \PYGZdq{}redact\PYGZus{}user\PYGZdq{}.
edb=\PYGZgt{} select * from payment\PYGZus{}details\PYGZus{}tab order by 1;
 customer\PYGZus{}id \textbar{} card\PYGZus{}string
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
     9999999 \textbar{} V
     9999999 \textbar{} V
(2 rows)
\end{sphinxVerbatim}

\newpage


\section{\index{DBMS\_RLS}DBMS\_RLS}
\label{\detokenize{dbms_rls::doc}}\label{\detokenize{dbms_rls:dbms-rls}}
The \sphinxcode{DBMS\_RLS} package enables the implementation of Virtual Private
Database on certain Advanced Server database objects.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|\Y{0.4}|\Y{0.2}|\Y{0.1}|\Y{0.3}|}
\hline

Function/Procedure
&
Function or Procedure
&
Return Type
&
Description
\\
\hline
ADD\_POLICY(\textless{}object\_schema\textgreater{}, \textless{}object\_name\textgreater{}, \textless{}policy\_name\textgreater{}, \textless{}function\_schema\textgreater{}, \textless{}policy\_function\textgreater{} {[}, \textless{}statement\_types\textgreater{} {[}, \textless{}update\_check\textgreater{} {[}, \textless{}enable\textgreater{} {[}, \textless{}static\_policy\textgreater{} {[}, \textless{}policy\_type\textgreater{} {[}, \textless{}long\_predicate\textgreater{} {[}, \textless{}sec\_relevant\_cols\textgreater{} {[}, \textless{}sec\_relevant\_cols\_opt\textgreater{} {]}{]}{]}{]}{]}{]}{]}{]})
&
Procedure
&
n/a
&
Add a security policy to a database object.
\\
\hline
DROP\_POLICY(\textless{}object\_schema\textgreater{}, \textless{}object\_name\textgreater{}, \textless{}policy\_name\textgreater{})
&
Procedure
&
n/a
&
Remove a security policy from a database object.
\\
\hline
ENABLE\_POLICY(\textless{}object\_schema\textgreater{}, \textless{}object\_name\textgreater{}, \textless{}policy\_name\textgreater{}, \textless{}enable\textgreater{})
&
Procedure
&
n/a
&
Enable or disable a security policy.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Advanced Server’s implementation of \sphinxcode{DBMS\_RLS} is a partial
implementation when compared to Oracle’s version. Only those functions
and procedures listed in the table above are supported.

\sphinxstyleemphasis{Virtual Private Database} is a type of fine-grained access control
using security policies. \sphinxstyleemphasis{Fine-grained access control} in Virtual
Private Database means that access to data can be controlled down to
specific rows as defined by the security policy.

The rules that encode a security policy are defined in a \sphinxstyleemphasis{policy
function}, which is an SPL function with certain input parameters and
return value. The \sphinxstyleemphasis{security policy} is the named association of the
policy function to a particular database object, typically a table.

\begin{sphinxadmonition}{note}{Note:}
In Advanced Server, the policy function can be written in any language supported by Advanced Server such as SQL, PL/pgSQL and SPL.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
The database objects currently supported by Advanced Server Virtual Private Database are tables. Policies cannot be applied to views or synonyms.
\end{sphinxadmonition}

The advantages of using Virtual Private Database are the following:
\begin{itemize}
\item {} 
Provides a fine-grained level of security. Database object level
privileges given by the \sphinxcode{GRANT} command determine access privileges to
the entire instance of a database object, while Virtual Private
Database provides access control for the individual rows of a
database object instance.

\item {} 
A different security policy can be applied depending upon the type of
SQL command (\sphinxcode{INSERT, UPDATE, DELETE, or SELECT}).

\item {} 
The security policy can vary dynamically for each applicable SQL
command affecting the database object depending upon factors such as
the session user of the application accessing the database object.

\item {} 
Invocation of the security policy is transparent to all applications
that access the database object and thus, individual applications do
not have to be modified to apply the security policy.

\item {} 
Once a security policy is enabled, it is not possible for any
application (including new applications) to circumvent the security
policy except by the system privilege noted by the following.

\item {} 
Even superusers cannot circumvent the security policy except by the
system privilege noted by the following.

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
The only way security policies can be circumvented is if the \sphinxcode{EXEMPT ACCESS POLICY} system privilege has been granted to a user. The \sphinxcode{EXEMPT ACCESS POLICY} privilege should be granted with extreme care as a user with this privilege is exempted from all policies in the database.
\end{sphinxadmonition}

The \sphinxcode{DBMS\_RLS} package provides procedures to create policies, remove
policies, enable policies, and disable policies.

The process for implementing Virtual Private Database is as follows:
\begin{itemize}
\item {} 
Create a policy function. The function must have two input parameters
of type \sphinxcode{VARCHAR2}. The first input parameter is for the schema
containing the database object to which the policy is to apply and
the second input parameter is for the name of that database object.
The function must have a \sphinxcode{VARCHAR2} return type. The function must
return a string in the form of a \sphinxcode{WHERE} clause predicate. This
predicate is dynamically appended as an \sphinxcode{AND} condition to the SQL
command that acts upon the database object. Thus, rows that do not
satisfy the policy function predicate are filtered out from the SQL
command result set.

\item {} 
Use the \sphinxcode{ADD\_POLICY} procedure to define a new policy, which is the
association of a policy function with a database object. With the
\sphinxcode{ADD\_POLICY} procedure, you can also specify the types of SQL commands
(\sphinxcode{INSERT, UPDATE, DELETE}, or \sphinxcode{SELECT}) to which the policy is to apply,
whether or not to enable the policy at the time of its creation, and
if the policy should apply to newly inserted rows or the modified
image of updated rows.

\item {} 
Use the \sphinxcode{ENABLE\_POLICY} procedure to disable or enable an existing
policy.

\item {} 
Use the \sphinxcode{DROP\_POLICY} procedure to remove an existing policy. The
\sphinxcode{DROP\_POLICY} procedure does not drop the policy function or the
associated database object.

\end{itemize}

Once policies are created, they can be viewed in the catalog views,
compatible with Oracle databases: \sphinxcode{ALL\_POLICIES, DBA\_POLICIES}, or
\sphinxcode{USER\_POLICIES}. The supported compatible views are listed in the
\sphinxstyleemphasis{Database Compatibility for Oracle Developers Reference Guide},
available at the EnterpriseDB website at:
\begin{quote}

\sphinxurl{https://www.enterprisedb.com/edb-docs/}
\end{quote}

The \sphinxcode{SYS\_CONTEXT} function is often used with \sphinxcode{DBMS\_RLS}. The signature
is:
\begin{quote}

\sphinxcode{SYS\_CONTEXT(\textless{}namespace\textgreater{}, \textless{}attribute\textgreater{})}
\end{quote}

Where:
\begin{quote}

\sphinxcode{\textless{}namespace\textgreater{}} is a \sphinxcode{VARCHAR2}; the only accepted value is \sphinxcode{USERENV}. Any
other value will return \sphinxcode{NULL}.

\sphinxcode{\textless{}attribute\textgreater{}} is a \sphinxcode{VARCHAR2}. \sphinxcode{\textless{}attribute\textgreater{}} may be:
\end{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|\Y{0.4}|\Y{0.6}|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
attribute Value
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Equivalent Value
\unskip}\relax \\
\hline
SESSION\_USER
&
pg\_catalog.session\_user
\\
\hline
CURRENT\_USER
&
pg\_catalog.current\_user
\\
\hline
CURRENT\_SCHEMA
&
pg\_catalog.current\_schema
\\
\hline
HOST
&
pg\_catalog.inet\_host
\\
\hline
IP\_ADDRESS
&
pg\_catalog.inet\_client\_addr
\\
\hline
SERVER\_HOST
&
pg\_catalog.inet\_server\_addr
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{sphinxadmonition}{note}{Note:}
The examples used to illustrate the \sphinxcode{DBMS\_RLS} package are based on a modified copy of the sample \sphinxcode{emp} table provided with Advanced Server along with a role named \sphinxcode{salesmgr} that is granted all privileges on the table. You can create the modified copy of the \sphinxcode{emp} table named \sphinxcode{vpemp} and the \sphinxcode{salesmgr} role as shown by the following:
\end{sphinxadmonition}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
CREATE TABLE public.vpemp AS SELECT empno, ename, job, sal, comm, deptno FROM emp;
ALTER TABLE vpemp ADD authid VARCHAR2(12);
UPDATE vpemp SET authid = \PYGZsq{}researchmgr\PYGZsq{} WHERE deptno = 20;
UPDATE vpemp SET authid = \PYGZsq{}salesmgr\PYGZsq{} WHERE deptno = 30;
SELECT * FROM vpemp;

empno \textbar{} ename  \textbar{}    job    \textbar{}   sal   \textbar{}  comm   \textbar{} deptno \textbar{}   authid
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
  7782 \textbar{} CLARK  \textbar{} MANAGER   \textbar{} 2450.00 \textbar{}         \textbar{}     10 \textbar{}
  7839 \textbar{} KING   \textbar{} PRESIDENT \textbar{} 5000.00 \textbar{}         \textbar{}     10 \textbar{}
  7934 \textbar{} MILLER \textbar{} CLERK     \textbar{} 1300.00 \textbar{}         \textbar{}     10 \textbar{}
  7369 \textbar{} SMITH  \textbar{} CLERK     \textbar{}  800.00 \textbar{}         \textbar{}     20 \textbar{} researchmgr
  7566 \textbar{} JONES  \textbar{} MANAGER   \textbar{} 2975.00 \textbar{}         \textbar{}     20 \textbar{} researchmgr
  7788 \textbar{} SCOTT  \textbar{} ANALYST   \textbar{} 3000.00 \textbar{}         \textbar{}     20 \textbar{} researchmgr
  7876 \textbar{} ADAMS  \textbar{} CLERK     \textbar{} 1100.00 \textbar{}         \textbar{}     20 \textbar{} researchmgr
  7902 \textbar{} FORD   \textbar{} ANALYST   \textbar{} 3000.00 \textbar{}         \textbar{}     20 \textbar{} researchmgr
  7499 \textbar{} ALLEN  \textbar{} SALESMAN  \textbar{} 1600.00 \textbar{}  300.00 \textbar{}     30 \textbar{} salesmgr
  7521 \textbar{} WARD   \textbar{} SALESMAN  \textbar{} 1250.00 \textbar{}  500.00 \textbar{}     30 \textbar{} salesmgr
  7654 \textbar{} MARTIN \textbar{} SALESMAN  \textbar{} 1250.00 \textbar{} 1400.00 \textbar{}     30 \textbar{} salesmgr
  7698 \textbar{} BLAKE  \textbar{} MANAGER   \textbar{} 2850.00 \textbar{}         \textbar{}     30 \textbar{} salesmgr
  7844 \textbar{} TURNER \textbar{} SALESMAN  \textbar{} 1500.00 \textbar{}    0.00 \textbar{}     30 \textbar{} salesmgr
  7900 \textbar{} JAMES  \textbar{} CLERK     \textbar{}  950.00 \textbar{}         \textbar{}     30 \textbar{} salesmgr
(14 rows)

CREATE ROLE salesmgr WITH LOGIN PASSWORD \PYGZsq{}password\PYGZsq{};
GRANT ALL ON vpemp TO salesmgr;
\end{sphinxVerbatim}

\newpage

\index{DBMS\_RLSADD\_POLICY:}\ignorespaces 

\subsection{ADD\_POLICY}
\label{\detokenize{dbms_rls:add-policy}}\label{\detokenize{dbms_rls:index-1}}
The \sphinxcode{ADD\_POLICY} procedure creates a new policy by associating a policy
function with a database object.

You must be a superuser to execute this procedure.
\begin{quote}

\sphinxcode{ADD\_POLICY(\textless{}object\_schema\textgreater{} VARCHAR2, \textless{}object\_name\textgreater{} VARCHAR2,}
\begin{quote}

\sphinxcode{\textless{}policy\_name\textgreater{} VARCHAR2, \textless{}function\_schema\textgreater{} VARCHAR2},

\sphinxcode{\textless{}policy\_function\textgreater{} VARCHAR2}

\sphinxcode{{[}, \textless{}statement\_types\textgreater{} VARCHAR2}

\sphinxcode{{[}, \textless{}update\_check\textgreater{} BOOLEAN}

\sphinxcode{{[}, \textless{}enable\textgreater{} BOOLEAN}

\sphinxcode{{[}, \textless{}static\_policy\textgreater{} BOOLEAN}

\sphinxcode{{[}, \textless{}policy\_type\textgreater{} INTEGER}

\sphinxcode{{[}, \textless{}long\_predicate\textgreater{} BOOLEAN}

\sphinxcode{{[}, \textless{}sec\_relevant\_cols\textgreater{} VARCHAR2}

\sphinxcode{{[}, \textless{}sec\_relevant\_cols\_opt\textgreater{} INTEGER {]}{]}{]}{]}{]}{]}{]}{]})}
\end{quote}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}object\_schema\textgreater{}}
\begin{quote}

Name of the schema containing the database object to which the policy is
to be applied.
\end{quote}

\sphinxcode{\textless{}object\_name\textgreater{}}
\begin{quote}

Name of the database object to which the policy is to be applied. A
given database object may have more than one policy applied to it.
\end{quote}

\sphinxcode{\textless{}policy\_name\textgreater{}}
\begin{quote}

Name assigned to the policy. The combination of database object
(identified by \sphinxcode{\textless{}object\_schema\textgreater{}} and \sphinxcode{\textless{}object\_name\textgreater{}}) and policy name must
be unique within the database.
\end{quote}

\sphinxcode{\textless{}function\_schema\textgreater{}}
\begin{quote}

Name of the schema containing the policy function.
\begin{quote}

\begin{sphinxadmonition}{note}{Note:}
The policy function may belong to a package in which case \sphinxcode{\textless{}function\_schema\textgreater{}} must contain the name of the schema in which the package is defined.
\end{sphinxadmonition}
\end{quote}
\end{quote}

\sphinxcode{\textless{}policy\_function\textgreater{}}
\begin{quote}

Name of the SPL function that defines the rules of the security policy.
The same function may be specified in more than one policy.

\begin{sphinxadmonition}{note}{Note:}
The policy function may belong to a package in which case \sphinxcode{\textless{}policy\_function\textgreater{}} must also contain the package name in dot notation (that is, \sphinxcode{\textless{}package\_name\textgreater{}.\textless{}function\_name\textgreater{}}).
\end{sphinxadmonition}
\end{quote}

\newpage

\sphinxcode{\textless{}statement\_types\textgreater{}}
\begin{quote}

Comma-separated list of SQL commands to which the policy applies. Valid
SQL commands are \sphinxcode{INSERT, UPDATE, DELETE}, and \sphinxcode{SELECT}. The default is
\sphinxcode{INSERT,UPDATE,DELETE,SELECT}.

\begin{sphinxadmonition}{note}{Note:}
Advanced Server accepts \sphinxcode{INDEX} as a statement type, but it is ignored. Policies are not applied to index operations in Advanced Server.
\end{sphinxadmonition}
\end{quote}

\sphinxcode{\textless{}update\_check\textgreater{}}
\begin{quote}

Applies to \sphinxcode{INSERT} and \sphinxcode{UPDATE} SQL commands only.

When set to \sphinxcode{TRUE}, the policy is applied to newly inserted rows and to
the modified image of updated rows. If any of the new or modified rows
do not qualify according to the policy function predicate, then the
\sphinxcode{INSERT} or \sphinxcode{UPDATE} command throws an exception and no rows are inserted or
modified by the \sphinxcode{INSERT} or \sphinxcode{UPDATE} command.

When set to \sphinxcode{FALSE}, the policy is not applied to newly inserted rows or
the modified image of updated rows. Thus, a newly inserted row may not
appear in the result set of a subsequent SQL command that invokes the
same policy. Similarly, rows which qualified according to the policy
prior to an \sphinxcode{UPDATE} command may not appear in the result set of a
subsequent SQL command that invokes the same policy.

The default is \sphinxcode{FALSE}.
\end{quote}

\sphinxcode{\textless{}enable\textgreater{}}
\begin{quote}

When set to \sphinxcode{TRUE}, the policy is enabled and applied to the SQL commands
given by the \sphinxcode{\textless{}statement\_types\textgreater{}} parameter. When set to \sphinxcode{FALSE} the policy
is disabled and not applied to any SQL commands. The policy can be
enabled using the \sphinxcode{ENABLE\_POLICY} procedure. The default is \sphinxcode{TRUE}.
\end{quote}

\sphinxcode{\textless{}static\_policy\textgreater{}}
\begin{quote}

In Oracle, when set to \sphinxcode{TRUE}, the policy is \sphinxstyleemphasis{static}, which means the
policy function is evaluated once per database object the first time it
is invoked by a policy on that database object. The resulting policy
function predicate string is saved in memory and reused for all
invocations of that policy on that database object while the database
server instance is running.

When set to FALSE, the policy is \sphinxstyleemphasis{dynamic}, which means the policy
function is re-evaluated and the policy function predicate string
regenerated for all invocations of the policy.

The default is \sphinxcode{FALSE}.

\begin{sphinxadmonition}{note}{Note:}
In Oracle 10g, the \sphinxcode{\textless{}policy\_type\textgreater{}} parameter was introduced, which is intended to replace the \sphinxcode{\textless{}static\_policy\textgreater{}} parameter. In Oracle, if the \sphinxcode{\textless{}policy\_type\textgreater{}} parameter is not set to its default value of \sphinxcode{NULL}, the \sphinxcode{\textless{}policy\_type\textgreater{}} parameter setting overrides the \sphinxcode{\textless{}static\_policy\textgreater{}} setting.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
The setting of \sphinxcode{\textless{}static\_policy\textgreater{}} is ignored by Advanced Server. Advanced Server implements only the dynamic policy, regardless of the setting of the \sphinxcode{\textless{}static\_policy\textgreater{}} parameter.
\end{sphinxadmonition}
\end{quote}

\newpage

\sphinxcode{\textless{}policy\_type\textgreater{}}
\begin{quote}

In Oracle, determines when the policy function is re-evaluated, and
hence, if and when the predicate string returned by the policy function
changes. The default is \sphinxcode{NULL}.

\begin{sphinxadmonition}{note}{Note:}
The setting of this parameter is ignored by Advanced Server. Advanced Server always assumes a dynamic policy.
\end{sphinxadmonition}
\end{quote}

\sphinxcode{\textless{}long\_predicate\textgreater{}}
\begin{quote}

In Oracle, allows predicates up to 32K bytes if set to \sphinxcode{TRUE}, otherwise
predicates are limited to 4000 bytes. The default is \sphinxcode{FALSE}.

\begin{sphinxadmonition}{note}{Note:}
The setting of this parameter is ignored by Advanced Server. An Advanced Server policy function can return a predicate of unlimited length for all practical purposes.
\end{sphinxadmonition}
\end{quote}

\sphinxcode{\textless{}sec\_relevant\_cols\textgreater{}}
\begin{quote}

Comma-separated list of columns of \sphinxcode{\textless{}object\_name\textgreater{}}. Provides
\sphinxstyleemphasis{column-level Virtual Private Database} for the listed columns. The
policy is enforced if any of the listed columns are referenced in a SQL
command of a type listed in \sphinxcode{\textless{}statement\_types\textgreater{}}. The policy is not
enforced if no such columns are referenced.

The default is \sphinxcode{NULL}, which has the same effect as if all of the database
object’s columns were included in \sphinxcode{\textless{}sec\_relevant\_cols\textgreater{}}.
\end{quote}

\sphinxcode{\textless{}sec\_relevant\_cols\_opt\textgreater{}}
\begin{quote}

In Oracle, if \sphinxcode{\textless{}sec\_relevant\_cols\_opt\textgreater{}} is set to \sphinxcode{DBMS\_RLS.ALL\_ROWS
(INTEGER} constant of value 1), then the columns listed in
\sphinxcode{\textless{}sec\_relevant\_cols\textgreater{}} return \sphinxcode{NULL} on all rows where the applied policy
predicate is false. (If \sphinxcode{\textless{}sec\_relevant\_cols\_opt\textgreater{}} is not set to
\sphinxcode{DBMS\_RLS.ALL\_ROWS}, these rows would not be returned at all in the
result set.) The default is \sphinxcode{NULL}.

\begin{sphinxadmonition}{note}{Note:}
Advanced Server does not support the \sphinxcode{DBMS\_RLS.ALL\_ROWS} functionality. Advanced Server throws an error if \sphinxcode{sec\_relevant\_cols\_opt} is set to \sphinxcode{DBMS\_RLS.ALL\_ROWS (INTEGER} value of 1).
\end{sphinxadmonition}
\end{quote}

\sphinxstylestrong{Examples}

This example uses the following policy function:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
CREATE OR REPLACE FUNCTION verify\PYGZus{}session\PYGZus{}user (
    p\PYGZus{}schema        VARCHAR2,
    p\PYGZus{}object        VARCHAR2
)
RETURN VARCHAR2
IS
BEGIN
    RETURN \PYGZsq{}authid = SYS\PYGZus{}CONTEXT(\PYGZsq{}\PYGZsq{}USERENV\PYGZsq{}\PYGZsq{}, \PYGZsq{}\PYGZsq{}SESSION\PYGZus{}USER\PYGZsq{}\PYGZsq{})\PYGZsq{};
END;
\end{sphinxVerbatim}

This function generates the predicate \sphinxcode{authid = SYS\_CONTEXT('USERENV',
'SESSION\_USER')}, which is added to the \sphinxcode{WHERE} clause of any SQL command
of the type specified in the \sphinxcode{ADD\_POLICY} procedure.

This limits the effect of the SQL command to those rows where the
content of the \sphinxcode{authid} column is the same as the session user.

\begin{sphinxadmonition}{note}{Note:}
This example uses the \sphinxcode{SYS\_CONTEXT} function to return the login user name. In Oracle the \sphinxcode{SYS\_CONTEXT} function is used to return attributes of an \sphinxstyleemphasis{application context}. The first parameter of the \sphinxcode{SYS\_CONTEXT} function is the name of an application context while the second parameter is the name of an attribute set within the application context. \sphinxcode{USERENV} is a special built-in namespace that describes the current session. Advanced Server does not support application contexts, but only this specific usage of the \sphinxcode{SYS\_CONTEXT} function.
\end{sphinxadmonition}

The following anonymous block calls the \sphinxcode{ADD\_POLICY} procedure to create
a policy named \sphinxcode{secure\_update} to be applied to the \sphinxcode{vpemp} table using
function \sphinxcode{verify\_session\_user} whenever an \sphinxcode{INSERT, UPDATE}, or \sphinxcode{DELETE SQL}
command is given referencing the \sphinxcode{vpemp} table.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    v\PYGZus{}object\PYGZus{}schema         VARCHAR2(30) := \PYGZsq{}public\PYGZsq{};
    v\PYGZus{}object\PYGZus{}name           VARCHAR2(30) := \PYGZsq{}vpemp\PYGZsq{};
    v\PYGZus{}policy\PYGZus{}name           VARCHAR2(30) := \PYGZsq{}secure\PYGZus{}update\PYGZsq{};
    v\PYGZus{}function\PYGZus{}schema       VARCHAR2(30) := \PYGZsq{}enterprisedb\PYGZsq{};
    v\PYGZus{}policy\PYGZus{}function       VARCHAR2(30) := \PYGZsq{}verify\PYGZus{}session\PYGZus{}user\PYGZsq{};
    v\PYGZus{}statement\PYGZus{}types       VARCHAR2(30) := \PYGZsq{}INSERT,UPDATE,DELETE\PYGZsq{};
    v\PYGZus{}update\PYGZus{}check          BOOLEAN      := TRUE;
    v\PYGZus{}enable                BOOLEAN      := TRUE;
BEGIN
    DBMS\PYGZus{}RLS.ADD\PYGZus{}POLICY(
        v\PYGZus{}object\PYGZus{}schema,
        v\PYGZus{}object\PYGZus{}name,
        v\PYGZus{}policy\PYGZus{}name,
        v\PYGZus{}function\PYGZus{}schema,
        v\PYGZus{}policy\PYGZus{}function,
        v\PYGZus{}statement\PYGZus{}types,
        v\PYGZus{}update\PYGZus{}check,
        v\PYGZus{}enable
    );
END;
\end{sphinxVerbatim}

After successful creation of the policy, a terminal session is started
by user \sphinxcode{salesmgr}. The following query shows the content of the \sphinxcode{vpemp}
table:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
edb=\PYGZsh{} \PYGZbs{}c edb salesmgr
Password for user salesmgr:
You are now connected to database \PYGZdq{}edb\PYGZdq{} as user \PYGZdq{}salesmgr\PYGZdq{}.
edb=\PYGZgt{} SELECT * FROM vpemp;
 empno \textbar{} ename  \textbar{}    job    \textbar{}   sal   \textbar{}  comm   \textbar{} deptno \textbar{}   authid
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
  7782 \textbar{} CLARK  \textbar{} MANAGER   \textbar{} 2450.00 \textbar{}         \textbar{}     10 \textbar{}
  7839 \textbar{} KING   \textbar{} PRESIDENT \textbar{} 5000.00 \textbar{}         \textbar{}     10 \textbar{}
  7934 \textbar{} MILLER \textbar{} CLERK     \textbar{} 1300.00 \textbar{}         \textbar{}     10 \textbar{}
  7369 \textbar{} SMITH  \textbar{} CLERK     \textbar{}  800.00 \textbar{}         \textbar{}     20 \textbar{} researchmgr
  7566 \textbar{} JONES  \textbar{} MANAGER   \textbar{} 2975.00 \textbar{}         \textbar{}     20 \textbar{} researchmgr
  7788 \textbar{} SCOTT  \textbar{} ANALYST   \textbar{} 3000.00 \textbar{}         \textbar{}     20 \textbar{} researchmgr
  7876 \textbar{} ADAMS  \textbar{} CLERK     \textbar{} 1100.00 \textbar{}         \textbar{}     20 \textbar{} researchmgr
  7902 \textbar{} FORD   \textbar{} ANALYST   \textbar{} 3000.00 \textbar{}         \textbar{}     20 \textbar{} researchmgr
  7499 \textbar{} ALLEN  \textbar{} SALESMAN  \textbar{} 1600.00 \textbar{}  300.00 \textbar{}     30 \textbar{} salesmgr
  7521 \textbar{} WARD   \textbar{} SALESMAN  \textbar{} 1250.00 \textbar{}  500.00 \textbar{}     30 \textbar{} salesmgr
  7654 \textbar{} MARTIN \textbar{} SALESMAN  \textbar{} 1250.00 \textbar{} 1400.00 \textbar{}     30 \textbar{} salesmgr
  7698 \textbar{} BLAKE  \textbar{} MANAGER   \textbar{} 2850.00 \textbar{}         \textbar{}     30 \textbar{} salesmgr
  7844 \textbar{} TURNER \textbar{} SALESMAN  \textbar{} 1500.00 \textbar{}    0.00 \textbar{}     30 \textbar{} salesmgr
  7900 \textbar{} JAMES  \textbar{} CLERK     \textbar{}  950.00 \textbar{}         \textbar{}     30 \textbar{} salesmgr
(14 rows)
\end{sphinxVerbatim}

An unqualified \sphinxcode{UPDATE} command (no \sphinxcode{WHERE} clause) is issued by the
\sphinxcode{salesmgr} user:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
edb=\PYGZgt{} UPDATE vpemp SET comm = sal * .75;
UPDATE 6
\end{sphinxVerbatim}

Instead of updating all rows in the table, the policy restricts the
effect of the update to only those rows where the \sphinxcode{authid} column contains
the value \sphinxcode{salesmgr} as specified by the policy function predicate \sphinxcode{authid
= SYS\_CONTEXT('USERENV', 'SESSION\_USER')}.

The following query shows that the \sphinxcode{comm} column has been changed only for
those rows where \sphinxcode{authid} contains \sphinxcode{salesmgr}. All other rows are unchanged.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
edb=\PYGZgt{} SELECT * FROM vpemp;
 empno \textbar{} ename  \textbar{}    job    \textbar{}   sal   \textbar{}  comm   \textbar{} deptno \textbar{}   authid
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
  7782 \textbar{} CLARK  \textbar{} MANAGER   \textbar{} 2450.00 \textbar{}         \textbar{}     10 \textbar{}
  7839 \textbar{} KING   \textbar{} PRESIDENT \textbar{} 5000.00 \textbar{}         \textbar{}     10 \textbar{}
  7934 \textbar{} MILLER \textbar{} CLERK     \textbar{} 1300.00 \textbar{}         \textbar{}     10 \textbar{}
  7369 \textbar{} SMITH  \textbar{} CLERK     \textbar{}  800.00 \textbar{}         \textbar{}     20 \textbar{} researchmgr
  7566 \textbar{} JONES  \textbar{} MANAGER   \textbar{} 2975.00 \textbar{}         \textbar{}     20 \textbar{} researchmgr
  7788 \textbar{} SCOTT  \textbar{} ANALYST   \textbar{} 3000.00 \textbar{}         \textbar{}     20 \textbar{} researchmgr
  7876 \textbar{} ADAMS  \textbar{} CLERK     \textbar{} 1100.00 \textbar{}         \textbar{}     20 \textbar{} researchmgr
  7902 \textbar{} FORD   \textbar{} ANALYST   \textbar{} 3000.00 \textbar{}         \textbar{}     20 \textbar{} researchmgr
  7499 \textbar{} ALLEN  \textbar{} SALESMAN  \textbar{} 1600.00 \textbar{} 1200.00 \textbar{}     30 \textbar{} salesmgr
  7521 \textbar{} WARD   \textbar{} SALESMAN  \textbar{} 1250.00 \textbar{}  937.50 \textbar{}     30 \textbar{} salesmgr
  7654 \textbar{} MARTIN \textbar{} SALESMAN  \textbar{} 1250.00 \textbar{}  937.50 \textbar{}     30 \textbar{} salesmgr
  7698 \textbar{} BLAKE  \textbar{} MANAGER   \textbar{} 2850.00 \textbar{} 2137.50 \textbar{}     30 \textbar{} salesmgr
  7844 \textbar{} TURNER \textbar{} SALESMAN  \textbar{} 1500.00 \textbar{} 1125.00 \textbar{}     30 \textbar{} salesmgr
  7900 \textbar{} JAMES  \textbar{} CLERK     \textbar{}  950.00 \textbar{}  712.50 \textbar{}     30 \textbar{} salesmgr
(14 rows)
\end{sphinxVerbatim}

Furthermore, since the \sphinxcode{\textless{}update\_check\textgreater{}} parameter was set to \sphinxcode{TRUE} in the
\sphinxcode{ADD\_POLICY} procedure, the following \sphinxcode{INSERT} command throws an exception
since the value given for the \sphinxcode{authid} column, \sphinxcode{researchmgr}, does not match
the session user, which is \sphinxcode{salesmgr}, and hence, fails the policy.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
edb=\PYGZgt{} INSERT INTO vpemp VALUES (9001,\PYGZsq{}SMITH\PYGZsq{},\PYGZsq{}ANALYST\PYGZsq{},3200.00,NULL,20, \PYGZsq{}researchmgr\PYGZsq{});
ERROR:  policy with check option violation
DETAIL:  Policy predicate was evaluated to FALSE with the updated values
\end{sphinxVerbatim}

If \sphinxcode{\textless{}update\_check\textgreater{}} was set to \sphinxcode{FALSE}, the preceding \sphinxcode{INSERT} command would
have succeeded.

The following example illustrates the use of the \sphinxcode{\textless{}sec\_relevant\_cols\textgreater{}}
parameter to apply a policy only when certain columns are referenced in
the SQL command. The following policy function is used for this example,
which selects rows where the employee salary is less than \sphinxcode{2000}.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
CREATE OR REPLACE FUNCTION sal\PYGZus{}lt\PYGZus{}2000 (
    p\PYGZus{}schema        VARCHAR2,
    p\PYGZus{}object        VARCHAR2
)
RETURN VARCHAR2
IS
BEGIN
    RETURN \PYGZsq{}sal \PYGZlt{} 2000\PYGZsq{};
END
\end{sphinxVerbatim}

\newpage

The policy is created so that it is enforced only if a \sphinxcode{SELECT} command
includes columns \sphinxcode{sal} or \sphinxcode{comm}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    v\PYGZus{}object\PYGZus{}schema         VARCHAR2(30) := \PYGZsq{}public\PYGZsq{};
    v\PYGZus{}object\PYGZus{}name           VARCHAR2(30) := \PYGZsq{}vpemp\PYGZsq{};
    v\PYGZus{}policy\PYGZus{}name           VARCHAR2(30) := \PYGZsq{}secure\PYGZus{}salary\PYGZsq{};
    v\PYGZus{}function\PYGZus{}schema       VARCHAR2(30) := \PYGZsq{}enterprisedb\PYGZsq{};
    v\PYGZus{}policy\PYGZus{}function       VARCHAR2(30) := \PYGZsq{}sal\PYGZus{}lt\PYGZus{}2000\PYGZsq{};
    v\PYGZus{}statement\PYGZus{}types       VARCHAR2(30) := \PYGZsq{}SELECT\PYGZsq{};
    v\PYGZus{}sec\PYGZus{}relevant\PYGZus{}cols     VARCHAR2(30) := \PYGZsq{}sal,comm\PYGZsq{};
BEGIN
    DBMS\PYGZus{}RLS.ADD\PYGZus{}POLICY(
        v\PYGZus{}object\PYGZus{}schema,
        v\PYGZus{}object\PYGZus{}name,
        v\PYGZus{}policy\PYGZus{}name,
        v\PYGZus{}function\PYGZus{}schema,
        v\PYGZus{}policy\PYGZus{}function,
        v\PYGZus{}statement\PYGZus{}types,
        sec\PYGZus{}relevant\PYGZus{}cols =\PYGZgt{} v\PYGZus{}sec\PYGZus{}relevant\PYGZus{}cols
    );
END;
\end{sphinxVerbatim}

If a query does not reference columns \sphinxcode{sal} or \sphinxcode{comm}, then the policy is
not applied. The following query returns all 14 rows of table \sphinxcode{vpemp}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
edb=\PYGZsh{} SELECT empno, ename, job, deptno, authid FROM vpemp;
 empno \textbar{} ename  \textbar{}    job    \textbar{} deptno \textbar{}   authid
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
  7782 \textbar{} CLARK  \textbar{} MANAGER   \textbar{}     10 \textbar{}
  7839 \textbar{} KING   \textbar{} PRESIDENT \textbar{}     10 \textbar{}
  7934 \textbar{} MILLER \textbar{} CLERK     \textbar{}     10 \textbar{}
  7369 \textbar{} SMITH  \textbar{} CLERK     \textbar{}     20 \textbar{} researchmgr
  7566 \textbar{} JONES  \textbar{} MANAGER   \textbar{}     20 \textbar{} researchmgr
  7788 \textbar{} SCOTT  \textbar{} ANALYST   \textbar{}     20 \textbar{} researchmgr
  7876 \textbar{} ADAMS  \textbar{} CLERK     \textbar{}     20 \textbar{} researchmgr
  7902 \textbar{} FORD   \textbar{} ANALYST   \textbar{}     20 \textbar{} researchmgr
  7499 \textbar{} ALLEN  \textbar{} SALESMAN  \textbar{}     30 \textbar{} salesmgr
  7521 \textbar{} WARD   \textbar{} SALESMAN  \textbar{}     30 \textbar{} salesmgr
  7654 \textbar{} MARTIN \textbar{} SALESMAN  \textbar{}     30 \textbar{} salesmgr
  7698 \textbar{} BLAKE  \textbar{} MANAGER   \textbar{}     30 \textbar{} salesmgr
  7844 \textbar{} TURNER \textbar{} SALESMAN  \textbar{}     30 \textbar{} salesmgr
  7900 \textbar{} JAMES  \textbar{} CLERK     \textbar{}     30 \textbar{} salesmgr
(14 rows)
\end{sphinxVerbatim}

\newpage

If the query references the \sphinxcode{sal} or \sphinxcode{comm} columns, then the policy is
applied to the query eliminating any rows where \sphinxcode{sal} is greater than or
equal to \sphinxcode{2000} as shown by the following:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
edb=\PYGZsh{} SELECT empno, ename, job, sal, comm, deptno, authid FROM vpemp;
 empno \textbar{} ename  \textbar{}   job    \textbar{}   sal   \textbar{}  comm   \textbar{} deptno \textbar{}   authid
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
  7934 \textbar{} MILLER \textbar{} CLERK    \textbar{} 1300.00 \textbar{}         \textbar{}     10 \textbar{}
  7369 \textbar{} SMITH  \textbar{} CLERK    \textbar{}  800.00 \textbar{}         \textbar{}     20 \textbar{} researchmgr
  7876 \textbar{} ADAMS  \textbar{} CLERK    \textbar{} 1100.00 \textbar{}         \textbar{}     20 \textbar{} researchmgr
  7499 \textbar{} ALLEN  \textbar{} SALESMAN \textbar{} 1600.00 \textbar{} 1200.00 \textbar{}     30 \textbar{} salesmgr
  7521 \textbar{} WARD   \textbar{} SALESMAN \textbar{} 1250.00 \textbar{}  937.50 \textbar{}     30 \textbar{} salesmgr
  7654 \textbar{} MARTIN \textbar{} SALESMAN \textbar{} 1250.00 \textbar{}  937.50 \textbar{}     30 \textbar{} salesmgr
  7844 \textbar{} TURNER \textbar{} SALESMAN \textbar{} 1500.00 \textbar{} 1125.00 \textbar{}     30 \textbar{} salesmgr
  7900 \textbar{} JAMES  \textbar{} CLERK    \textbar{}  950.00 \textbar{}  712.50 \textbar{}     30 \textbar{} salesmgr
(8 rows)
\end{sphinxVerbatim}

\newpage

\index{DBMS\_RLS\_DROP\_POLICY}\ignorespaces 

\subsection{DROP\_POLICY}
\label{\detokenize{dbms_rls:drop-policy}}\label{\detokenize{dbms_rls:index-2}}
The \sphinxcode{DROP\_POLICY} procedure deletes an existing policy. The policy
function and database object associated with the policy are not deleted
by the \sphinxcode{DROP\_POLICY} procedure.

You must be a superuser to execute this procedure.
\begin{quote}

\sphinxcode{DROP\_POLICY(\textless{}object\_schema\textgreater{} VARCHAR2, \textless{}object\_name\textgreater{} VARCHAR2},

\sphinxcode{\textless{}policy\_name\textgreater{} VARCHAR2)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}object\_schema\textgreater{}}
\begin{quote}

Name of the schema containing the database object to which the policy
applies.
\end{quote}

\sphinxcode{\textless{}object\_name\textgreater{}}
\begin{quote}

Name of the database object to which the policy applies.
\end{quote}

\sphinxcode{\textless{}policy\_name\textgreater{}}
\begin{quote}

Name of the policy to be deleted.
\end{quote}

\sphinxstylestrong{Examples}

The following example deletes policy \sphinxcode{secure\_update} on table
\sphinxcode{public.vpemp}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    v\PYGZus{}object\PYGZus{}schema         VARCHAR2(30) := \PYGZsq{}public\PYGZsq{};
    v\PYGZus{}object\PYGZus{}name           VARCHAR2(30) := \PYGZsq{}vpemp\PYGZsq{};
    v\PYGZus{}policy\PYGZus{}name           VARCHAR2(30) := \PYGZsq{}secure\PYGZus{}update\PYGZsq{};
BEGIN
    DBMS\PYGZus{}RLS.DROP\PYGZus{}POLICY(
        v\PYGZus{}object\PYGZus{}schema,
        v\PYGZus{}object\PYGZus{}name,
        v\PYGZus{}policy\PYGZus{}name
    );
END;
\end{sphinxVerbatim}

\newpage

\index{DBMS\_RLS\_ENABLE\_POLICY}\ignorespaces 

\subsection{ENABLE\_POLICY}
\label{\detokenize{dbms_rls:index-3}}\label{\detokenize{dbms_rls:enable-policy}}
The \sphinxcode{ENABLE\_POLICY} procedure enables or disables an existing policy on
the specified database object.

You must be a superuser to execute this procedure.
\begin{quote}

\sphinxcode{ENABLE\_POLICY(\textless{}object\_schema\textgreater{} VARCHAR2, \textless{}object\_name\textgreater{} VARCHAR2},

\sphinxcode{\textless{}policy\_name\textgreater{} VARCHAR2, \textless{}enable\textgreater{} BOOLEAN)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}object\_schema\textgreater{}}
\begin{quote}

Name of the schema containing the database object to which the policy
applies.
\end{quote}

\sphinxcode{\textless{}object\_name\textgreater{}}
\begin{quote}

Name of the database object to which the policy applies.
\end{quote}

\sphinxcode{\textless{}policy\_name\textgreater{}}
\begin{quote}

Name of the policy to be enabled or disabled.
\end{quote}

\sphinxcode{\textless{}enable\textgreater{}}
\begin{quote}

When set to \sphinxcode{TRUE}, the policy is enabled. When set to \sphinxcode{FALSE}, the policy
is disabled.
\end{quote}

\sphinxstylestrong{Examples}

The following example disables policy secure\_update on table
\sphinxcode{public.vpemp}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    v\PYGZus{}object\PYGZus{}schema         VARCHAR2(30) := \PYGZsq{}public\PYGZsq{};
    v\PYGZus{}object\PYGZus{}name           VARCHAR2(30) := \PYGZsq{}vpemp\PYGZsq{};
    v\PYGZus{}policy\PYGZus{}name           VARCHAR2(30) := \PYGZsq{}secure\PYGZus{}update\PYGZsq{};
    v\PYGZus{}enable                BOOLEAN := FALSE;
BEGIN
    DBMS\PYGZus{}RLS.ENABLE\PYGZus{}POLICY(
        v\PYGZus{}object\PYGZus{}schema,
        v\PYGZus{}object\PYGZus{}name,
        v\PYGZus{}policy\PYGZus{}name,
        v\PYGZus{}enable
    );
END;
\end{sphinxVerbatim}

\newpage


\section{\index{DBMS\_SCHEDULER}DBMS\_SCHEDULER}
\label{\detokenize{dbms_scheduler::doc}}\label{\detokenize{dbms_scheduler:dbms-scheduler}}
The \sphinxcode{DBMS\_SCHEDULER} package provides a way to create and manage
Oracle-styled jobs, programs and job schedules. The \sphinxcode{DBMS\_SCHEDULER}
package implements the following functions and procedures:


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}{|\X{4}{10}|\X{1}{10}|\X{5}{10}|}
\hline

\endfirsthead

\multicolumn{3}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{3}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot

Function/Procedure
&
Return Type
&
Description
\\
\hline
CREATE\_JOB(\textless{}job\_name\textgreater{}, \textless{}job\_type\textgreater{}, \textless{}job\_action\textgreater{}, \textless{}number\_of\_arguments\textgreater{}, \textless{}start\_date\textgreater{}, \textless{}repeat\_interval\textgreater{}, \textless{}end\_date\textgreater{}, \textless{}job\_class\textgreater{}, \textless{}enabled\textgreater{}, \textless{}auto\_drop\textgreater{}, \textless{}comments\textgreater{})
&
n/a
&
Use the first form of the CREATE\_JOB procedure to create a job, specifying program and schedule details by means of parameters.
\\
\hline
CREATE\_JOB(\textless{}job\_name\textgreater{}, \textless{}program\_name\textgreater{}, \textless{}schedule\_name\textgreater{}, \textless{}job\_class\textgreater{}, \textless{}enabled\textgreater{}, \textless{}auto\_drop\textgreater{}, \textless{}comments\textgreater{})
&
n/a
&
Use the second form of CREATE\_JOB to create a job that uses a named program and named schedule.
\\
\hline
CREATE\_PROGRAM(\textless{}program\_name\textgreater{}, \textless{}program\_type\textgreater{}, \textless{}program\_action\textgreater{}, \textless{}number\_of\_arguments\textgreater{}, \textless{}enabled\textgreater{}, \textless{}comments\textgreater{})
&
n/a
&
Use CREATE\_PROGRAM to create a program.
\\
\hline
CREATE\_SCHEDULE(
\textless{}schedule\_name\textgreater{}, \textless{}start\_date\textgreater{}, \textless{}repeat\_interval\textgreater{}, \textless{}end\_date\textgreater{}, \textless{}comments\textgreater{})
&
n/a
&
Use the CREATE\_SCHEDULE procedure to create a schedule.
\\
\hline
DEFINE\_PROGRAM\_ARGUMENT(
\textless{}program\_name\textgreater{}, \textless{}argument\_position\textgreater{}, \textless{}argument\_name\textgreater{}, \textless{}argument\_type\textgreater{}, \textless{}default\_value\textgreater{}, \textless{}Mout\_argument\textgreater{})
&
n/a
&
Use the first form of the DEFINE\_PROGRAM\_ARGUMENT procedure to define a program argument that has a default value.
\\
\hline
DEFINE\_PROGRAM\_ARGUMENT(
\textless{}program\_name\textgreater{}, \textless{}argument\_position\textgreater{}, \textless{}argument\_name\textgreater{}, \textless{}argument\_type\textgreater{}, \textless{}out\_argument\textgreater{})
&
n/a
&
Use the first form of the DEFINE\_PROGRAM\_ARGUMENT procedure to define a program argument that does not have a default value.
\\
\hline
DISABLE(\textless{}name\textgreater{}, \textless{}force\textgreater{}, \textless{}commit\_semantics\textgreater{})
&
n/a
&
Use the DISABLE procedure to disable a job or program.
\\
\hline
DROP\_JOB(\textless{}job\_name\textgreater{}, \textless{}force\textgreater{}, \textless{}defer\textgreater{}, \textless{}commit\_semantics\textgreater{})
&
n/a
&
Use the DROP\_JOB procedure to drop a job.
\\
\hline
DROP\_PROGRAM(\textless{}program\_name\textgreater{}, \textless{}force\textgreater{})
&
n/a
&
Use the DROP\_PROGRAM procedure to drop a program.
\\
\hline
DROP\_PROGRAM\_ARGUMENT(
\textless{}program\_name\textgreater{}, \textless{}argument\_position\textgreater{})
&
n/a
&
Use the first form of DROP\_PROGRAM\_ARGUMENT to drop a program argument by specifying the argument position.
\\
\hline
DROP\_PROGRAM\_ARGUMENT(
\textless{}program\_name\textgreater{}, \textless{}argument\_name\textgreater{})
&
n/a
&
Use the second form of DROP\_PROGRAM\_ARGUMENT to drop a program argument by specifying the argument name.
\\
\hline
DROP\_SCHEDULE(\textless{}schedule\_name\textgreater{}, \textless{}force\textgreater{})
&
n/a
&
Use the DROP SCHEDULE procedure to drop a schedule.
\\
\hline
ENABLE(\textless{}name\textgreater{}, \textless{}commit\_semantics\textgreater{})
&
n/a
&
Use the ENABLE command to enable a program or job.
\\
\hline
EVALUATE\_CALENDAR\_STRING(
\textless{}calendar\_string\textgreater{}, \textless{}start\_date\textgreater{}, \textless{}return\_date\_after\textgreater{}, \textless{}next\_run\_date\textgreater{})
&
n/a
&
Use EVALUATE\_CALENDAR\_STRING to review the execution date described by a user-defined calendar schedule.
\\
\hline
RUN\_JOB(\textless{}job\_name\textgreater{}, \textless{}use\_current\_session\textgreater{}, \textless{}manually\textgreater{})
&
n/a
&
Use the RUN\_JOB procedure to execute a job immediately.
\\
\hline
SET\_JOB\_ARGUMENT\_VALUE(
\textless{}job\_name\textgreater{}, \textless{}argument\_position\textgreater{}, \textless{}argument\_value\textgreater{})
&
n/a
&
Use the first form of SET\_JOB\_ARGUMENT value to set the value of a job argument described by the argument’s position.
\\
\hline
SET\_JOB\_ARGUMENT\_VALUE(
\textless{}job\_name\textgreater{}, \textless{}argument\_name\textgreater{}, \textless{}argument\_value\textgreater{})
&
n/a
&
Use the second form of SET\_JOB\_ARGUMENT value to set the value of a job argument described by the argument’s name.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}

Advanced Server’s implementation of \sphinxcode{DBMS\_SCHEDULER} is a partial
implementation when compared to Oracle’s version. Only those functions
and procedures listed in the table above are supported.

The \sphinxcode{DBMS\_SCHEDULER} package is dependent on the pgAgent service; you
must have a pgAgent service installed and running on your server before
using \sphinxcode{DBMS\_SCHEDULER}.

Before using \sphinxcode{DBMS\_SCHEDULER}, a database superuser must create the
catalog tables in which the \sphinxcode{DBMS\_SCHEDULER} programs, schedules and jobs
are stored. Use the \sphinxcode{psql} client to connect to the database, and invoke
the command:
\begin{quote}

\sphinxcode{CREATE EXTENSION dbms\_scheduler};
\end{quote}

By default, the \sphinxcode{dbms\_scheduler} extension resides in the
\sphinxcode{contrib/dbms\_scheduler\_ext} subdirectory (under the Advanced Server
installation).

Note that after creating the \sphinxcode{DBMS\_SCHEDULER} tables, only a superuser
will be able to perform a dump or reload of the database.

\newpage


\subsection{\index{Using Calendar Syntax to Specify a Repeating Interval}Using Calendar Syntax to Specify a Repeating Interval}
\label{\detokenize{using_calendar_syntax_to_specify_a_repeating_interval::doc}}\label{\detokenize{using_calendar_syntax_to_specify_a_repeating_interval:using-calendar-syntax-to-specify-a-repeating-interval}}
The \sphinxcode{CREATE\_JOB} and \sphinxcode{CREATE\_SCHEDULE} procedures use Oracle-styled
calendar syntax to define the interval with which a job or schedule is
repeated. You should provide the scheduling information in the
\sphinxcode{\textless{}repeat\_interval\textgreater{}} parameter of each procedure.

\sphinxcode{\textless{}repeat\_interval\textgreater{}} is a value (or series of values) that define the
interval between the executions of the scheduled job. Each value is
composed of a token, followed by an equal sign, followed by the unit (or
units) on which the schedule will execute. Multiple token values must be
separated by a semi-colon (;).

For example, the following value:
\begin{quote}

\sphinxcode{FREQ=DAILY;BYDAY=MON,TUE,WED,THU,FRI;BYHOUR=17;BYMINUTE=45}
\end{quote}

Defines a schedule that is executed each weeknight at 5:45.

The token types and syntax described in the table below are supported by Advanced Server:


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}{|\X{4}{14}|\X{5}{14}|\X{5}{14}|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Token type
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Syntax
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Valid Values
\unskip}\relax \\
\hline
\endfirsthead

\multicolumn{3}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Token type
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Syntax
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Valid Values
\unskip}\relax \\
\hline
\endhead

\hline
\multicolumn{3}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot

FREQ
&
FREQ=\textless{}predefined\_interval\textgreater{}
&
Where \textless{}predefined\_interval\textgreater{} is one of the following: YEARLY, MONTHLY, WEEKLY, DAILY, HOURLY, MINUTELY. The SECONDLY keyword is not supported.
\\
\hline
BYMONTH
&
BYMONTH=\textless{}month\textgreater{}(, \textless{}month\textgreater{})…
&
Where \textless{}month\textgreater{} is the three-letter abbreviation of the month name: JAN \textbar{} FEB \textbar{} MAR \textbar{} APR \textbar{} MAY \textbar{} JUN \textbar{} JUL \textbar{} AUG \textbar{} SEP \textbar{} OCT \textbar{} NOV \textbar{} DEC
\\
\hline
BYMONTH
&
BYMONTH=\textless{}month\textgreater{} (, \textless{}month\textgreater{})…
&
Where \textless{}month\textgreater{} is the numeric value representing the month: 1 \textbar{} 2 \textbar{} 3 \textbar{} 4 \textbar{} 5 \textbar{} 6 \textbar{} 7 \textbar{} 8 \textbar{} 9 \textbar{} 10 \textbar{} 11 \textbar{} 12
\\
\hline
BYMONTHDAY
&
BYMONTHDAY=\textless{}day\_of\_month\textgreater{}
&
Where \textless{}day\_of\_month\textgreater{} is a value from 1 through 31
\\
\hline
BYDAY
&
BYDAY=\textless{}weekday\textgreater{}
&
Where \textless{}weekday\textgreater{} is a three-letter abbreviation or single-digit value representing the day of the week.
\\
\hline&&
Monday           \textbar{} MON   \textbar{} 1   \textbar{}
\\
\hline&&
Tuesday          \textbar{} TUE   \textbar{} 2   \textbar{}
\\
\hline&&
Wednesday        \textbar{} WED   \textbar{} 3   \textbar{}
\\
\hline&&
Thursday         \textbar{} THU   \textbar{} 4   \textbar{}
\\
\hline&&
Friday           \textbar{} FRI   \textbar{} 5   \textbar{}
\\
\hline&&
Saturday         \textbar{} SAT   \textbar{} 6   \textbar{}
\\
\hline&&
Sunday           \textbar{} SUN   \textbar{} 7   \textbar{}
\\
\hline
BYDATE
&
BYDATE=\textless{}date\textgreater{} (, \textless{}date\textgreater{})…
&
Where \textless{}date\textgreater{} is \textless{}YYYYMMDD\textgreater{}.

\begin{DUlineblock}{0em}
\item[] YYYY is a four-digit year representation of the year,
\item[] MM is a two-digit representation of the month,
\item[] and DD is a two-digit day representation of the day.
\end{DUlineblock}
\\
\hline
BYDATE
&
BYDATE=\textless{}date\textgreater{} (, \textless{}date\textgreater{})…
&
Where \textless{}date\textgreater{} is \textless{}MMDD\textgreater{}.

\begin{DUlineblock}{0em}
\item[] MM is a two-digit representation of the month,
\item[] and DD is a two-digit day representation of the day
\end{DUlineblock}
\\
\hline
BYHOUR
&
BYHOUR=\textless{}hour\textgreater{}
&
Where \textless{}hour\textgreater{} is a value from 0 through 23.
\\
\hline
BYMINUTE
&
BYMINUTE=\textless{}minute\textgreater{}
&
Where \textless{}minute\textgreater{} is a value from 0 through 59.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}

\newpage


\subsection{\index{CREATE\_JOB}CREATE\_JOB}
\label{\detokenize{create_job::doc}}\label{\detokenize{create_job:create-job}}
Use the \sphinxcode{CREATE\_JOB} procedure to create a job. The procedure comes in
two forms; the first form of the procedure specifies a schedule within
the job definition, as well as a job action that will be invoked when
the job executes:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{create\_job(}
\item[] \sphinxcode{\textless{}job\_name\textgreater{} IN VARCHAR2},
\item[] \sphinxcode{\textless{}job\_type\textgreater{} IN VARCHAR2},
\item[] \sphinxcode{\textless{}job\_action\textgreater{} IN VARCHAR2},
\item[] \sphinxcode{\textless{}number\_of\_arguments\textgreater{} IN PLS\_INTEGER DEFAULT 0},
\item[] \sphinxcode{\textless{}start\_date\textgreater{} IN TIMESTAMP WITH TIME ZONE DEFAULT NULL},
\item[] \sphinxcode{\textless{}repeat\_interval\textgreater{} IN VARCHAR2 DEFAULT NULL},
\item[] \sphinxcode{\textless{}end\_date\textgreater{} IN TIMESTAMP WITH TIME ZONE DEFAULT NULL},
\item[] \sphinxcode{\textless{}job\_class\textgreater{} IN VARCHAR2 DEFAULT 'DEFAULT\_JOB\_CLASS'},
\item[] \sphinxcode{\textless{}enabled\textgreater{} IN BOOLEAN DEFAULT FALSE},
\item[] \sphinxcode{\textless{}auto\_drop\textgreater{} IN BOOLEAN DEFAULT TRUE},
\item[] \sphinxcode{\textless{}comments\textgreater{} IN VARCHAR2 DEFAULT NULL)}
\end{DUlineblock}
\end{quote}

The second form uses a job schedule to specify the schedule on which the
job will execute, and specifies the name of a program that will execute
when the job runs:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{create\_job(}
\item[] \sphinxcode{\textless{}job\_name\textgreater{} IN VARCHAR2},
\item[] \sphinxcode{\textless{}program\_name\textgreater{} IN VARCHAR2},
\item[] \sphinxcode{\textless{}schedule\_name\textgreater{} IN VARCHAR2},
\item[] \sphinxcode{\textless{}job\_class\textgreater{} IN VARCHAR2 DEFAULT 'DEFAULT\_JOB\_CLASS'},
\item[] \sphinxcode{\textless{}enabled\textgreater{} IN BOOLEAN DEFAULT FALSE},
\item[] \sphinxcode{\textless{}auto\_drop\textgreater{} IN BOOLEAN DEFAULT TRUE},
\item[] \sphinxcode{\textless{}comments\textgreater{} IN VARCHAR2 DEFAULT NULL)}
\end{DUlineblock}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}job\_ame\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}job\_name\textgreater{}} specifies the optionally schema-qualified name of the
job being created.
\end{quote}

\sphinxcode{\textless{}job\_type\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}job\_type\textgreater{}} specifies the type of job. The current implementation of
\sphinxcode{CREATE\_JOB} supports a job type of \sphinxcode{PLSQL\_BLOCK} or
\sphinxcode{STORED\_PROCEDURE}.
\end{quote}

\sphinxcode{\textless{}job\_action\textgreater{}}
\begin{quote}

If \sphinxcode{\textless{}job\_type\textgreater{}} is \sphinxcode{PLSQL\_BLOCK}, \sphinxcode{\textless{}job\_action\textgreater{}} specifies the content
of the PL/SQL block that will be invoked when the job executes. The
block must be terminated with a semi-colon (;).

If \sphinxcode{\textless{}job\_type\textgreater{}} is \sphinxcode{STORED\_PROCEDURE}, \sphinxcode{\textless{}job\_action\textgreater{}} specifies the
optionally schema-qualified name of the procedure.
\end{quote}

\sphinxcode{\textless{}number\_of\_arguments\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}number\_of\_arguments\textgreater{}} is an \sphinxcode{INTEGER} value that specifies the
number of arguments expected by the job. The default is \sphinxcode{0}.
\end{quote}

\sphinxcode{\textless{}start\_date\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}start\_date\textgreater{}} is a \sphinxcode{TIMESTAMP WITH TIME ZONE} value that specifies the
first time that the job is scheduled to execute. The default value
is \sphinxcode{NULL}, indicating that the job should be scheduled to execute when
the job is enabled.
\end{quote}

\sphinxcode{\textless{}repeat\_interval\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}repeat\_interval\textgreater{}} is a \sphinxcode{VARCHAR2} value that specifies how often the
job will repeat. If a \sphinxcode{\textless{}repeat\_interval\textgreater{}} is not specified, the job
will execute only once. The default value is \sphinxcode{NULL}.
\end{quote}

\sphinxcode{\textless{}end\_date\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}end\_date\textgreater{}} is a \sphinxcode{TIMESTAMP WITH TIME ZONE} value that specifies a
time after which the job will no longer execute. If a date is
specified, the \sphinxcode{\textless{}end\_date\textgreater{}} must be after \sphinxcode{\textless{}start\_date\textgreater{}}. The default
value is \sphinxcode{NULL}.

Please note that if an \sphinxcode{\textless{}end\_date\textgreater{}} is not specified and a
\sphinxcode{\textless{}repeat\_interval\textgreater{}} is specified, the job will repeat indefinitely
until it is disabled.
\end{quote}

\sphinxcode{\textless{}program\_name\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}program\_name\textgreater{}} is the name of a program that will be executed by
the job.
\end{quote}

\sphinxcode{\textless{}schedule\_name\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}schedule\_name\textgreater{}} is the name of the schedule associated with the
job.
\end{quote}

\sphinxcode{\textless{}job\_class\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}job\_class\textgreater{}} is accepted for compatibility and ignored.
\end{quote}

\sphinxcode{\textless{}enabled\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}enabled\textgreater{}} is a \sphinxcode{BOOLEAN} value that specifies if the job is enabled
when created. By default, a job is created in a disabled state, with
\sphinxcode{\textless{}enabled\textgreater{}} set to \sphinxcode{FALSE}. To enable a job, specify a value of \sphinxcode{TRUE}
when creating the job, or enable the job with the
\sphinxcode{DBMS\_SCHEDULER.ENABLE} procedure.
\end{quote}

\sphinxcode{\textless{}auto\_drop\textgreater{}}
\begin{quote}

The \sphinxcode{\textless{}auto\_drop\textgreater{}} parameter is accepted for compatibility and is
ignored. By default, a job’s status will be changed to \sphinxcode{DISABLED}
after the time specified in \sphinxcode{\textless{}end\_date\textgreater{}}.
\end{quote}

\sphinxcode{\textless{}comments\textgreater{}}
\begin{quote}

Use the \sphinxcode{\textless{}comments\textgreater{}} parameter to specify a comment about the job.
\end{quote}

\sphinxstylestrong{Example}

The following example demonstrates a call to the \sphinxcode{CREATE\_JOB} procedure:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
EXEC
  DBMS\PYGZus{}SCHEDULER.CREATE\PYGZus{}JOB (
    job\PYGZus{}name        =\PYGZgt{} \PYGZsq{}update\PYGZus{}log\PYGZsq{},
    job\PYGZus{}type        =\PYGZgt{} \PYGZsq{}PLSQL\PYGZus{}BLOCK\PYGZsq{},
    job\PYGZus{}action      =\PYGZgt{} \PYGZsq{}BEGIN INSERT INTO my\PYGZus{}log VALUES(current\PYGZus{}timestamp);END;\PYGZsq{},
    start\PYGZus{}date      =\PYGZgt{} \PYGZsq{}01\PYGZhy{}JUN\PYGZhy{}15 09:00:00.000000\PYGZsq{},
    repeat\PYGZus{}interval =\PYGZgt{} \PYGZsq{}FREQ=DAILY;BYDAY=MON,TUE,WED,THU,FRI;BYHOUR=17;\PYGZsq{},
    end\PYGZus{}date        =\PYGZgt{} NULL,
    enabled         =\PYGZgt{} TRUE,
    comments        =\PYGZgt{} \PYGZsq{}This job adds a row to the my\PYGZus{}log table.\PYGZsq{});
\end{sphinxVerbatim}

The code fragment creates a job named \sphinxcode{update\_log} that executes each
weeknight at 5:00. The job executes a PL/SQL block that inserts the
current timestamp into a logfile (\sphinxcode{my\_log}). Since no \sphinxcode{end\_date} is
specified, the job will execute until it is disabled by the
\sphinxcode{DBMS\_SCHEDULER.DISABLE} procedure.

\newpage


\subsection{\index{CREATE\_PROGRAM}CREATE\_PROGRAM}
\label{\detokenize{create_program::doc}}\label{\detokenize{create_program:create-program}}
Use the \sphinxcode{CREATE\_PROGRAM} procedure to create a \sphinxcode{DBMS\_SCHEDULER} program.
The signature is:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{CREATE\_PROGRAM(}
\item[] \sphinxcode{\textless{}program\_name\textgreater{} IN VARCHAR2},
\item[] \sphinxcode{\textless{}program\_type\textgreater{} IN VARCHAR2,}
\item[] \sphinxcode{\textless{}program\_action\textgreater{} IN VARCHAR2},
\item[] \sphinxcode{\textless{}number\_of\_arguments\textgreater{} IN PLS\_INTEGER DEFAULT 0},
\item[] \sphinxcode{\textless{}enabled\textgreater{} IN BOOLEAN DEFAULT FALSE},
\item[] \sphinxcode{\textless{}comments\textgreater{} IN VARCHAR2 DEFAULT NULL)}
\end{DUlineblock}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}program\_name\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}program\_name\textgreater{}} specifies the name of the program that is being
created.
\end{quote}

\sphinxcode{\textless{}program\_type\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}program\_type\textgreater{}} specifies the type of program. The current
implementation of \sphinxcode{CREATE\_PROGRAM} supports a \sphinxcode{\textless{}program\_type\textgreater{}} of
\sphinxcode{PLSQL\_BLOCK} or \sphinxcode{PROCEDURE}.
\end{quote}

\sphinxcode{\textless{}program\_action\textgreater{}}
\begin{quote}

If \sphinxcode{\textless{}program\_type\textgreater{}} is \sphinxcode{PLSQL\_BLOCK, \textless{}program\_action\textgreater{}} contains the
PL/SQL block that will execute when the program is invoked. The
PL/SQL block must be terminated with a semi-colon (;).

If \sphinxcode{\textless{}program\_type\textgreater{}} is \sphinxcode{PROCEDURE}, \sphinxcode{\textless{}program\_action\textgreater{}} contains the name
of the stored procedure.
\end{quote}

\sphinxcode{\textless{}number\_of\_arguments\textgreater{}}
\begin{quote}

If \sphinxcode{\textless{}program\_type\textgreater{}} is \sphinxcode{PLSQL\_BLOCK}, this argument is ignored.

If \sphinxcode{\textless{}program\_type\textgreater{}} is \sphinxcode{PROCEDURE}, \sphinxcode{\textless{}number\_of\_arguments\textgreater{}}
specifies the number of arguments required by the procedure. The
default value is 0.
\end{quote}

\sphinxcode{\textless{}enabled\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}enabled\textgreater{}} specifies if the program is created enabled or disabled:
\end{quote}
\begin{itemize}
\item {} 
If \sphinxcode{\textless{}enabled\textgreater{}} is \sphinxcode{TRUE}, the program is created enabled.

\item {} 
If \sphinxcode{\textless{}enabled\textgreater{}} is \sphinxcode{FALSE}, the program is created disabled; use the
\sphinxcode{DBMS\_SCHEDULER.ENABLE} program to enable a disabled program.
\begin{quote}

The default value is \sphinxcode{FALSE}.
\end{quote}

\end{itemize}

\sphinxcode{\textless{}comments\textgreater{}}
\begin{quote}

Use the \sphinxcode{\textless{}comments\textgreater{}} parameter to specify a comment about the program;
by default, this parameter is \sphinxcode{NULL}.
\end{quote}

\newpage

\sphinxstylestrong{Example}

The following call to the \sphinxcode{CREATE\_PROGRAM} procedure creates a program
named \sphinxcode{update\_log}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
EXEC
  DBMS\PYGZus{}SCHEDULER.CREATE\PYGZus{}PROGRAM (
program\PYGZus{}name     =\PYGZgt{} \PYGZsq{}update\PYGZus{}log\PYGZsq{},
    program\PYGZus{}type     =\PYGZgt{} \PYGZsq{}PLSQL\PYGZus{}BLOCK\PYGZsq{},
    program\PYGZus{}action   =\PYGZgt{} \PYGZsq{}BEGIN INSERT INTO my\PYGZus{}log VALUES(current\PYGZus{}timestamp);END;\PYGZsq{},
    enabled          =\PYGZgt{} TRUE,
    comment          =\PYGZgt{} \PYGZsq{}This program adds a row to the my\PYGZus{}log table.\PYGZsq{});
\end{sphinxVerbatim}

\sphinxcode{update\_log} is a PL/SQL block that adds a row containing the current
date and time to the \sphinxcode{my\_log} table. The program will be enabled when the
\sphinxcode{CREATE\_PROGRAM} procedure executes.

\newpage


\subsection{\index{CREATE\_SCHEDULE}CREATE\_SCHEDULE}
\label{\detokenize{create_schedule::doc}}\label{\detokenize{create_schedule:create-schedule}}
Use the \sphinxcode{CREATE\_SCHEDULE} procedure to create a job schedule. The
signature of the \sphinxcode{CREATE\_SCHEDULE} procedure is:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{create\_schedule(}
\item[] \sphinxcode{\textless{}schedule\_name\textgreater{} IN VARCHAR2},
\item[] \sphinxcode{\textless{}start\_date\textgreater{} IN TIMESTAMP WITH TIME ZONE DEFAULT NULL},
\item[] \sphinxcode{\textless{}repeat\_interval\textgreater{} IN VARCHAR2},
\item[] \sphinxcode{\textless{}end\_date\textgreater{} IN TIMESTAMP WITH TIME ZONE DEFAULT NULL},
\item[] \sphinxcode{\textless{}comments\textgreater{} IN VARCHAR2 DEFAULT NULL)}
\end{DUlineblock}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}schedule\_name\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}schedule\_name\textgreater{}} specifies the name of the schedule.
\end{quote}

\sphinxcode{\textless{}start\_date\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}start\_date\textgreater{}} is a \sphinxcode{TIMESTAMP WITH TIME ZONE} value that specifies the
date and time that the schedule is eligible to execute. If a
\sphinxcode{\textless{}start\_date\textgreater{}} is not specified, the date that the job is enabled is
used as the \sphinxcode{\textless{}start\_date\textgreater{}}. By default, \sphinxcode{\textless{}start\_date\textgreater{}} is \sphinxcode{NULL}.
\end{quote}

\sphinxcode{\textless{}repeat\_interval\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}repeat\_interval\textgreater{}} is a \sphinxcode{VARCHAR2} value that specifies how often the
job will repeat. If a \sphinxcode{\textless{}repeat\_interval\textgreater{}} is not specified, the job
will execute only once, on the date specified by \sphinxcode{\textless{}start\_date\textgreater{}}.

\begin{sphinxadmonition}{note}{Note:}
You must provide a value for either \sphinxcode{\textless{}start\_date\textgreater{}} or \sphinxcode{\textless{}repeat\_interval\textgreater{}}; if both \sphinxcode{\textless{}start\_date\textgreater{}} and \sphinxcode{\textless{}repeat\_interval\textgreater{}} are \sphinxcode{NULL}, the server will return an error.
\end{sphinxadmonition}
\end{quote}

\sphinxcode{\textless{}end\_date\textgreater{} IN TIMESTAMP WITH TIME ZONE DEFAULT NULL}
\begin{quote}

\sphinxcode{\textless{}end\_date\textgreater{}} is a \sphinxcode{TIMESTAMP WITH TIME ZONE} value that specifies a
time after which the schedule will no longer execute. If a date is
specified, the \sphinxcode{\textless{}end\_date\textgreater{}} must be after the \sphinxcode{\textless{}start\_date\textgreater{}}. The
default value is \sphinxcode{NULL}.

Please note that if a \sphinxcode{\textless{}repeat\_interval\textgreater{}} is specified and an
\sphinxcode{\textless{}end\_date\textgreater{}} is not specified, the schedule will repeat indefinitely
until it is disabled.
\end{quote}

\sphinxcode{\textless{}comments\textgreater{} IN VARCHAR2 DEFAULT NULL)}
\begin{quote}

Use the \sphinxcode{\textless{}comments\textgreater{}} parameter to specify a comment about the
schedule; by default, this parameter is \sphinxcode{NULL}.
\end{quote}

\sphinxstylestrong{Example}

The following code fragment calls \sphinxcode{CREATE\_SCHEDULE} to create a schedule
named weeknights\_at\_5:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
EXEC
  DBMS\PYGZus{}SCHEDULER.CREATE\PYGZus{}SCHEDULE (
    schedule\PYGZus{}name    =\PYGZgt{} \PYGZsq{}weeknights\PYGZus{}at\PYGZus{}5\PYGZsq{},
    start\PYGZus{}date       =\PYGZgt{} \PYGZsq{}01\PYGZhy{}JUN\PYGZhy{}13 09:00:00.000000\PYGZsq{}
    repeat\PYGZus{}interval  =\PYGZgt{} \PYGZsq{}FREQ=DAILY;BYDAY=MON,TUE,WED,THU,FRI;BYHOUR=17;\PYGZsq{},
    comments         =\PYGZgt{} \PYGZsq{}This schedule executes each weeknight at 5:00\PYGZsq{});
\end{sphinxVerbatim}

The schedule executes each weeknight, at 5:00 pm, effective after June
1, 2013. Since no \sphinxcode{end\_date} is specified, the schedule will execute
indefinitely until it is disabled with \sphinxcode{DBMS\_SCHEDULER.DISABLE}.

\newpage


\subsection{\index{DEFINE\_PROGRAM\_ARGUMENT}DEFINE\_PROGRAM\_ARGUMENT}
\label{\detokenize{define_program_argument::doc}}\label{\detokenize{define_program_argument:define-program-argument}}
Use the \sphinxcode{DEFINE\_PROGRAM\_ARGUMENT} procedure to define a program
argument. The \sphinxcode{DEFINE\_PROGRAM\_ARGUMENT} procedure comes in two forms;
the first form defines an argument with a default value:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{DEFINE\_PROGRAM\_ARGUMENT(}
\item[] \sphinxcode{\textless{}program\_name\textgreater{} IN VARCHAR2},
\item[] \sphinxcode{\textless{}argument\_position\textgreater{} IN PLS\_INTEGER},
\item[] \sphinxcode{\textless{}argument\_name\textgreater{} IN VARCHAR2 DEFAULT NULL},
\item[] \sphinxcode{\textless{}argument\_type\textgreater{} IN VARCHAR2},
\item[] \sphinxcode{\textless{}default\_value\textgreater{} IN VARCHAR2},
\item[] \sphinxcode{\textless{}out\_argument\textgreater{} IN BOOLEAN DEFAULT FALSE)}
\end{DUlineblock}
\end{quote}

The second form defines an argument without a default value:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{DEFINE\_PROGRAM\_ARGUMENT(}
\item[] \sphinxcode{\textless{}program\_name\textgreater{} IN VARCHAR2},
\item[] \sphinxcode{\textless{}argument\_position\textgreater{} IN PLS\_INTEGER},
\item[] \sphinxcode{\textless{}argument\_name\textgreater{} IN VARCHAR2 DEFAULT NULL},
\item[] \sphinxcode{\textless{}argument\_type\textgreater{} IN VARCHAR2},
\item[] \sphinxcode{\textless{}out\_argument\textgreater{} IN BOOLEAN DEFAULT FALSE)}
\end{DUlineblock}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}program\_name\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}program\_name\textgreater{}} is the name of the program to which the arguments
belong.
\end{quote}

\sphinxcode{\textless{}argument\_position\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}argument\_position\textgreater{}} specifies the position of the argument as it is
passed to the program.
\end{quote}

\sphinxcode{\textless{}argument\_name\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}argument\_name\textgreater{}} specifies the optional name of the argument. By
default, \sphinxcode{\textless{}argument\_name\textgreater{}} is \sphinxcode{NULL}.
\end{quote}

\sphinxcode{\textless{}argument\_type\textgreater{} IN VARCHAR2}
\begin{quote}

\sphinxcode{\textless{}argument\_type\textgreater{}} specifies the data type of the argument.
\end{quote}

\sphinxcode{\textless{}default\_value\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}default\_value\textgreater{}} specifies the default value assigned to the
argument. \sphinxcode{\textless{}default\_value\textgreater{}} will be overridden by a value specified
by the job when the job executes.
\end{quote}

\sphinxcode{\textless{}out\_argument\textgreater{} IN BOOLEAN DEFAULT FALSE}
\begin{quote}

\sphinxcode{\textless{}out\_argument\textgreater{}} is not currently used; if specified, the value must
be \sphinxcode{FALSE}.
\end{quote}

\newpage

\sphinxstylestrong{Example}

The following code fragment uses the \sphinxcode{DEFINE\_PROGRAM\_ARGUMENT} procedure
to define the first and second arguments in a program named \sphinxcode{add\_emp}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
EXEC
  DBMS\PYGZus{}SCHEDULER.DEFINE\PYGZus{}PROGRAM\PYGZus{}ARGUMENT(
    program\PYGZus{}name         =\PYGZgt{} \PYGZsq{}add\PYGZus{}emp\PYGZsq{},
    argument\PYGZus{}position    =\PYGZgt{} 1,
    argument\PYGZus{}name        =\PYGZgt{} \PYGZsq{}dept\PYGZus{}no\PYGZsq{},
    argument\PYGZus{}type        =\PYGZgt{} \PYGZsq{}INTEGER,
    default\PYGZus{}value        =\PYGZgt{} \PYGZsq{}20\PYGZsq{});
EXEC
  DBMS\PYGZus{}SCHEDULER.DEFINE\PYGZus{}PROGRAM\PYGZus{}ARGUMENT(
    program\PYGZus{}name         =\PYGZgt{} \PYGZsq{}add\PYGZus{}emp\PYGZsq{},
    argument\PYGZus{}position    =\PYGZgt{} 2,
    argument\PYGZus{}name        =\PYGZgt{} \PYGZsq{}emp\PYGZus{}name\PYGZsq{},
    argument\PYGZus{}type        =\PYGZgt{} \PYGZsq{}VARCHAR2\PYGZsq{});
\end{sphinxVerbatim}

The first argument is an \sphinxcode{INTEGER} value named{}`{}` dept\_no{}`{}` that has a default
value of \sphinxcode{20}. The second argument is a \sphinxcode{VARCHAR2} value named \sphinxcode{emp\_name};
the second argument does not have a default value.
\phantomsection\label{\detokenize{dbms_scheduler_disable:dbms-scheduler-disable}}
\newpage

\index{DBMS\_SCHEDULER\_DISABLE}\ignorespaces 

\subsection{DISABLE}
\label{\detokenize{dbms_scheduler_disable::doc}}\label{\detokenize{dbms_scheduler_disable:disable}}\label{\detokenize{dbms_scheduler_disable:index-0}}
Use the \sphinxcode{DISABLE} procedure to disable a program or a job. The signature
of the \sphinxcode{DISABLE} procedure is:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{DISABLE(}
\item[] \sphinxcode{\textless{}name\textgreater{} IN VARCHAR2},
\item[] \sphinxcode{\textless{}force\textgreater{} IN BOOLEAN DEFAULT FALSE},
\item[] \sphinxcode{\textless{}commit\_semantics\textgreater{} IN VARCHAR2 DEFAULT 'STOP\_ON\_FIRST\_ERROR')}
\end{DUlineblock}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}name\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}name\textgreater{}} specifies the name of the program or job that is being
disabled.
\end{quote}

\sphinxcode{\textless{}force\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}force\textgreater{}} is accepted for compatibility, and ignored.
\end{quote}

\sphinxcode{\textless{}commit\_semantics\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}commit\_semantics\textgreater{}} instructs the server how to handle an error
encountered while disabling a program or job. By default,
\sphinxcode{\textless{}commit\_semantics\textgreater{}} is set to \sphinxcode{STOP\_ON\_FIRST\_ERROR}, instructing
the server to stop when it encounters an error. Any programs or jobs
that were successfully disabled prior to the error will be committed
to disk.

The \sphinxcode{TRANSACTIONAL} and \sphinxcode{ABSORB\_ERRORS} keywords are accepted for
compatibility, and ignored.
\end{quote}

\sphinxstylestrong{Example}

The following call to the \sphinxcode{DISABLE} procedure disables a program named
\sphinxcode{update\_emp}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DBMS\PYGZus{}SCHEDULER.DISABLE(\PYGZsq{}update\PYGZus{}emp\PYGZsq{});
\end{sphinxVerbatim}

\newpage


\subsection{\index{DROP\_JOB}DROP\_JOB}
\label{\detokenize{drop_job::doc}}\label{\detokenize{drop_job:drop-job}}
Use the \sphinxcode{DROP\_JOB} procedure to \sphinxcode{DROP} a job, \sphinxcode{DROP} any arguments that
belong to the job, and eliminate any future job executions. The
signature of the procedure is:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{DROP\_JOB(}
\item[] \sphinxcode{\textless{}job\_name\textgreater{} IN VARCHAR2},
\item[] \sphinxcode{\textless{}force\textgreater{} IN BOOLEAN DEFAULT FALSE},
\item[] \sphinxcode{\textless{}defer\textgreater{} IN BOOLEAN DEFAULT FALSE},
\item[] \sphinxcode{\textless{}commit\_semantics\textgreater{} IN VARCHAR2 DEFAULT 'STOP\_ON\_FIRST\_ERROR'})
\end{DUlineblock}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}job\_name\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}job\_name\textgreater{}} specifies the name of the job that is being dropped.
\end{quote}

\sphinxcode{\textless{}force\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}force\textgreater{}} is accepted for compatibility, and ignored.
\end{quote}

\sphinxcode{\textless{}defer\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}defer\textgreater{}} is accepted for compatibility, and ignored.
\end{quote}

\sphinxcode{\textless{}commit\_semantics\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}commit\_semantics\textgreater{}} instructs the server how to handle an error
encountered while dropping a program or job. By default,
\sphinxcode{\textless{}commit\_semantics\textgreater{}} is set to \sphinxcode{STOP\_ON\_FIRST\_ERROR}, instructing
the server to stop when it encounters an error.

The \sphinxcode{TRANSACTIONAL} and \sphinxcode{ABSORB\_ERRORS} keywords are accepted for
compatibility, and ignored.
\end{quote}

\sphinxstylestrong{Example}

The following call to \sphinxcode{DROP\_JOB} drops a job named \sphinxcode{update\_log}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DBMS\PYGZus{}SCHEDULER.DROP\PYGZus{}JOB(\PYGZsq{}update\PYGZus{}log\PYGZsq{});
\end{sphinxVerbatim}

\newpage


\subsection{\index{DROP\_PROGRAM}DROP\_PROGRAM}
\label{\detokenize{drop_program::doc}}\label{\detokenize{drop_program:drop-program}}
The \sphinxcode{DROP\_PROGRAM} procedure

The signature of the \sphinxcode{DROP\_PROGRAM} procedure is:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{DROP\_PROGRAM(}
\item[] \sphinxcode{\textless{}program\_name\textgreater{} IN VARCHAR2},
\item[] \sphinxcode{\textless{}force\textgreater{} IN BOOLEAN DEFAULT FALSE)}
\end{DUlineblock}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}program\_name\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}program\_name\textgreater{}} specifies the name of the program that is being
dropped.
\end{quote}

\sphinxcode{\textless{}force\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}force\textgreater{}} is a \sphinxcode{BOOLEAN} value that instructs the server how to handle
programs with dependent jobs.
\begin{quote}

Specify \sphinxcode{FALSE} to instruct the server to return an error if the
program is referenced by a job.

Specify \sphinxcode{TRUE} to instruct the server to disable any jobs that
reference the program before dropping the program.
\end{quote}

The default value is \sphinxcode{FALSE}.
\end{quote}

\sphinxstylestrong{Example}

The following call to \sphinxcode{DROP\_PROGRAM} drops a job named \sphinxcode{update\_emp}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DBMS\PYGZus{}SCHEDULER.DROP\PYGZus{}PROGRAM(\PYGZsq{}update\PYGZus{}emp\PYGZsq{});
\end{sphinxVerbatim}

\newpage


\subsection{\index{DROP\_PROGRAM\_ARGUMENT}DROP\_PROGRAM\_ARGUMENT}
\label{\detokenize{drop_program_argument::doc}}\label{\detokenize{drop_program_argument:drop-program-argument}}
Use the \sphinxcode{DROP\_PROGRAM\_ARGUMENT} procedure to drop a program argument.
The \sphinxcode{DROP\_PROGRAM\_ARGUMENT} procedure comes in two forms; the first form
uses an argument position to specify which argument to drop:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{drop\_program\_argument(}
\item[] \sphinxcode{\textless{}program\_name\textgreater{} IN VARCHAR2},
\item[] \sphinxcode{\textless{}argument\_position\textgreater{} IN PLS\_INTEGER)}
\end{DUlineblock}
\end{quote}

The second form takes the argument name:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{drop\_program\_argument(}
\item[] \sphinxcode{\textless{}program\_name\textgreater{} IN VARCHAR2},
\item[] \sphinxcode{\textless{}argument\_name\textgreater{} IN VARCHAR2)}
\end{DUlineblock}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}program\_name\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}program\_name\textgreater{}} specifies the name of the program that is being
modified.
\end{quote}

\sphinxcode{\textless{}argument\_position\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}argument\_position\textgreater{}} specifies the position of the argument that is
being dropped.
\end{quote}

\sphinxcode{\textless{}argument\_name\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}argument\_name\textgreater{}} specifies the name of the argument that is being
dropped.
\end{quote}

\sphinxstylestrong{Examples}

The following call to \sphinxcode{DROP\_PROGRAM\_ARGUMENT} drops the first argument
in the \sphinxcode{update\_emp} program:

\sphinxcode{DBMS\_SCHEDULER.DROP\_PROGRAM\_ARGUMENT('update\_emp', 1);}

The following call to \sphinxcode{DROP\_PROGRAM\_ARGUMENT} drops an argument named
\sphinxcode{emp\_name}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DBMS\PYGZus{}SCHEDULER.DROP\PYGZus{}PROGRAM\PYGZus{}ARGUMENT(update\PYGZus{}emp\PYGZsq{}, \PYGZsq{}emp\PYGZus{}name\PYGZsq{});
\end{sphinxVerbatim}

\newpage


\subsection{\index{DROP\_SCHEDULE}DROP\_SCHEDULE}
\label{\detokenize{drop_schedule::doc}}\label{\detokenize{drop_schedule:drop-schedule}}
Use the \sphinxcode{DROP\_SCHEDULE} procedure to drop a schedule. The signature is:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{DROP\_SCHEDULE(}
\item[] \sphinxcode{\textless{}schedule\_name IN VARCHAR2},
\item[] \sphinxcode{\textless{}force\textgreater{} IN BOOLEAN DEFAULT FALSE)}
\end{DUlineblock}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}schedule\_name\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}schedule\_name\textgreater{}} specifies the name of the schedule that is being
dropped.
\end{quote}

\sphinxcode{\textless{}force\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}force\textgreater{}} specifies the behavior of the server if the specified
schedule is referenced by any job:
\begin{itemize}
\item {} 
Specify \sphinxcode{FALSE} to instruct the server to return an error if the
specified schedule is referenced by a job. This is the default
behavior.

\item {} 
Specify \sphinxcode{TRUE} to instruct the server to disable to any jobs that use
the specified schedule before dropping the schedule. Any running jobs
will be allowed to complete before the schedule is dropped.

\end{itemize}
\end{quote}

\sphinxstylestrong{Example}

The following call to \sphinxcode{DROP\_SCHEDULE} drops a schedule named
\sphinxcode{weeknights\_at\_5}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DBMS\PYGZus{}SCHEDULER.DROP\PYGZus{}SCHEDULE(\PYGZsq{}weeknights\PYGZus{}at\PYGZus{}5\PYGZsq{}, TRUE);
\end{sphinxVerbatim}

The server will disable any jobs that use the schedule before dropping
the schedule.
\phantomsection\label{\detokenize{dbms_scheduler_enable:dbms-scheduler-enable}}
\newpage

\index{DBMS\_SCHEDULER\_ENABLE}\ignorespaces 

\subsection{ENABLE}
\label{\detokenize{dbms_scheduler_enable::doc}}\label{\detokenize{dbms_scheduler_enable:index-0}}\label{\detokenize{dbms_scheduler_enable:enable}}
Use the \sphinxcode{ENABLE} procedure to enable a disabled program or job.

The signature of the \sphinxcode{ENABLE} procedure is:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{ENABLE(}
\item[] \sphinxcode{\textless{}name\textgreater{} IN VARCHAR2},
\item[] \sphinxcode{\textless{}commit\_semantics\textgreater{} IN VARCHAR2 DEFAULT 'STOP\_ON\_FIRST\_ERROR')}
\end{DUlineblock}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}name\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}name\textgreater{}} specifies the name of the program or job that is being
enabled.
\end{quote}

\sphinxcode{\textless{}commit\_semantics\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}commit\_semantics\textgreater{}} instructs the server how to handle an error
encountered while enabling a program or job. By default,
\sphinxcode{\textless{}commit\_semantics\textgreater{}} is set to \sphinxcode{STOP\_ON\_FIRST\_ERROR}, instructing
the server to stop when it encounters an error.

The \sphinxcode{TRANSACTIONAL} and \sphinxcode{ABSORB\_ERRORS} keywords are accepted for
compatibility, and ignored.
\end{quote}

\sphinxstylestrong{Example}

The following call to \sphinxcode{DBMS\_SCHEDULER.ENABLE} enables the \sphinxcode{update\_emp}
program:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DBMS\PYGZus{}SCHEDULER.ENABLE(\PYGZsq{}update\PYGZus{}emp\PYGZsq{});
\end{sphinxVerbatim}

\newpage


\subsection{\index{EVALUATE\_CALENDAR\_STRING}EVALUATE\_CALENDAR\_STRING}
\label{\detokenize{evaluate_calendar_string::doc}}\label{\detokenize{evaluate_calendar_string:evaluate-calendar-string}}
Use the \sphinxcode{EVALUATE\_CALENDAR\_STRING} procedure to evaluate the
\sphinxcode{\textless{}repeat\_interval\textgreater{}} value specified when creating a schedule with the
\sphinxcode{CREATE\_SCHEDULE} procedure. The \sphinxcode{EVALUATE\_CALENDAR\_STRING} procedure
will return the date and time that a specified schedule will execute
without actually scheduling the job.

The signature of the \sphinxcode{EVALUATE\_CALENDAR\_STRING} procedure is:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{evaluate\_calendar\_string(}
\item[] \sphinxcode{\textless{}calendar\_string\textgreater{} IN VARCHAR2},
\item[] \sphinxcode{\textless{}start\_date\textgreater{} IN TIMESTAMP WITH TIME ZONE},
\item[] \sphinxcode{\textless{}return\_date\_after\textgreater{} IN TIMESTAMP WITH TIME ZONE},
\item[] \sphinxcode{\textless{}next\_run\_date\textgreater{} OUT TIMESTAMP WITH TIME ZONE)}
\end{DUlineblock}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}calendar\_string\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}calendar\_string\textgreater{}} is the calendar string that describes a
\sphinxcode{\textless{}repeat\_interval\textgreater{}} that is being evaluated.
\end{quote}

\sphinxcode{\textless{}start\_date\textgreater{} IN TIMESTAMP WITH TIME ZONE}
\begin{quote}

\sphinxcode{\textless{}start\_date\textgreater{}} is the date and time after which the
\sphinxcode{\textless{}repeat\_interval\textgreater{}} will become valid.
\end{quote}

\sphinxcode{\textless{}return\_date\_after\textgreater{}}
\begin{quote}

Use the \sphinxcode{\textless{}return\_date\_after parameter\textgreater{}} to specify the date and time
that \sphinxcode{EVALUATE\_CALENDAR\_STRING} should use as a starting date when
evaluating the \sphinxcode{\textless{}repeat\_interval\textgreater{}}.

For example, if you specify a \sphinxcode{\textless{}return\_date\_after\textgreater{}} value of
\sphinxcode{01-APR-13 09.00.00.000000, EVALUATE\_CALENDAR\_STRING} will return
the date and time of the first iteration of the schedule after April
1st, 2013.
\end{quote}

\sphinxcode{\textless{}next\_run\_date OUT TIMESTAMP WITH TIME ZONE}
\begin{quote}

\sphinxcode{\textless{}next\_run\_date\textgreater{}} is an \sphinxcode{OUT} parameter that will contain the first
occurrence of the schedule after the date specified by the
\sphinxcode{\textless{}return\_date\_after\textgreater{}} parameter.
\end{quote}

\sphinxstylestrong{Example}

The following example evaluates a calendar string and returns the first
date and time that the schedule will be executed after June 15, 2013:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
  result     TIMESTAMP;
BEGIN

  DBMS\PYGZus{}SCHEDULER.EVALUATE\PYGZus{}CALENDAR\PYGZus{}STRING
  (
    \PYGZsq{}FREQ=DAILY;BYDAY=MON,TUE,WED,THU,FRI;BYHOUR=17;\PYGZsq{},
    \PYGZsq{}15\PYGZhy{}JUN\PYGZhy{}2013\PYGZsq{}, NULL, result
  );

    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}next\PYGZus{}run\PYGZus{}date: \PYGZsq{} \textbar{}\textbar{} result);
END;
/

next\PYGZus{}run\PYGZus{}date: 17\PYGZhy{}JUN\PYGZhy{}13 05.00.00.000000 PM
\end{sphinxVerbatim}

June 15, 2013 is a Saturday; the schedule will not execute until Monday,
June 17, 2013 at 5:00 pm.

\newpage


\subsection{\index{RUN\_JOB}RUN\_JOB}
\label{\detokenize{run_job::doc}}\label{\detokenize{run_job:run-job}}
Use the \sphinxcode{RUN\_JOB} procedure to execute a job immediately. The signature
of the \sphinxcode{RUN\_JOB} procedure is:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{run\_job(}
\item[] \sphinxcode{\textless{}job\_name\textgreater{} IN VARCHAR2},
\item[] \sphinxcode{\textless{}use\_current\_session\textgreater{} IN BOOLEAN DEFAULT TRUE}
\end{DUlineblock}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}job\_name\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}job\_name\textgreater{}} specifies the name of the job that will execute.
\end{quote}

\sphinxcode{\textless{}use\_current\_session\textgreater{}}
\begin{quote}

By default, the job will execute in the current session. If
specified, \sphinxcode{\textless{}use\_current\_session\textgreater{}} must be set to \sphinxcode{TRUE} ; if
\sphinxcode{\textless{}use\_current\_session\textgreater{}} is set to \sphinxcode{FALSE}, Advanced Server will return
an error.
\end{quote}

\sphinxstylestrong{Example}

The following call to \sphinxcode{RUN\_JOB} executes a job named \sphinxcode{update\_log}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DBMS\PYGZus{}SCHEDULER.RUN\PYGZus{}JOB(\PYGZsq{}update\PYGZus{}log\PYGZsq{}, TRUE);
\end{sphinxVerbatim}

Passing a value of \sphinxcode{TRUE} as the second argument instructs the server to
invoke the job in the current session.

\newpage


\subsection{\index{SET\_JOB\_ARGUMENT\_VALUE}SET\_JOB\_ARGUMENT\_VALUE}
\label{\detokenize{set_job_argument_value::doc}}\label{\detokenize{set_job_argument_value:set-job-argument-value}}
Use the \sphinxcode{SET\_JOB\_ARGUMENT\_VALUE} procedure to specify a value for an
argument. The \sphinxcode{SET\_JOB\_ARGUMENT\_VALUE} procedure comes in two forms;
the first form specifies which argument should be modified by position:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{set\_job\_argument\_value(}
\item[] \sphinxcode{\textless{}job\_name\textgreater{} IN VARCHAR2},
\item[] \sphinxcode{\textless{}argument\_position\textgreater{} IN PLS\_INTEGER},
\item[] \sphinxcode{\textless{}argument\_value\textgreater{} IN VARCHAR2)}
\end{DUlineblock}
\end{quote}

The second form uses an argument name to specify which argument to
modify:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{set\_job\_argument\_value(}
\item[] \sphinxcode{\textless{}job\_name\textgreater{} IN VARCHAR2},
\item[] \sphinxcode{\textless{}argument\_name\textgreater{} IN VARCHAR2},
\item[] \sphinxcode{\textless{}argument\_value\textgreater{} IN VARCHAR2)}
\end{DUlineblock}
\end{quote}

Argument values set by the \sphinxcode{SET\_JOB\_ARGUMENT\_VALUE} procedure override
any values set by default.

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}job\_name\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}job\_name\textgreater{}} specifies the name of the job to which the modified
argument belongs.
\end{quote}

\sphinxcode{\textless{}argument\_position\textgreater{}}
\begin{quote}

Use \sphinxcode{\textless{}argument\_position\textgreater{}} to specify the argument position for which
the value will be set.
\end{quote}

\sphinxcode{\textless{}argument\_name\textgreater{}}
\begin{quote}

Use \sphinxcode{\textless{}argument\_name\textgreater{}} to specify the argument by name for which the
value will be set.
\end{quote}

\sphinxcode{\textless{}argument\_value\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}argument\_value\textgreater{}} specifies the new value of the argument.
\end{quote}

\sphinxstylestrong{Examples}

The following example assigns a value of \sphinxcode{30} to the first argument in the
\sphinxcode{update\_emp} job:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DBMS\PYGZus{}SCHEDULER.SET\PYGZus{}JOB\PYGZus{}ARGUMENT\PYGZus{}VALUE(\PYGZsq{}update\PYGZus{}emp\PYGZsq{}, 1, \PYGZsq{}30\PYGZsq{});
\end{sphinxVerbatim}

The following example sets the \sphinxcode{emp\_name} argument to \sphinxcode{SMITH}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DBMS\PYGZus{}SCHEDULER.SET\PYGZus{}JOB\PYGZus{}ARGUMENT\PYGZus{}VALUE(\PYGZsq{}update\PYGZus{}emp\PYGZsq{}, \PYGZsq{}emp\PYGZus{}name\PYGZsq{},
\PYGZsq{}SMITH\PYGZsq{});
\end{sphinxVerbatim}

\newpage


\section{\index{DBMS\_SESSION}DBMS\_SESSION}
\label{\detokenize{dbms_session:dbms-session}}\label{\detokenize{dbms_session::doc}}
Advanced Server provides support for the following
\sphinxcode{DBMS\_SESSION.SET\_ROLE} procedure:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|\Y{0.3}|\Y{0.1}|\Y{0.6}|}
\hline

Function/Procedure
&
Return Type
&
Description
\\
\hline
SET\_ROLE(\textless{}role\_cmd\textgreater{})
&
n/a
&
Executes a SET ROLE statement followed by the string value specified in \textless{}role\_cmd\textgreater{}.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Advanced Server’s implementation of \sphinxcode{DBMS\_SESSION} is a partial
implementation when compared to Oracle’s version. Only
\sphinxcode{DBMS\_SESSION.SET\_ROLE} is supported.


\subsection{\index{SET\_ROLE}SET\_ROLE}
\label{\detokenize{dbms_session:set-role}}
The \sphinxcode{SET\_ROLE} procedure sets the current session user to the role
specified in \sphinxcode{\textless{}role\_cmd\textgreater{}}. After invoking the \sphinxcode{SET\_ROLE} procedure, the
current session will use the permissions assigned to the specified role.
The signature of the procedure is:
\begin{quote}

\sphinxcode{SET\_ROLE(\textless{}role\_cmd\textgreater{})}
\end{quote}

The \sphinxcode{SET\_ROLE} procedure appends the value specified for \sphinxcode{\textless{}role\_cmd\textgreater{}} to
the \sphinxcode{SET ROLE} statement, and then invokes the statement.

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}role\_cmd\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}role\_cmd\textgreater{}} specifies a role name in the form of a string value.
\end{quote}

\sphinxstylestrong{Example}

The following call to the \sphinxcode{SET\_ROLE} procedure invokes the \sphinxcode{SET ROLE}
command to set the identity of the current session user to manager:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
edb=\PYGZsh{} exec DBMS\PYGZus{}SESSION.SET\PYGZus{}ROLE(\PYGZsq{}manager\PYGZsq{});
\end{sphinxVerbatim}

\newpage


\section{\index{DBMS\_SQL}DBMS\_SQL}
\label{\detokenize{dbms_sql:dbms-sql}}\label{\detokenize{dbms_sql::doc}}
The \sphinxcode{DBMS\_SQL} package provides an application interface compatible with
Oracle databases to the EnterpriseDB dynamic SQL functionality. With
\sphinxcode{DBMS\_SQL} you can construct queries and other commands at run time
(rather than when you write the application). EnterpriseDB Advanced
Server offers native support for dynamic SQL; \sphinxcode{DBMS\_SQL} provides a way
to use dynamic SQL in a fashion compatible with Oracle databases without
modifying your application.

\sphinxcode{DBMS\_SQL} assumes the privileges of the current user when executing
dynamic SQL statements.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|\Y{0.4}|\Y{0.15}|\Y{0.2}|\Y{0.3}|}
\hline

Function/Procedure
&
Function or Procedure
&
Return Type
&
Description
\\
\hline
BIND\_VARIABLE(c, name, value {[}, out\_value\_size {]})
&
Procedure
&
n/a
&
Bind a value to a variable.
\\
\hline
BIND\_VARIABLE\_CHAR(c, name, value {[}, out\_value\_size {]})
&
Procedure
&
n/a
&
Bind a CHAR value to a variable.
\\
\hline
BIND\_VARIABLE\_RAW(c, name, value {[}, out\_value\_size{]})
&
Procedure
&
n/a
&
Bind a RAW value to a variable.
\\
\hline
CLOSE\_CURSOR(c IN OUT)
&
Procedure
&
n/a
&
Close a cursor.
\\
\hline
COLUMN\_VALUE(c, position, value OUT {[}, column\_error OUT {[}, actual\_length OUT {]}{]})
&
Procedure
&
n/a
&
Return a column value into a variable.
\\
\hline
COLUMN\_VALUE\_CHAR(c, position, value OUT {[}, column\_error OUT {[}, actual\_length OUT {]}{]})
&
Procedure
&
n/a
&
Return a CHAR column value into a variable.
\\
\hline
COLUMN\_VALUE\_RAW(c, position, value OUT {[}, column\_error OUT {[}, actual\_length OUT {]}{]})
&
Procedure
&
n/a
&
Return a RAW column value into a variable.
\\
\hline
DEFINE\_COLUMN(c, position, column {[}, column\_size {]})
&
Procedure
&
n/a
&
Define a column in the SELECT list.
\\
\hline
DEFINE\_COLUMN\_CHAR(c, position, column, column\_size)
&
Procedure
&
n/a
&
Define a CHAR column in the SELECT list.
\\
\hline
DEFINE\_COLUMN\_RAW(c, position, column, column\_size)
&
Procedure
&
n/a
&
Define a RAW column in the SELECT list.
\\
\hline
DESCRIBE\_COLUMNS
&
Procedure
&
n/a
&
Defines columns to hold a cursor result set.
\\
\hline
EXECUTE(c)
&
Function
&
INTEGER
&
Execute a cursor.
\\
\hline
EXECUTE\_AND\_FETCH(c {[}, exact {]})
&
Function
&
INTEGER
&
Execute a cursor and fetch a single row.
\\
\hline
FETCH\_ROWS(c)
&
Function
&
INTEGER
&
Fetch rows from the cursor.
\\
\hline
IS\_OPEN(c)
&
Function
&
BOOLEAN
&
Check if a cursor is open.
\\
\hline
LAST\_ROW\_COUNT
&
Function
&
INTEGER
&
Return cumulative number of rows fetched.
\\
\hline
OPEN\_CURSOR
&
Function
&
INTEGER
&
Open a cursor.
\\
\hline
PARSE(c, statement, language\_flag)
&
Procedure
&
n/a
&
Parse a statement.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\newpage

Advanced Server’s implementation of \sphinxcode{DBMS\_SQL} is a partial
implementation when compared to Oracle’s version. Only those functions
and procedures listed in the table above are supported.

The following table lists the public variable available in the \sphinxcode{DBMS\_SQL}
package.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|\Y{0.2}|\Y{0.2}|\Y{0.1}|\Y{0.6}|}
\hline

Public Variables
&
Data Type
&
Value
&
Description
\\
\hline
native
&
INTEGER
&
1
&
Provided for compatibility with Oracle syntax. See DBMS\_SQL.PARSE for more information.
\\
\hline
V6
&
INTEGER
&
2
&
Provided for compatibility with Oracle syntax. See DBMS\_SQL.PARSE for more information.
\\
\hline
V7
&
INTEGER
&
3
&
Provided for compatibility with Oracle syntax. See DBMS\_SQL.PARSE for more information
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\newpage


\subsection{\index{BIND\_VARIABLE}BIND\_VARIABLE}
\label{\detokenize{bind_variable::doc}}\label{\detokenize{bind_variable:bind-variable}}
The \sphinxcode{BIND\_VARIABLE} procedure provides the capability to associate a
value with an \sphinxcode{IN} or \sphinxcode{IN OUT} bind variable in a SQL command.
\begin{quote}

\sphinxcode{BIND\_VARIABLE(c INTEGER, \textless{}name\textgreater{} VARCHAR2},
\begin{quote}

\sphinxcode{\textless{}value\textgreater{} \{ BLOB \textbar{} CLOB \textbar{} DATE \textbar{} FLOAT \textbar{} INTEGER \textbar{} NUMBER \textbar{}}
\begin{quote}

\sphinxcode{TIMESTAMP \textbar{} VARCHAR2 \}}
\end{quote}

\sphinxcode{{[}, \textless{}out\_value\_size\textgreater{} INTEGER {]})}
\end{quote}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}c\textgreater{}}
\begin{quote}

Cursor ID of the cursor for the SQL command with bind variables.
\end{quote}

\sphinxcode{\textless{}name\textgreater{}}
\begin{quote}

Name of the bind variable in the SQL command.
\end{quote}

\sphinxcode{\textless{}value\textgreater{}}
\begin{quote}

Value to be assigned.
\end{quote}

\sphinxcode{\textless{}out\_value\_size\textgreater{}}
\begin{quote}

If \sphinxcode{\textless{}name\textgreater{}} is an \sphinxcode{IN OUT} variable, defines the maximum length of the
output value. If not specified, the length of \sphinxcode{\textless{}value\textgreater{}} is assumed.
\end{quote}

\sphinxstylestrong{Examples}

The following anonymous block uses bind variables to insert a row into
the \sphinxcode{emp table}.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    curid           INTEGER;
    v\PYGZus{}sql           VARCHAR2(150) := \PYGZsq{}INSERT INTO emp VALUES \PYGZsq{} \textbar{}\textbar{}
                        \PYGZsq{}(:p\PYGZus{}empno, :p\PYGZus{}ename, :p\PYGZus{}job, :p\PYGZus{}mgr, \PYGZsq{} \textbar{}\textbar{}
                        \PYGZsq{}:p\PYGZus{}hiredate, :p\PYGZus{}sal, :p\PYGZus{}comm, :p\PYGZus{}deptno)\PYGZsq{};
    v\PYGZus{}empno         emp.empno\PYGZpc{}TYPE;
    v\PYGZus{}ename         emp.ename\PYGZpc{}TYPE;
    v\PYGZus{}job           emp.job\PYGZpc{}TYPE;
    v\PYGZus{}mgr           emp.mgr\PYGZpc{}TYPE;
    v\PYGZus{}hiredate      emp.hiredate\PYGZpc{}TYPE;
    v\PYGZus{}sal           emp.sal\PYGZpc{}TYPE;
    v\PYGZus{}comm          emp.comm\PYGZpc{}TYPE;
    v\PYGZus{}deptno        emp.deptno\PYGZpc{}TYPE;
    v\PYGZus{}status        INTEGER;
BEGIN
    curid := DBMS\PYGZus{}SQL.OPEN\PYGZus{}CURSOR;
    DBMS\PYGZus{}SQL.PARSE(curid,v\PYGZus{}sql,DBMS\PYGZus{}SQL.native);
    v\PYGZus{}empno    := 9001;
    v\PYGZus{}ename    := \PYGZsq{}JONES\PYGZsq{};
    v\PYGZus{}job      := \PYGZsq{}SALESMAN\PYGZsq{};
    v\PYGZus{}mgr      := 7369;
    v\PYGZus{}hiredate := TO\PYGZus{}DATE(\PYGZsq{}13\PYGZhy{}DEC\PYGZhy{}07\PYGZsq{},\PYGZsq{}DD\PYGZhy{}MON\PYGZhy{}YY\PYGZsq{});
    v\PYGZus{}sal      := 8500.00;
    v\PYGZus{}comm     := 1500.00;
    v\PYGZus{}deptno   := 40;
    DBMS\PYGZus{}SQL.BIND\PYGZus{}VARIABLE(curid,\PYGZsq{}:p\PYGZus{}empno\PYGZsq{},v\PYGZus{}empno);
    DBMS\PYGZus{}SQL.BIND\PYGZus{}VARIABLE(curid,\PYGZsq{}:p\PYGZus{}ename\PYGZsq{},v\PYGZus{}ename);
    DBMS\PYGZus{}SQL.BIND\PYGZus{}VARIABLE(curid,\PYGZsq{}:p\PYGZus{}job\PYGZsq{},v\PYGZus{}job);
    DBMS\PYGZus{}SQL.BIND\PYGZus{}VARIABLE(curid,\PYGZsq{}:p\PYGZus{}mgr\PYGZsq{},v\PYGZus{}mgr);
    DBMS\PYGZus{}SQL.BIND\PYGZus{}VARIABLE(curid,\PYGZsq{}:p\PYGZus{}hiredate\PYGZsq{},v\PYGZus{}hiredate);
    DBMS\PYGZus{}SQL.BIND\PYGZus{}VARIABLE(curid,\PYGZsq{}:p\PYGZus{}sal\PYGZsq{},v\PYGZus{}sal);
    DBMS\PYGZus{}SQL.BIND\PYGZus{}VARIABLE(curid,\PYGZsq{}:p\PYGZus{}comm\PYGZsq{},v\PYGZus{}comm);
    DBMS\PYGZus{}SQL.BIND\PYGZus{}VARIABLE(curid,\PYGZsq{}:p\PYGZus{}deptno\PYGZsq{},v\PYGZus{}deptno);
    v\PYGZus{}status := DBMS\PYGZus{}SQL.EXECUTE(curid);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Number of rows processed: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}status);
    DBMS\PYGZus{}SQL.CLOSE\PYGZus{}CURSOR(curid);
END;

Number of rows processed: 1
\end{sphinxVerbatim}

\newpage


\subsection{\index{BIND\_VARIABLE\_CHAR}BIND\_VARIABLE\_CHAR}
\label{\detokenize{bind_variable_char::doc}}\label{\detokenize{bind_variable_char:bind-variable-char}}
The \sphinxcode{BIND\_VARIABLE\_CHAR} procedure provides the capability to associate
a \sphinxcode{CHAR} value with an \sphinxcode{IN} or \sphinxcode{IN OUT} bind variable in a SQL command.
\begin{quote}

\sphinxcode{BIND\_VARIABLE\_CHAR(\textless{}c\textgreater{} INTEGER, \textless{}name\textgreater{} VARCHAR2, \textless{}value\textgreater{} CHAR}
\begin{quote}

\sphinxcode{{[}, \textless{}out\_value\_size\textgreater{} INTEGER {]})}
\end{quote}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}c\textgreater{}}
\begin{quote}

Cursor ID of the cursor for the SQL command with bind variables.
\end{quote}

\sphinxcode{\textless{}name\textgreater{}}
\begin{quote}

Name of the bind variable in the SQL command.
\end{quote}

\sphinxcode{\textless{}value\textgreater{}}
\begin{quote}

Value of type \sphinxcode{CHAR} to be assigned.
\end{quote}

\sphinxcode{\textless{}out\_value\_size\textgreater{}}
\begin{quote}

If \sphinxcode{\textless{}name\textgreater{}} is an \sphinxcode{IN OUT} variable, defines the maximum length of the
output value. If not specified, the length of \sphinxcode{\textless{}value\textgreater{}} is assumed.
\end{quote}

\newpage


\subsection{\index{BIND VARIABLE RAW}BIND VARIABLE RAW}
\label{\detokenize{bind_variable_raw::doc}}\label{\detokenize{bind_variable_raw:bind-variable-raw}}
The \sphinxcode{BIND\_VARIABLE\_RAW} procedure provides the capability to associate a
\sphinxcode{RAW} value with an \sphinxcode{IN} or \sphinxcode{IN OUT} bind variable in a SQL command.
\begin{quote}

\sphinxcode{BIND\_VARIABLE\_RAW(\textless{}c\textgreater{} INTEGER, \textless{}name\textgreater{} VARCHAR2, \textless{}value\textgreater{} RAW}
\begin{quote}

\sphinxcode{{[}, \textless{}out\_value\_size\textgreater{} INTEGER {]})}
\end{quote}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}c\textgreater{}}
\begin{quote}

Cursor ID of the cursor for the SQL command with bind variables.
\end{quote}

\sphinxcode{\textless{}name\textgreater{}}
\begin{quote}

Name of the bind variable in the SQL command.
\end{quote}

\sphinxcode{\textless{}value\textgreater{}}
\begin{quote}

Value of type RAW to be assigned.
\end{quote}

\sphinxcode{\textless{}out\_value\_size\textgreater{}}
\begin{quote}

If \sphinxcode{\textless{}name\textgreater{}} is an \sphinxcode{IN OUT} variable, defines the maximum length of the
output value. If not specified, the length of \sphinxcode{\textless{}value\textgreater{}} is assumed.
\end{quote}

\newpage


\subsection{\index{CLOSE\_CURSOR}CLOSE\_CURSOR}
\label{\detokenize{close_cursor::doc}}\label{\detokenize{close_cursor:close-cursor}}
The \sphinxcode{CLOSE\_CURSOR} procedure closes an open cursor. The resources
allocated to the cursor are released and it can no longer be used.
\begin{quote}

\sphinxcode{CLOSE\_CURSOR(\textless{}c\textgreater{} IN OUT INTEGER)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}c\textgreater{}}
\begin{quote}

Cursor ID of the cursor to be closed.
\end{quote}

\sphinxstylestrong{Examples}

The following example closes a previously opened cursor:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    curid           INTEGER;
BEGIN
    curid := DBMS\PYGZus{}SQL.OPEN\PYGZus{}CURSOR;
            .
            .
            .
    DBMS\PYGZus{}SQL.CLOSE\PYGZus{}CURSOR(curid);
END;
\end{sphinxVerbatim}

\newpage


\subsection{\index{COLUMN\_VALUE}COLUMN\_VALUE}
\label{\detokenize{column_value::doc}}\label{\detokenize{column_value:column-value}}
The \sphinxcode{COLUMN\_VALUE} procedure defines a variable to receive a value from a
cursor.

\sphinxcode{COLUMN\_VALUE(\textless{}c\textgreater{} INTEGER, \textless{}position\textgreater{} INTEGER, \textless{}value\textgreater{} OUT \{ BLOB \textbar{}}
\begin{quote}

\sphinxcode{CLOB \textbar{} DATE \textbar{} FLOAT \textbar{} INTEGER \textbar{} NUMBER \textbar{} TIMESTAMP \textbar{} VARCHAR2 \}}

\sphinxcode{{[}, \textless{}column\_error\textgreater{} OUT NUMBER {[}, \textless{}actual\_length\textgreater{} OUT INTEGER {]}{]})}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}c\textgreater{}}
\begin{quote}

Cursor id of the cursor returning data to the variable being defined.
\end{quote}

\sphinxcode{\textless{}position\textgreater{}}
\begin{quote}

Position within the cursor of the returned data. The first value in the
cursor is position 1.
\end{quote}

\sphinxcode{\textless{}value\textgreater{}}
\begin{quote}

Variable receiving the data returned in the cursor by a prior fetch
call.
\end{quote}

\sphinxcode{\textless{}column\_error\textgreater{}}
\begin{quote}

Error number associated with the column, if any.
\end{quote}

\sphinxcode{\textless{}actual\_length\textgreater{}}
\begin{quote}

Actual length of the data prior to any truncation.
\end{quote}

\sphinxstylestrong{Examples}

The following example shows the portion of an anonymous block that
receives the values from a cursor using the \sphinxcode{COLUMN\_VALUE} procedure.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    curid           INTEGER;
    v\PYGZus{}empno         NUMBER(4);
    v\PYGZus{}ename         VARCHAR2(10);
    v\PYGZus{}hiredate      DATE;
    v\PYGZus{}sal           NUMBER(7,2);
    v\PYGZus{}comm          NUMBER(7,2);
    v\PYGZus{}sql           VARCHAR2(50) := \PYGZsq{}SELECT empno, ename, hiredate, sal, \PYGZsq{} \textbar{}\textbar{}
                                    \PYGZsq{}comm FROM emp\PYGZsq{};
    v\PYGZus{}status        INTEGER;
BEGIN
            .
            .
            .
    LOOP
        v\PYGZus{}status := DBMS\PYGZus{}SQL.FETCH\PYGZus{}ROWS(curid);
        EXIT WHEN v\PYGZus{}status = 0;
        DBMS\PYGZus{}SQL.COLUMN\PYGZus{}VALUE(curid,1,v\PYGZus{}empno);
        DBMS\PYGZus{}SQL.COLUMN\PYGZus{}VALUE(curid,2,v\PYGZus{}ename);
        DBMS\PYGZus{}SQL.COLUMN\PYGZus{}VALUE(curid,3,v\PYGZus{}hiredate);
        DBMS\PYGZus{}SQL.COLUMN\PYGZus{}VALUE(curid,4,v\PYGZus{}sal);
        DBMS\PYGZus{}SQL.COLUMN\PYGZus{}VALUE(curid,4,v\PYGZus{}sal);
        DBMS\PYGZus{}SQL.COLUMN\PYGZus{}VALUE(curid,5,v\PYGZus{}comm);
        DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(v\PYGZus{}empno \textbar{}\textbar{} \PYGZsq{}   \PYGZsq{} \textbar{}\textbar{} RPAD(v\PYGZus{}ename,10) \textbar{}\textbar{} \PYGZsq{}  \PYGZsq{} \textbar{}\textbar{}
            TO\PYGZus{}CHAR(v\PYGZus{}hiredate,\PYGZsq{}yyyy\PYGZhy{}mm\PYGZhy{}dd\PYGZsq{}) \textbar{}\textbar{} \PYGZsq{} \PYGZsq{} \textbar{}\textbar{}
            TO\PYGZus{}CHAR(v\PYGZus{}sal,\PYGZsq{}9,999.99\PYGZsq{}) \textbar{}\textbar{} \PYGZsq{} \PYGZsq{} \textbar{}\textbar{}
            TO\PYGZus{}CHAR(NVL(v\PYGZus{}comm,0),\PYGZsq{}9,999.99\PYGZsq{}));
    END LOOP;
    DBMS\PYGZus{}SQL.CLOSE\PYGZus{}CURSOR(curid);
END;
\end{sphinxVerbatim}

\newpage


\subsection{\index{COLUMN\_VALUE\_CHAR}COLUMN\_VALUE\_CHAR}
\label{\detokenize{column_value_char:column-value-char}}\label{\detokenize{column_value_char::doc}}
The \sphinxcode{COLUMN\_VALUE\_CHAR} procedure defines a variable to receive a \sphinxcode{CHAR}
value from a cursor.

\sphinxcode{COLUMN\_VALUE\_CHAR(\textless{}c\textgreater{} INTEGER, \textless{}position\textgreater{} INTEGER, \textless{}value\textgreater{} OUT CHAR}
\begin{quote}

\sphinxcode{{[}, \textless{}column\_error\textgreater{} OUT NUMBER {[}, \textless{}actual\_length\textgreater{} OUT INTEGER {]}{]})}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}c\textgreater{}}
\begin{quote}

Cursor id of the cursor returning data to the variable being defined.
\end{quote}

\sphinxcode{\textless{}position\textgreater{}}
\begin{quote}

Position within the cursor of the returned data. The first value in the
cursor is position 1.
\end{quote}

\sphinxcode{\textless{}value\textgreater{}}
\begin{quote}

Variable of data type \sphinxcode{CHAR} receiving the data returned in the cursor by
a prior fetch call.
\end{quote}

\sphinxcode{\textless{}column\_error\textgreater{}}
\begin{quote}

Error number associated with the column, if any.
\end{quote}

\sphinxcode{\textless{}actual\_length\textgreater{}}
\begin{quote}

Actual length of the data prior to any truncation.
\end{quote}

\newpage


\subsection{\index{COLUMN\_VALUE\_RAW}COLUMN\_VALUE\_RAW}
\label{\detokenize{column_value_raw:column-value-raw}}\label{\detokenize{column_value_raw::doc}}
The \sphinxcode{COLUMN\_VALUE\_RAW} procedure defines a variable to receive a \sphinxcode{RAW}
value from a cursor.

\sphinxcode{COLUMN\_VALUE\_RAW(\textless{}c\textgreater{} INTEGER, \textless{}position\textgreater{} INTEGER, \textless{}value\textgreater{} OUT RAW}
\begin{quote}

\sphinxcode{{[}, \textless{}column\_error\textgreater{} OUT NUMBER {[}, \textless{}actual\_length\textgreater{} OUT INTEGER {]}{]})}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}c\textgreater{}}
\begin{quote}

Cursor id of the cursor returning data to the variable being defined.
\end{quote}

\sphinxcode{\textless{}position\textgreater{}}
\begin{quote}

Position within the cursor of the returned data. The first value in the
cursor is position 1.
\end{quote}

\sphinxcode{\textless{}value\textgreater{}}
\begin{quote}

Variable of data type \sphinxcode{RAW} receiving the data returned in the cursor by a
prior fetch call.
\end{quote}

\sphinxcode{\textless{}column\_error\textgreater{}}
\begin{quote}

Error number associated with the column, if any.
\end{quote}

\sphinxcode{\textless{}actual\_length\textgreater{}}
\begin{quote}

Actual length of the data prior to any truncation.
\end{quote}

\newpage


\subsection{\index{DEFINE\_COLUMN}DEFINE\_COLUMN}
\label{\detokenize{define_column:define-column}}\label{\detokenize{define_column::doc}}
The \sphinxcode{DEFINE\_COLUMN} procedure defines a column or expression in the
\sphinxcode{SELECT} list that is to be returned and retrieved in a cursor.

\sphinxcode{DEFINE\_COLUMN(\textless{}c\textgreater{} INTEGER, \textless{}position\textgreater{} INTEGER, \textless{}column\textgreater{} \{ BLOB \textbar{}}
\begin{quote}

\sphinxcode{CLOB \textbar{} DATE \textbar{} FLOAT \textbar{} INTEGER \textbar{} NUMBER \textbar{} TIMESTAMP \textbar{} VARCHAR2 \}}

\sphinxcode{{[}, \textless{}column\_size\textgreater{} INTEGER {]})}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}c\textgreater{}}
\begin{quote}

Cursor id of the cursor associated with the \sphinxcode{SELECT} command.
\end{quote}

\sphinxcode{\textless{}position\textgreater{}}
\begin{quote}

Position of the column or expression in the \sphinxcode{SELECT} list that is being
defined.
\end{quote}

\sphinxcode{\textless{}column\textgreater{}}
\begin{quote}

A variable that is of the same data type as the column or expression in
position \sphinxcode{\textless{}position\textgreater{}} of the \sphinxcode{SELECT list}.
\end{quote}

\sphinxcode{\textless{}column\_size\textgreater{}}
\begin{quote}

The maximum length of the returned data. \sphinxcode{\textless{}column\_size\textgreater{}} must be
specified only if \sphinxcode{\textless{}column\textgreater{}} is \sphinxcode{VARCHAR2}. Returned data exceeding
\sphinxcode{\textless{}column\_size\textgreater{}} is truncated to \sphinxcode{\textless{}column\_size\textgreater{}} characters.
\end{quote}

\sphinxstylestrong{Examples}

The following shows how the \sphinxcode{empno, ename, hiredate, sal}, and \sphinxcode{comm}
columns of the \sphinxcode{emp table} are defined with the \sphinxcode{DEFINE\_COLUMN} procedure.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    curid           INTEGER;
    v\PYGZus{}empno         NUMBER(4);
    v\PYGZus{}ename         VARCHAR2(10);
    v\PYGZus{}hiredate      DATE;
    v\PYGZus{}sal           NUMBER(7,2);
    v\PYGZus{}comm          NUMBER(7,2);
    v\PYGZus{}sql           VARCHAR2(50) := \PYGZsq{}SELECT empno, ename, hiredate, sal, \PYGZsq{} \textbar{}\textbar{}
                                    \PYGZsq{}comm FROM emp\PYGZsq{};
    v\PYGZus{}status        INTEGER;
BEGIN
    curid := DBMS\PYGZus{}SQL.OPEN\PYGZus{}CURSOR;
    DBMS\PYGZus{}SQL.PARSE(curid,v\PYGZus{}sql,DBMS\PYGZus{}SQL.native);
    DBMS\PYGZus{}SQL.DEFINE\PYGZus{}COLUMN(curid,1,v\PYGZus{}empno);
    DBMS\PYGZus{}SQL.DEFINE\PYGZus{}COLUMN(curid,2,v\PYGZus{}ename,10);
    DBMS\PYGZus{}SQL.DEFINE\PYGZus{}COLUMN(curid,3,v\PYGZus{}hiredate);
    DBMS\PYGZus{}SQL.DEFINE\PYGZus{}COLUMN(curid,4,v\PYGZus{}sal);
    DBMS\PYGZus{}SQL.DEFINE\PYGZus{}COLUMN(curid,5,v\PYGZus{}comm);
            .
            .
            .
END;
\end{sphinxVerbatim}

\newpage

The following shows an alternative to the prior example that produces
the exact same results. Note that the lengths of the data types are
irrelevant \textendash{} the \sphinxcode{empno, sal}, and \sphinxcode{comm} columns will still return data
equivalent to \sphinxcode{NUMBER(4)} and \sphinxcode{NUMBER(7,2)}, respectively, even though
\sphinxcode{v\_num} is defined as \sphinxcode{NUMBER(1)} (assuming the declarations in the
\sphinxcode{COLUMN\_VALUE} procedure are of the appropriate maximum sizes). The \sphinxcode{ename}
column will return data up to ten characters in length as defined by the
\sphinxcode{\textless{}length\textgreater{}} parameter in the \sphinxcode{DEFINE\_COLUMN} call, not by the data type
declaration, \sphinxcode{VARCHAR2(1)} declared for \sphinxcode{v\_varchar}. The actual size of the
returned data is dictated by the \sphinxcode{COLUMN\_VALUE} procedure.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    curid           INTEGER;
    v\PYGZus{}num           NUMBER(1);
    v\PYGZus{}varchar       VARCHAR2(1);
    v\PYGZus{}date          DATE;
    v\PYGZus{}sql           VARCHAR2(50) := \PYGZsq{}SELECT empno, ename, hiredate, sal, \PYGZsq{} \textbar{}\textbar{}
                                    \PYGZsq{}comm FROM emp\PYGZsq{};
    v\PYGZus{}status        INTEGER;
BEGIN
    curid := DBMS\PYGZus{}SQL.OPEN\PYGZus{}CURSOR;
    DBMS\PYGZus{}SQL.PARSE(curid,v\PYGZus{}sql,DBMS\PYGZus{}SQL.native);
    DBMS\PYGZus{}SQL.DEFINE\PYGZus{}COLUMN(curid,1,v\PYGZus{}num);
    DBMS\PYGZus{}SQL.DEFINE\PYGZus{}COLUMN(curid,2,v\PYGZus{}varchar,10);
    DBMS\PYGZus{}SQL.DEFINE\PYGZus{}COLUMN(curid,3,v\PYGZus{}date);
    DBMS\PYGZus{}SQL.DEFINE\PYGZus{}COLUMN(curid,4,v\PYGZus{}num);
    DBMS\PYGZus{}SQL.DEFINE\PYGZus{}COLUMN(curid,5,v\PYGZus{}num);
            .
            .
            .
END;
\end{sphinxVerbatim}

\newpage


\subsection{\index{DEFINE\_COLUMN\_CHAR}DEFINE\_COLUMN\_CHAR}
\label{\detokenize{define_column_char::doc}}\label{\detokenize{define_column_char:define-column-char}}
The \sphinxcode{DEFINE\_COLUMN\_CHAR} procedure defines a \sphinxcode{CHAR} column or expression
in the \sphinxcode{SELECT} list that is to be returned and retrieved in a cursor.
\begin{quote}

\sphinxcode{DEFINE\_COLUMN\_CHAR(\textless{}c\textgreater{} INTEGER, \textless{}position\textgreater{} INTEGER, \textless{}column\textgreater{}}
\sphinxcode{CHAR, \textless{}column\_size\textgreater{} INTEGER)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}c\textgreater{}}
\begin{quote}

Cursor id of the cursor associated with the \sphinxcode{SELECT} command.
\end{quote}

\sphinxcode{\textless{}position\textgreater{}}
\begin{quote}

Position of the column or expression in the \sphinxcode{SELECT} list that is being
defined.
\end{quote}

\sphinxcode{\textless{}column\textgreater{}}
\begin{quote}

A \sphinxcode{CHAR} variable.
\end{quote}

\sphinxcode{\textless{}column\_size\textgreater{}}
\begin{quote}

The maximum length of the returned data. Returned data exceeding
\sphinxcode{\textless{}column\_size\textgreater{}} is truncated to \sphinxcode{\textless{}column\_size\textgreater{}} characters.
\end{quote}

\newpage


\subsection{\index{DEFINE\_COLUMN\_RAW}DEFINE\_COLUMN\_RAW}
\label{\detokenize{define_column_raw::doc}}\label{\detokenize{define_column_raw:define-column-raw}}
The \sphinxcode{DEFINE\_COLUMN\_RAW} procedure defines a \sphinxcode{RAW} column or expression in
the \sphinxcode{SELECT} list that is to be returned and retrieved in a cursor.
\begin{quote}

\sphinxcode{DEFINE\_COLUMN\_RAW(\textless{}c\textgreater{} INTEGER, \textless{}position\textgreater{} INTEGER, \textless{}column\textgreater{} RAW},

\sphinxcode{\textless{}column\_size\textgreater{} INTEGER)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}c\textgreater{}}
\begin{quote}

Cursor id of the cursor associated with the \sphinxcode{SELECT} command.
\end{quote}

\sphinxcode{\textless{}position\textgreater{}}
\begin{quote}

Position of the column or expression in the \sphinxcode{SELECT} list that is being
defined.
\end{quote}

\sphinxcode{\textless{}column\textgreater{}}
\begin{quote}

A \sphinxcode{RAW} variable.
\end{quote}

\sphinxcode{\textless{}column\_size\textgreater{}}
\begin{quote}

The maximum length of the returned data. Returned data exceeding
\sphinxcode{\textless{}column\_size\textgreater{}} is truncated to \sphinxcode{\textless{}column\_size\textgreater{}} characters.
\end{quote}

\newpage


\subsection{\index{DESCRIBE COLUMNS}DESCRIBE COLUMNS}
\label{\detokenize{describe_columns::doc}}\label{\detokenize{describe_columns:describe-columns}}
The \sphinxcode{DESCRIBE\_COLUMNS} procedure describes the columns returned by a
cursor.

\begin{DUlineblock}{0em}
\item[] \sphinxcode{DESCRIBE\_COLUMNS(c INTEGER, col\_cnt OUT INTEGER, desc\_t OUT}
\item[] \sphinxcode{DESC\_TAB});
\end{DUlineblock}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}c\textgreater{}}
\begin{quote}

The cursor ID of the cursor.
\end{quote}

\sphinxcode{\textless{}col\_cnt\textgreater{}}
\begin{quote}

The number of columns in cursor result set.
\end{quote}

\sphinxcode{\textless{}desc\_tab\textgreater{}}
\begin{quote}

The table that contains a description of each column returned by the
cursor. The descriptions are of type \sphinxcode{DESC\_REC}, and contain the
following values:
\end{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Column Name
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Type
\unskip}\relax \\
\hline
col\_type
&
INTEGER
\\
\hline
col\_max\_len
&
INTEGER
\\
\hline
col\_name
&
VARCHAR2(128)
\\
\hline
col\_name\_len
&
INTEGER
\\
\hline
col\_schema\_name
&
VARCHAR2(128)
\\
\hline
col\_schema\_name\_len
&
INTEGER
\\
\hline
col\_precision
&
INTEGER
\\
\hline
col\_scale
&
INTEGER
\\
\hline
col\_charsetid
&
INTEGER
\\
\hline
col\_charsetform
&
INTEGER
\\
\hline
col\_null\_ok
&
BOOLEAN
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\newpage


\subsection{\index{EXECUTE}EXECUTE}
\label{\detokenize{execute::doc}}\label{\detokenize{execute:execute}}
The \sphinxcode{EXECUTE} function executes a parsed SQL command or SPL block.
\begin{quote}

\sphinxcode{\textless{}status\textgreater{} INTEGER EXECUTE(\textless{}c\textgreater{} INTEGER)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}c\textgreater{}}
\begin{quote}

Cursor ID of the parsed SQL command or SPL block to be executed.
\end{quote}

\sphinxcode{\textless{}status\textgreater{}}
\begin{quote}

Number of rows processed if the SQL command was \sphinxcode{DELETE, INSERT}, or
\sphinxcode{UPDATE}. \sphinxcode{\textless{}status\textgreater{}} is meaningless for all other commands.
\end{quote}

\sphinxstylestrong{Examples}

The following anonymous block inserts a row into the \sphinxcode{dept} table.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    curid           INTEGER;
    v\PYGZus{}sql           VARCHAR2(50);
    v\PYGZus{}status        INTEGER;
BEGIN
    curid := DBMS\PYGZus{}SQL.OPEN\PYGZus{}CURSOR;
    v\PYGZus{}sql := \PYGZsq{}INSERT INTO dept VALUES (50, \PYGZsq{}\PYGZsq{}HR\PYGZsq{}\PYGZsq{}, \PYGZsq{}\PYGZsq{}LOS ANGELES\PYGZsq{}\PYGZsq{})\PYGZsq{};
    DBMS\PYGZus{}SQL.PARSE(curid, v\PYGZus{}sql, DBMS\PYGZus{}SQL.native);
    v\PYGZus{}status := DBMS\PYGZus{}SQL.EXECUTE(curid);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Number of rows processed: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}status);
    DBMS\PYGZus{}SQL.CLOSE\PYGZus{}CURSOR(curid);
END;
\end{sphinxVerbatim}

\newpage


\subsection{\index{EXECUTE\_AND\_FETCH}EXECUTE\_AND\_FETCH}
\label{\detokenize{execute_and_fetch::doc}}\label{\detokenize{execute_and_fetch:execute-and-fetch}}
Function \sphinxcode{EXECUTE\_AND\_FETCH} executes a parsed \sphinxcode{SELECT} command and
fetches one row.
\begin{quote}

\sphinxcode{\textless{}status\textgreater{} INTEGER EXECUTE\_AND\_FETCH(\textless{}c\textgreater{} INTEGER}
\begin{quote}

\sphinxcode{{[}, \textless{}exact\textgreater{} BOOLEAN {]})}
\end{quote}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}c\textgreater{}}
\begin{quote}

Cursor id of the cursor for the \sphinxcode{SELECT} command to be executed.
\end{quote}

\sphinxcode{\textless{}exact\textgreater{}}
\begin{quote}

If set to \sphinxcode{TRUE}, an exception is thrown if the number of rows in the
result set is not exactly equal to 1. If set to \sphinxcode{FALSE}, no exception is
thrown. The default is \sphinxcode{FALSE}. A \sphinxcode{NO\_DATA\_FOUND} exception is thrown if
\sphinxcode{\textless{}exact\textgreater{}} is \sphinxcode{TRUE} and there are no rows in the result set. A
\sphinxcode{TOO\_MANY\_ROWS} exception is thrown if \sphinxcode{\textless{}exact\textgreater{}} is \sphinxcode{TRUE} and there is more
than one row in the result set.
\end{quote}

\sphinxcode{\textless{}status\textgreater{}}
\begin{quote}

Returns 1 if a row was successfully fetched, 0 if no rows to fetch. If
an exception is thrown, no value is returned.
\end{quote}

\sphinxstylestrong{Examples}

The following stored procedure uses the \sphinxcode{EXECUTE\_AND\_FETCH} function to
retrieve one employee using the employee’s name. An exception will be
thrown if the employee is not found, or there is more than one employee
with the same name.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
CREATE OR REPLACE PROCEDURE select\PYGZus{}by\PYGZus{}name(
    p\PYGZus{}ename         emp.ename\PYGZpc{}TYPE
)
IS
    curid           INTEGER;
    v\PYGZus{}empno         emp.empno\PYGZpc{}TYPE;
    v\PYGZus{}hiredate      emp.hiredate\PYGZpc{}TYPE;
    v\PYGZus{}sal           emp.sal\PYGZpc{}TYPE;
    v\PYGZus{}comm          emp.comm\PYGZpc{}TYPE;
    v\PYGZus{}dname         dept.dname\PYGZpc{}TYPE;
    v\PYGZus{}disp\PYGZus{}date     VARCHAR2(10);
    v\PYGZus{}sql           VARCHAR2(120) := \PYGZsq{}SELECT empno, hiredate, sal, \PYGZsq{} \textbar{}\textbar{}
                                     \PYGZsq{}NVL(comm, 0), dname \PYGZsq{} \textbar{}\textbar{}
                                     \PYGZsq{}FROM emp e, dept d \PYGZsq{} \textbar{}\textbar{}
                                     \PYGZsq{}WHERE ename = :p\PYGZus{}ename \PYGZsq{} \textbar{}\textbar{}
                                     \PYGZsq{}AND e.deptno = d.deptno\PYGZsq{};
    v\PYGZus{}status        INTEGER;
BEGIN
    curid := DBMS\PYGZus{}SQL.OPEN\PYGZus{}CURSOR;
    DBMS\PYGZus{}SQL.PARSE(curid,v\PYGZus{}sql,DBMS\PYGZus{}SQL.native);
    DBMS\PYGZus{}SQL.BIND\PYGZus{}VARIABLE(curid,\PYGZsq{}:p\PYGZus{}ename\PYGZsq{},UPPER(p\PYGZus{}ename));
    DBMS\PYGZus{}SQL.DEFINE\PYGZus{}COLUMN(curid,1,v\PYGZus{}empno);
    DBMS\PYGZus{}SQL.DEFINE\PYGZus{}COLUMN(curid,2,v\PYGZus{}hiredate);
    DBMS\PYGZus{}SQL.DEFINE\PYGZus{}COLUMN(curid,3,v\PYGZus{}sal);
    DBMS\PYGZus{}SQL.DEFINE\PYGZus{}COLUMN(curid,4,v\PYGZus{}comm);
    DBMS\PYGZus{}SQL.DEFINE\PYGZus{}COLUMN(curid,5,v\PYGZus{}dname,14);
    v\PYGZus{}status := DBMS\PYGZus{}SQL.EXECUTE\PYGZus{}AND\PYGZus{}FETCH(curid,TRUE);
    DBMS\PYGZus{}SQL.COLUMN\PYGZus{}VALUE(curid,1,v\PYGZus{}empno);
    DBMS\PYGZus{}SQL.COLUMN\PYGZus{}VALUE(curid,2,v\PYGZus{}hiredate);
    DBMS\PYGZus{}SQL.COLUMN\PYGZus{}VALUE(curid,3,v\PYGZus{}sal);
    DBMS\PYGZus{}SQL.COLUMN\PYGZus{}VALUE(curid,4,v\PYGZus{}comm);
    DBMS\PYGZus{}SQL.COLUMN\PYGZus{}VALUE(curid,5,v\PYGZus{}dname);
    v\PYGZus{}disp\PYGZus{}date := TO\PYGZus{}CHAR(v\PYGZus{}hiredate, \PYGZsq{}MM/DD/YYYY\PYGZsq{});
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Number    : \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}empno);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Name      : \PYGZsq{} \textbar{}\textbar{} UPPER(p\PYGZus{}ename));
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Hire Date : \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}disp\PYGZus{}date);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Salary    : \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}sal);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Commission: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}comm);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Department: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}dname);
    DBMS\PYGZus{}SQL.CLOSE\PYGZus{}CURSOR(curid);
EXCEPTION
    WHEN NO\PYGZus{}DATA\PYGZus{}FOUND THEN
        DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Employee \PYGZsq{} \textbar{}\textbar{} p\PYGZus{}ename \textbar{}\textbar{} \PYGZsq{} not found\PYGZsq{});
        DBMS\PYGZus{}SQL.CLOSE\PYGZus{}CURSOR(curid);
    WHEN TOO\PYGZus{}MANY\PYGZus{}ROWS THEN
        DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Too many employees named, \PYGZsq{} \textbar{}\textbar{}
            p\PYGZus{}ename \textbar{}\textbar{} \PYGZsq{}, found\PYGZsq{});
        DBMS\PYGZus{}SQL.CLOSE\PYGZus{}CURSOR(curid);
    WHEN OTHERS THEN
        DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}The following is SQLERRM:\PYGZsq{});
        DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(SQLERRM);
        DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}The following is SQLCODE:\PYGZsq{});
        DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(SQLCODE);
        DBMS\PYGZus{}SQL.CLOSE\PYGZus{}CURSOR(curid);
END;

EXEC select\PYGZus{}by\PYGZus{}name(\PYGZsq{}MARTIN\PYGZsq{})

Number    : 7654
Name      : MARTIN
Hire Date : 09/28/1981
Salary    : 1250
Commission: 1400
Department: SALES
\end{sphinxVerbatim}

\newpage


\subsection{\index{FETCH\_ROWS}FETCH\_ROWS}
\label{\detokenize{fetch_rows::doc}}\label{\detokenize{fetch_rows:fetch-rows}}
The \sphinxcode{FETCH\_ROWS} function retrieves a row from a cursor.
\begin{quote}

\sphinxcode{\textless{}status\textgreater{} INTEGER FETCH\_ROWS(\textless{}c\textgreater{} INTEGER)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}c\textgreater{}}
\begin{quote}

Cursor ID of the cursor from which to fetch a row.
\end{quote}

\sphinxcode{\textless{}status\textgreater{}}
\begin{quote}

Returns \sphinxcode{1} if a row was successfully fetched, \sphinxcode{0} if no more rows to fetch.
\end{quote}

\sphinxstylestrong{Examples}

The following examples fetches the rows from the \sphinxcode{emp} table and displays
the results.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    curid           INTEGER;
    v\PYGZus{}empno         NUMBER(4);
    v\PYGZus{}ename         VARCHAR2(10);
    v\PYGZus{}hiredate      DATE;
    v\PYGZus{}sal           NUMBER(7,2);
    v\PYGZus{}comm          NUMBER(7,2);
    v\PYGZus{}sql           VARCHAR2(50) := \PYGZsq{}SELECT empno, ename, hiredate, sal, \PYGZsq{} \textbar{}\textbar{}
                                    \PYGZsq{}comm FROM emp\PYGZsq{};
    v\PYGZus{}status        INTEGER;
BEGIN
    curid := DBMS\PYGZus{}SQL.OPEN\PYGZus{}CURSOR;
    DBMS\PYGZus{}SQL.PARSE(curid,v\PYGZus{}sql,DBMS\PYGZus{}SQL.native);
    DBMS\PYGZus{}SQL.DEFINE\PYGZus{}COLUMN(curid,1,v\PYGZus{}empno);
    DBMS\PYGZus{}SQL.DEFINE\PYGZus{}COLUMN(curid,2,v\PYGZus{}ename,10);
    DBMS\PYGZus{}SQL.DEFINE\PYGZus{}COLUMN(curid,3,v\PYGZus{}hiredate);
    DBMS\PYGZus{}SQL.DEFINE\PYGZus{}COLUMN(curid,4,v\PYGZus{}sal);
    DBMS\PYGZus{}SQL.DEFINE\PYGZus{}COLUMN(curid,5,v\PYGZus{}comm);

    v\PYGZus{}status := DBMS\PYGZus{}SQL.EXECUTE(curid);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}EMPNO  ENAME       HIREDATE    SAL       COMM\PYGZsq{});
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}  \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}  \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}  \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}  \PYGZsq{} \textbar{}\textbar{}
        \PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZsq{});
    LOOP
        v\PYGZus{}status := DBMS\PYGZus{}SQL.FETCH\PYGZus{}ROWS(curid);
        EXIT WHEN v\PYGZus{}status = 0;
        DBMS\PYGZus{}SQL.COLUMN\PYGZus{}VALUE(curid,1,v\PYGZus{}empno);
        DBMS\PYGZus{}SQL.COLUMN\PYGZus{}VALUE(curid,2,v\PYGZus{}ename);
        DBMS\PYGZus{}SQL.COLUMN\PYGZus{}VALUE(curid,3,v\PYGZus{}hiredate);
        DBMS\PYGZus{}SQL.COLUMN\PYGZus{}VALUE(curid,4,v\PYGZus{}sal);
        DBMS\PYGZus{}SQL.COLUMN\PYGZus{}VALUE(curid,4,v\PYGZus{}sal);
        DBMS\PYGZus{}SQL.COLUMN\PYGZus{}VALUE(curid,5,v\PYGZus{}comm);
        DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(v\PYGZus{}empno \textbar{}\textbar{} \PYGZsq{}   \PYGZsq{} \textbar{}\textbar{} RPAD(v\PYGZus{}ename,10) \textbar{}\textbar{} \PYGZsq{}  \PYGZsq{} \textbar{}\textbar{}
            TO\PYGZus{}CHAR(v\PYGZus{}hiredate,\PYGZsq{}yyyy\PYGZhy{}mm\PYGZhy{}dd\PYGZsq{}) \textbar{}\textbar{} \PYGZsq{} \PYGZsq{} \textbar{}\textbar{}
            TO\PYGZus{}CHAR(v\PYGZus{}sal,\PYGZsq{}9,999.99\PYGZsq{}) \textbar{}\textbar{} \PYGZsq{} \PYGZsq{} \textbar{}\textbar{}
            TO\PYGZus{}CHAR(NVL(v\PYGZus{}comm,0),\PYGZsq{}9,999.99\PYGZsq{}));
    END LOOP;
    DBMS\PYGZus{}SQL.CLOSE\PYGZus{}CURSOR(curid);
END;

EMPNO  ENAME       HIREDATE    SAL       COMM
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}  \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}  \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}  \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}  \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
7369   SMITH       1980\PYGZhy{}12\PYGZhy{}17    800.00       .00
7499   ALLEN       1981\PYGZhy{}02\PYGZhy{}20  1,600.00    300.00
7521   WARD        1981\PYGZhy{}02\PYGZhy{}22  1,250.00    500.00
7566   JONES       1981\PYGZhy{}04\PYGZhy{}02  2,975.00       .00
7654   MARTIN      1981\PYGZhy{}09\PYGZhy{}28  1,250.00  1,400.00
7698   BLAKE       1981\PYGZhy{}05\PYGZhy{}01  2,850.00       .00
7782   CLARK       1981\PYGZhy{}06\PYGZhy{}09  2,450.00       .00
7788   SCOTT       1987\PYGZhy{}04\PYGZhy{}19  3,000.00       .00
7839   KING        1981\PYGZhy{}11\PYGZhy{}17  5,000.00       .00
7844   TURNER      1981\PYGZhy{}09\PYGZhy{}08  1,500.00       .00
7876   ADAMS       1987\PYGZhy{}05\PYGZhy{}23  1,100.00       .00
7900   JAMES       1981\PYGZhy{}12\PYGZhy{}03    950.00       .00
7902   FORD        1981\PYGZhy{}12\PYGZhy{}03  3,000.00       .00
7934   MILLER      1982\PYGZhy{}01\PYGZhy{}23  1,300.00       .00
\end{sphinxVerbatim}

\newpage


\subsection{\index{IS\_OPEN}IS\_OPEN}
\label{\detokenize{is_open::doc}}\label{\detokenize{is_open:is-open}}
The \sphinxcode{IS\_OPEN} function provides the capability to test if the given
cursor is open.
\begin{quote}

\sphinxcode{\textless{}status\textgreater{} BOOLEAN IS\_OPEN(\textless{}c\textgreater{} INTEGER)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}c\textgreater{}}
\begin{quote}

Cursor ID of the cursor to be tested.
\end{quote}

\sphinxcode{\textless{}status\textgreater{}}
\begin{quote}

Set to \sphinxcode{TRUE} if the cursor is open, set to \sphinxcode{FALSE} if the cursor is not
open.
\end{quote}

\newpage


\subsection{\index{LAST\_ROW\_COUNT}LAST\_ROW\_COUNT}
\label{\detokenize{last_row_count::doc}}\label{\detokenize{last_row_count:last-row-count}}
The \sphinxcode{LAST\_ROW\_COUNT} function returns the number of rows that have been
currently fetched.
\begin{quote}

\sphinxcode{\textless{}rowcnt\textgreater{} INTEGER LAST\_ROW\_COUNT}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}rowcnt\textgreater{}}
\begin{quote}

Number of row fetched thus far.
\end{quote}

\sphinxstylestrong{Examples}

The following example uses the \sphinxcode{LAST\_ROW\_COUNT} function to display the
total number of rows fetched in the query.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    curid           INTEGER;
    v\PYGZus{}empno         NUMBER(4);
    v\PYGZus{}ename         VARCHAR2(10);
    v\PYGZus{}hiredate      DATE;
    v\PYGZus{}sal           NUMBER(7,2);
    v\PYGZus{}comm          NUMBER(7,2);
    v\PYGZus{}sql           VARCHAR2(50) := \PYGZsq{}SELECT empno, ename, hiredate, sal, \PYGZsq{} \textbar{}\textbar{}
                                    \PYGZsq{}comm FROM emp\PYGZsq{};
    v\PYGZus{}status        INTEGER;
BEGIN
    curid := DBMS\PYGZus{}SQL.OPEN\PYGZus{}CURSOR;
    DBMS\PYGZus{}SQL.PARSE(curid,v\PYGZus{}sql,DBMS\PYGZus{}SQL.native);
    DBMS\PYGZus{}SQL.DEFINE\PYGZus{}COLUMN(curid,1,v\PYGZus{}empno);
    DBMS\PYGZus{}SQL.DEFINE\PYGZus{}COLUMN(curid,2,v\PYGZus{}ename,10);
    DBMS\PYGZus{}SQL.DEFINE\PYGZus{}COLUMN(curid,3,v\PYGZus{}hiredate);
    DBMS\PYGZus{}SQL.DEFINE\PYGZus{}COLUMN(curid,4,v\PYGZus{}sal);
    DBMS\PYGZus{}SQL.DEFINE\PYGZus{}COLUMN(curid,5,v\PYGZus{}comm);

    v\PYGZus{}status := DBMS\PYGZus{}SQL.EXECUTE(curid);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}EMPNO  ENAME       HIREDATE    SAL       COMM\PYGZsq{});
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}  \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}  \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}  \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}  \PYGZsq{} \textbar{}\textbar{}
        \PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZsq{});
    LOOP
        v\PYGZus{}status := DBMS\PYGZus{}SQL.FETCH\PYGZus{}ROWS(curid);
        EXIT WHEN v\PYGZus{}status = 0;
        DBMS\PYGZus{}SQL.COLUMN\PYGZus{}VALUE(curid,1,v\PYGZus{}empno);
        DBMS\PYGZus{}SQL.COLUMN\PYGZus{}VALUE(curid,2,v\PYGZus{}ename);
        DBMS\PYGZus{}SQL.COLUMN\PYGZus{}VALUE(curid,3,v\PYGZus{}hiredate);
        DBMS\PYGZus{}SQL.COLUMN\PYGZus{}VALUE(curid,4,v\PYGZus{}sal);
        DBMS\PYGZus{}SQL.COLUMN\PYGZus{}VALUE(curid,4,v\PYGZus{}sal);
        DBMS\PYGZus{}SQL.COLUMN\PYGZus{}VALUE(curid,5,v\PYGZus{}comm);
        DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(v\PYGZus{}empno \textbar{}\textbar{} \PYGZsq{}   \PYGZsq{} \textbar{}\textbar{} RPAD(v\PYGZus{}ename,10) \textbar{}\textbar{} \PYGZsq{}  \PYGZsq{} \textbar{}\textbar{}
            TO\PYGZus{}CHAR(v\PYGZus{}hiredate,\PYGZsq{}yyyy\PYGZhy{}mm\PYGZhy{}dd\PYGZsq{}) \textbar{}\textbar{} \PYGZsq{} \PYGZsq{} \textbar{}\textbar{}
            TO\PYGZus{}CHAR(v\PYGZus{}sal,\PYGZsq{}9,999.99\PYGZsq{}) \textbar{}\textbar{} \PYGZsq{} \PYGZsq{} \textbar{}\textbar{}
            TO\PYGZus{}CHAR(NVL(v\PYGZus{}comm,0),\PYGZsq{}9,999.99\PYGZsq{}));
    END LOOP;
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Number of rows: \PYGZsq{} \textbar{}\textbar{} DBMS\PYGZus{}SQL.LAST\PYGZus{}ROW\PYGZus{}COUNT);
    DBMS\PYGZus{}SQL.CLOSE\PYGZus{}CURSOR(curid);
END;

EMPNO  ENAME       HIREDATE    SAL       COMM
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}  \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}  \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}  \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}  \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
7369   SMITH       1980\PYGZhy{}12\PYGZhy{}17    800.00       .00
7499   ALLEN       1981\PYGZhy{}02\PYGZhy{}20  1,600.00    300.00
7521   WARD        1981\PYGZhy{}02\PYGZhy{}22  1,250.00    500.00
7566   JONES       1981\PYGZhy{}04\PYGZhy{}02  2,975.00       .00
7654   MARTIN      1981\PYGZhy{}09\PYGZhy{}28  1,250.00  1,400.00
7698   BLAKE       1981\PYGZhy{}05\PYGZhy{}01  2,850.00       .00
7782   CLARK       1981\PYGZhy{}06\PYGZhy{}09  2,450.00       .00
7788   SCOTT       1987\PYGZhy{}04\PYGZhy{}19  3,000.00       .00
7839   KING        1981\PYGZhy{}11\PYGZhy{}17  5,000.00       .00
7844   TURNER      1981\PYGZhy{}09\PYGZhy{}08  1,500.00       .00
7876   ADAMS       1987\PYGZhy{}05\PYGZhy{}23  1,100.00       .00
7900   JAMES       1981\PYGZhy{}12\PYGZhy{}03    950.00       .00
7902   FORD        1981\PYGZhy{}12\PYGZhy{}03  3,000.00       .00
7934   MILLER      1982\PYGZhy{}01\PYGZhy{}23  1,300.00       .00
Number of rows: 14
\end{sphinxVerbatim}

\newpage


\subsection{\index{OPEN\_CURSOR}OPEN\_CURSOR}
\label{\detokenize{open_cursor::doc}}\label{\detokenize{open_cursor:open-cursor}}
The \sphinxcode{OPEN\_CURSOR} function creates a new cursor. A cursor must be used to
parse and execute any dynamic SQL statement. Once a cursor has been
opened, it can be re-used with the same or different SQL statements. The
cursor does not have to be closed and re-opened in order to be re-used.
\begin{quote}

\sphinxcode{\textless{}c\textgreater{} INTEGER OPEN\_CURSOR}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}c\textgreater{}}
\begin{quote}

Cursor ID number associated with the newly created cursor.
\end{quote}

Examples

The following example creates a new cursor:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    curid           INTEGER;
BEGIN
    curid := DBMS\PYGZus{}SQL.OPEN\PYGZus{}CURSOR;
            .
            .
            .
END;
\end{sphinxVerbatim}

\newpage


\subsection{\index{PARSE}PARSE}
\label{\detokenize{parse::doc}}\label{\detokenize{parse:parse}}
The \sphinxcode{PARSE} procedure parses a SQL command or SPL block. If the SQL
command is a DDL command, it is immediately executed and does not
require running the \sphinxcode{EXECUTE} function.
\begin{quote}

\sphinxcode{PARSE(\textless{}c\textgreater{} INTEGER, \textless{}statement\textgreater{} VARCHAR2, \textless{}language\_flag\textgreater{} INTEGER)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}c\textgreater{}}
\begin{quote}

Cursor ID of an open cursor.
\end{quote}

\sphinxcode{\textless{}statement\textgreater{}}
\begin{quote}

SQL command or SPL block to be parsed. A SQL command must not end with
the semi-colon terminator, however an SPL block does require the
semi-colon terminator.
\end{quote}

\sphinxcode{\textless{}language\_flag\textgreater{}}
\begin{quote}

Language flag provided for compatibility with Oracle syntax. Use
\sphinxcode{DBMS\_SQL.V6, DBMS\_SQL.V7} or \sphinxcode{DBMS\_SQL.native}. This flag is ignored,
and all syntax is assumed to be in EnterpriseDB Advanced Server form.
\end{quote}

\sphinxstylestrong{Examples}

The following anonymous block creates a table named, \sphinxcode{job}. Note that DDL
statements are executed immediately by the \sphinxcode{PARSE} procedure and do not
require a separate \sphinxcode{EXECUTE} step.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    curid           INTEGER;
BEGIN
    curid := DBMS\PYGZus{}SQL.OPEN\PYGZus{}CURSOR;
    DBMS\PYGZus{}SQL.PARSE(curid, \PYGZsq{}CREATE TABLE job (jobno NUMBER(3), \PYGZsq{} \textbar{}\textbar{}
        \PYGZsq{}jname VARCHAR2(9))\PYGZsq{},DBMS\PYGZus{}SQL.native);
    DBMS\PYGZus{}SQL.CLOSE\PYGZus{}CURSOR(curid);
END;
\end{sphinxVerbatim}

The following inserts two rows into the job table.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    curid           INTEGER;
    v\PYGZus{}sql           VARCHAR2(50);
    v\PYGZus{}status        INTEGER;
BEGIN
    curid := DBMS\PYGZus{}SQL.OPEN\PYGZus{}CURSOR;
    v\PYGZus{}sql := \PYGZsq{}INSERT INTO job VALUES (100, \PYGZsq{}\PYGZsq{}ANALYST\PYGZsq{}\PYGZsq{})\PYGZsq{};
    DBMS\PYGZus{}SQL.PARSE(curid, v\PYGZus{}sql, DBMS\PYGZus{}SQL.native);
    v\PYGZus{}status := DBMS\PYGZus{}SQL.EXECUTE(curid);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Number of rows processed: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}status);
    v\PYGZus{}sql := \PYGZsq{}INSERT INTO job VALUES (200, \PYGZsq{}\PYGZsq{}CLERK\PYGZsq{}\PYGZsq{})\PYGZsq{};
    DBMS\PYGZus{}SQL.PARSE(curid, v\PYGZus{}sql, DBMS\PYGZus{}SQL.native);
    v\PYGZus{}status := DBMS\PYGZus{}SQL.EXECUTE(curid);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Number of rows processed: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}status);
    DBMS\PYGZus{}SQL.CLOSE\PYGZus{}CURSOR(curid);
END;

Number of rows processed: 1
Number of rows processed: 1
\end{sphinxVerbatim}

The following anonymous block uses the \sphinxcode{DBMS\_SQL} package to execute a
block containing two \sphinxcode{INSERT} statements. Note that the end of the block
contains a terminating semi-colon, while in the prior example, each
individual \sphinxcode{INSERT} statement does not have a terminating semi-colon.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    curid           INTEGER;
    v\PYGZus{}sql           VARCHAR2(100);
    v\PYGZus{}status        INTEGER;
BEGIN
    curid := DBMS\PYGZus{}SQL.OPEN\PYGZus{}CURSOR;
    v\PYGZus{}sql := \PYGZsq{}BEGIN \PYGZsq{} \textbar{}\textbar{}
               \PYGZsq{}INSERT INTO job VALUES (300, \PYGZsq{}\PYGZsq{}MANAGER\PYGZsq{}\PYGZsq{}); \PYGZsq{}  \textbar{}\textbar{}
               \PYGZsq{}INSERT INTO job VALUES (400, \PYGZsq{}\PYGZsq{}SALESMAN\PYGZsq{}\PYGZsq{}); \PYGZsq{} \textbar{}\textbar{}
             \PYGZsq{}END;\PYGZsq{};
    DBMS\PYGZus{}SQL.PARSE(curid, v\PYGZus{}sql, DBMS\PYGZus{}SQL.native);
    v\PYGZus{}status := DBMS\PYGZus{}SQL.EXECUTE(curid);
    DBMS\PYGZus{}SQL.CLOSE\PYGZus{}CURSOR(curid);
END;
\end{sphinxVerbatim}

\newpage


\section{\index{DBMS\_UTILITY}DBMS\_UTILITY}
\label{\detokenize{dbms_utility::doc}}\label{\detokenize{dbms_utility:dbms-utility}}
The \sphinxcode{DBMS\_UTILITY} package provides support for the following various
utility programs:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|\Y{0.4}|\Y{0.1}|\Y{0.2}|\Y{0.3}|}
\hline

Function/Procedure
&
Function or Procedure
&
Return Type
&
Description
\\
\hline
ANALYZE\_DATABASE(method {[}, estimate\_rows {[}, estimate\_percent {[}, method\_opt {]}{]}{]})
&
Procedure
&
n/a
&
Analyze database tables.
\\
\hline
ANALYZE\_PART\_OBJECT(schema, object\_name {[}, object\_type {[}, command\_type {[}, command\_opt {[}, sample\_clause {]}{]}{]}{]})
&
Procedure
&
n/a
&
Analyze a partitioned table.
\\
\hline
ANALYZE\_SCHEMA(schema, method {[}, estimate\_rows {[}, estimate\_percent {[}, method\_opt {]}{]}{]})
&
Procedure
&
n/a
&
Analyze schema tables.
\\
\hline
CANONICALIZE(name, canon\_name OUT, canon\_len)
&
Procedure
&
n/a
&
Canonicalizes a string \textendash{} e.g., strips off white space.
\\
\hline
COMMA\_TO\_TABLE(list, tablen OUT, tab OUT)
&
Procedure
&
n/a
&
Convert a comma-delimited list of names to a table of names.
\\
\hline
DB\_VERSION(version OUT, compatibility OUT)
&
Procedure
&
n/a
&
Get the database version.
\\
\hline
EXEC\_DDL\_STATEMENT(parse\_string)
&
Procedure
&
n/a
&
Execute a DDL statement.
\\
\hline
FORMAT\_CALL\_STACK
&
Function
&
TEXT
&
Formats the current call stack.
\\
\hline
GET\_CPU\_TIME
&
Function
&
NUMBER
&
Get the current CPU time.
\\
\hline
GET\_DEPENDENCY(type, schema, name)
&
Procedure
&
n/a
&
Get objects that are dependent upon the given object..
\\
\hline
GET\_HASH\_VALUE(name, base, hash\_size)
&
Function
&
NUMBER
&
Compute a hash value.
\\
\hline
GET\_PARAMETER\_VALUE(parnam, intval OUT, strval OUT)
&
Procedure
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{4}}
BINARY\_INTEGER   \textbar{} Get database initialization parameter settings.
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline
GET\_TIME
&
Function
&
NUMBER
&
Get the current time.
\\
\hline
NAME\_TOKENIZE(name, a OUT, b OUT, c OUT, dblink OUT, nextpos OUT)
&
Procedure
&
n/a
&
Parse the given name into its component parts.
\\
\hline
TABLE\_TO\_COMMA(tab, tablen OUT, list OUT)
&
Procedure
&
n/a
&
Convert a table of names to a comma-delimited list.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Advanced Server’s implementation of \sphinxcode{DBMS\_UTILITY} is a partial
implementation when compared to Oracle’s version. Only those functions
and procedures listed in the table above are supported.

The following table lists the public variables available in the
\sphinxcode{DBMS\_UTILITY} package.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|\Y{0.3}|\Y{0.2}|\Y{0.1}|\Y{0.3}|}
\hline

Public Variables
&
Data Type
&
Value
&
Description
\\
\hline
inv\_error\_on\_restrictions
&
PLS\_INTEGER
&
1
&
Used by the INVALIDATE procedure.
\\
\hline
lname\_array
&
TABLE
&&
For lists of long names.
\\
\hline
uncl\_array
&
TABLE
&&
For lists of users and names.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\newpage


\subsection{\index{LNAME\_ARRAY}LNAME\_ARRAY}
\label{\detokenize{dbms_utility:lname-array}}\label{\detokenize{dbms_utility:id1}}
The \sphinxcode{LNAME\_ARRAY} is for storing lists of long names including
fully-qualified names.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
TYPE lname\PYGZus{}array IS {}`TABLE OF VARCHAR2(4000) INDEX BY BINARY\PYGZus{}INTEGER;
\end{sphinxVerbatim}


\subsection{\index{UNCL\_ARRAY}UNCL\_ARRAY}
\label{\detokenize{dbms_utility:uncl-array}}\label{\detokenize{dbms_utility:id2}}
The \sphinxcode{UNCL\_ARRAY} is for storing lists of users and names.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
TYPE uncl\PYGZus{}array IS TABLE OF VARCHAR2(227) INDEX BY BINARY\PYGZus{}INTEGER;
\end{sphinxVerbatim}

\newpage


\subsection{\index{ANALYZE\_DATABASE, ANALYZE SCHEMA and ANALYZE PART\_OBJECT}ANALYZE\_DATABASE, ANALYZE SCHEMA and ANALYZE PART\_OBJECT}
\label{\detokenize{dbms_utility:analyze-database-analyze-schema-and-analyze-part-object}}
The \sphinxcode{ANALYZE\_DATABASE(), ANALYZE\_SCHEMA() and ANALYZE\_PART\_OBJECT()}
procedures provide the capability to gather statistics on tables in the
database. When you execute the \sphinxcode{ANALYZE} statement, Postgres samples the
data in a table and records distribution statistics in the
\sphinxcode{pg\_statistics system} table.

\sphinxcode{ANALYZE\_DATABASE, ANALYZE\_SCHEMA}, and \sphinxcode{ANALYZE\_PART\_OBJECT} differ
primarily in the number of tables that are processed:
\begin{itemize}
\item {} 
\sphinxcode{ANALYZE\_DATABASE} analyzes all tables in all schemas within the current database.

\item {} 
\sphinxcode{ANALYZE\_SCHEMA} analyzes all tables in a given schema (within the current database).

\item {} 
\sphinxcode{ANALYZE\_PART\_OBJECT} analyzes a single table.

\end{itemize}

The syntax for the \sphinxcode{ANALYZE} commands are:
\begin{quote}

\sphinxcode{ANALYZE\_DATABASE(\textless{}method\textgreater{} VARCHAR2 {[}, \textless{}estimate\_rows\textgreater{} NUMBER}
\begin{quote}

\sphinxcode{{[}, \textless{}estimate\_percent\textgreater{} NUMBER {[}, \textless{}method\_opt\textgreater{} VARCHAR2 {]}{]}{]})}
\end{quote}

\sphinxcode{ANALYZE\_SCHEMA(\textless{}schema\textgreater{} VARCHAR2, \textless{}method\textgreater{} VARCHAR2}
\begin{quote}
\begin{quote}

\sphinxcode{{[}, \textless{}estimate\_rows\textgreater{} NUMBER {[}, \textless{}estimate\_percent\textgreater{} NUMBER}

\sphinxcode{{[}, \textless{}method\_opt\textgreater{} VARCHAR2 {]}{]}{]})}
\end{quote}

\sphinxcode{ANALYZE\_PART\_OBJECT(\textless{}schema\textgreater{} VARCHAR2, \textless{}object\_name\textgreater{} VARCHAR2}
\begin{quote}

\sphinxcode{{[}, \textless{}object\_type\textgreater{} CHAR {[}, \textless{}command\_type\textgreater{} CHAR}

\sphinxcode{{[}, \textless{}command\_opt\textgreater{} VARCHAR2 {[}, \textless{}sample\_clause\textgreater{} {]}{]}{]}{]})}
\end{quote}
\end{quote}
\end{quote}

\sphinxstylestrong{Parameters} - \sphinxcode{ANALYZE\_DATABASE} and \sphinxcode{ANALYZE\_SCHEMA}

\sphinxcode{\textless{}method\textgreater{}}
\begin{quote}

method determines whether the \sphinxcode{ANALYZE} procedure populates the
\sphinxcode{pg\_statistics} table or removes entries from the \sphinxcode{pg\_statistics} table.
If you specify a method of \sphinxcode{DELETE}, the \sphinxcode{ANALYZE} procedure removes the
relevant rows from \sphinxcode{pg\_statistics}. If you specify a method of \sphinxcode{COMPUTE} or
\sphinxcode{ESTIMATE}, the \sphinxcode{ANALYZE} procedure analyzes a table (or multiple tables)
and records the distribution information in pg\_statistics. There is no
difference between \sphinxcode{COMPUTE} and \sphinxcode{ESTIMATE}; both methods execute the
Postgres \sphinxcode{ANALYZE} statement. All other parameters are validated and then
ignored.
\end{quote}

\sphinxcode{\textless{}estimate\_rows\textgreater{}}
\begin{quote}

Number of rows upon which to base estimated statistics. One of
\sphinxcode{\textless{}estimate\_rows\textgreater{}} or \sphinxcode{\textless{}estimate\_percent\textgreater{}} must be specified if method is
\sphinxcode{ESTIMATE}.
\begin{quote}

This argument is ignored, but is included for compatibility.
\end{quote}
\end{quote}

\sphinxcode{\textless{}estimate\_percent\textgreater{}}
\begin{quote}

Percentage of rows upon which to base estimated statistics. One of
\sphinxcode{\textless{}estimate\_rows\textgreater{}} or \sphinxcode{\textless{}estimate\_percent\textgreater{}} must be specified if method is
\sphinxcode{ESTIMATE}.

This argument is ignored, but is included for compatibility.
\end{quote}

\sphinxcode{\textless{}method\_opt\textgreater{}}
\begin{quote}

Object types to be analyzed. Any combination of the following:

{[} \sphinxcode{FOR TABLE} {]}

{[} \sphinxcode{FOR ALL {[} INDEXED {]} COLUMNS {]} {[} SIZE n} {]}

{[} \sphinxcode{FOR ALL INDEXES} {]}

This argument is ignored, but is included for compatibility.
\end{quote}

\sphinxstylestrong{Parameters} - \sphinxcode{ANALYZE\_PART\_OBJECT}

\sphinxcode{\textless{}schema\textgreater{}}
\begin{quote}

Name of the schema whose objects are to be analyzed.
\end{quote}

\sphinxcode{\textless{}object\_name\textgreater{}}
\begin{quote}

Name of the partitioned object to be analyzed.
\end{quote}

\sphinxcode{\textless{}object\_type\textgreater{}}
\begin{quote}

Type of object to be analyzed. Valid values are: \sphinxcode{T} \textendash{} table, \sphinxcode{I} \textendash{} index.

This argument is ignored, but is included for compatibility.
\end{quote}

\sphinxcode{\textless{}command\_type\textgreater{}}
\begin{quote}

Type of analyze functionality to perform. Valid values are: \sphinxcode{E} - gather
estimated statistics based upon on a specified number of rows or a
percentage of rows in the \sphinxcode{\textless{}sample\_clause\textgreater{}} clause; \sphinxcode{C} - compute exact
statistics; or \sphinxcode{V} \textendash{} validate the structure and integrity of the
partitions.

This argument is ignored, but is included for compatibility.
\end{quote}

\sphinxcode{\textless{}command\_opt\textgreater{}}
\begin{quote}

For \sphinxcode{\textless{}command\_type\textgreater{}} \sphinxcode{C} or \sphinxcode{E}, can be any combination of:

{[} \sphinxcode{FOR TABLE} {]}

{[} \sphinxcode{FOR ALL COLUMNS} {]}

{[} \sphinxcode{FOR ALL LOCAL INDEXES} {]}

For \sphinxcode{\textless{}command\_type\textgreater{} V}, can be \sphinxcode{CASCADE} if \sphinxcode{\textless{}object\_type\textgreater{}} is \sphinxcode{T}.

This argument is ignored, but is included for compatibility.
\end{quote}

\sphinxcode{\textless{}sample\_clause\textgreater{}}
\begin{quote}

If \sphinxcode{\textless{}command\_type\textgreater{}} is \sphinxcode{E}, contains the following clause to specify the
number of rows or percentage or rows on which to base the estimate.
\end{quote}

\sphinxcode{SAMPLE \textless{}n\textgreater{} \{ ROWS \textbar{} PERCENT \}}
\begin{quote}

This argument is ignored, but is included for compatibility.
\end{quote}

\newpage


\subsection{\index{CANONICALIZE}CANONICALIZE}
\label{\detokenize{dbms_utility:canonicalize}}
The \sphinxcode{CANONICALIZE} procedure performs the following operations on an input
string:
\begin{itemize}
\item {} 
If the string is not double-quoted, verifies that it uses the characters of a legal identifier. If not, an exception is thrown. If the string is double-quoted, all characters are allowed.

\item {} 
If the string is not double-quoted and does not contain periods, uppercases all alphabetic characters and eliminates leading and trailing spaces.

\item {} 
If the string is double-quoted and does not contain periods, strips off the double quotes.

\item {} 
If the string contains periods and no portion of the string is double-quoted, uppercases each portion of the string and encloses each portion in double quotes.

\item {} 
If the string contains periods and portions of the string are double-quoted, returns the double-quoted portions unchanged including the double quotes and returns the non-double-quoted portions uppercased and enclosed in double quotes.

\sphinxcode{CANONICALIZE(\textless{}name\textgreater{} VARCHAR2, \textless{}canon\_name\textgreater{} OUT VARCHAR2},

\sphinxcode{\textless{}canon\_len\textgreater{} BINARY\_INTEGER)}

\end{itemize}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}name\textgreater{}}
\begin{quote}

String to be canonicalized.
\end{quote}

\sphinxcode{\textless{}canon\_name\textgreater{}}
\begin{quote}

The canonicalized string.
\end{quote}

\sphinxcode{\textless{}canon\_len\textgreater{}}
\begin{quote}

Number of bytes in \sphinxcode{\textless{}name\textgreater{}} to canonicalize starting from the first
character.
\end{quote}

\sphinxstylestrong{Examples}

The following procedure applies the \sphinxcode{CANONICALIZE} procedure on its input
parameter and displays the results.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
CREATE OR REPLACE PROCEDURE canonicalize (
    p\PYGZus{}name      VARCHAR2,
    p\PYGZus{}length    BINARY\PYGZus{}INTEGER DEFAULT 30
)
IS
    v\PYGZus{}canon     VARCHAR2(100);
BEGIN
    DBMS\PYGZus{}UTILITY.CANONICALIZE(p\PYGZus{}name,v\PYGZus{}canon,p\PYGZus{}length);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Canonicalized name ==\PYGZgt{}\PYGZsq{} \textbar{}\textbar{} v\PYGZus{}canon \textbar{}\textbar{} \PYGZsq{}\PYGZlt{}==\PYGZsq{});
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Length: \PYGZsq{} \textbar{}\textbar{} LENGTH(v\PYGZus{}canon));
EXCEPTION
    WHEN OTHERS THEN
        DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}SQLERRM: \PYGZsq{} \textbar{}\textbar{} SQLERRM);
        DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}SQLCODE: \PYGZsq{} \textbar{}\textbar{} SQLCODE);
END;

EXEC canonicalize(\PYGZsq{}Identifier\PYGZsq{})
Canonicalized name ==\PYGZgt{}IDENTIFIER\PYGZlt{}==
Length: 10

EXEC canonicalize(\PYGZsq{}\PYGZdq{}Identifier\PYGZdq{}\PYGZsq{})
Canonicalized name ==\PYGZgt{}Identifier\PYGZlt{}==
Length: 10

EXEC canonicalize(\PYGZsq{}\PYGZdq{}\PYGZus{}+142\PYGZpc{}\PYGZdq{}\PYGZsq{})
Canonicalized name ==\PYGZgt{}\PYGZus{}+142\PYGZpc{}\PYGZlt{}==
Length: 6

EXEC canonicalize(\PYGZsq{}abc.def.ghi\PYGZsq{})
Canonicalized name ==\PYGZgt{}\PYGZdq{}ABC\PYGZdq{}.\PYGZdq{}DEF\PYGZdq{}.\PYGZdq{}GHI\PYGZdq{}\PYGZlt{}==
Length: 17

EXEC canonicalize(\PYGZsq{}\PYGZdq{}abc.def.ghi\PYGZdq{}\PYGZsq{})
Canonicalized name ==\PYGZgt{}abc.def.ghi\PYGZlt{}==
Length: 11

EXEC canonicalize(\PYGZsq{}\PYGZdq{}abc\PYGZdq{}.def.\PYGZdq{}ghi\PYGZdq{}\PYGZsq{})
Canonicalized name ==\PYGZgt{}\PYGZdq{}abc\PYGZdq{}.\PYGZdq{}DEF\PYGZdq{}.\PYGZdq{}ghi\PYGZdq{}\PYGZlt{}==
Length: 17

EXEC canonicalize(\PYGZsq{}\PYGZdq{}abc.def\PYGZdq{}.ghi\PYGZsq{})
Canonicalized name ==\PYGZgt{}\PYGZdq{}abc.def\PYGZdq{}.\PYGZdq{}GHI\PYGZdq{}\PYGZlt{}==
Length: 15
\end{sphinxVerbatim}

\newpage


\subsection{\index{COMMA\_TO\_TABLE}COMMA\_TO\_TABLE}
\label{\detokenize{dbms_utility:comma-to-table}}
The \sphinxcode{COMMA\_TO\_TABLE} procedure converts a comma-delimited list of names
into a table of names. Each entry in the list becomes a table entry. The
names must be formatted as valid identifiers.
\begin{quote}

\sphinxcode{COMMA\_TO\_TABLE(\textless{}list\textgreater{} VARCHAR2, \textless{}tablen\textgreater{} OUT BINARY\_INTEGER},
\begin{quote}

\sphinxcode{\textless{}tab\textgreater{} OUT \{ LNAME\_ARRAY \textbar{} UNCL\_ARRAY \})}
\end{quote}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}list\textgreater{}}
\begin{quote}

Comma-delimited list of names.
\end{quote}

\sphinxcode{\textless{}tablen\textgreater{}}
\begin{quote}

Number of entries in \sphinxcode{\textless{}tab\textgreater{}}.
\end{quote}

\sphinxcode{\textless{}tab\textgreater{}}
\begin{quote}

Table containing the individual names in \sphinxcode{\textless{}list\textgreater{}}.
\end{quote}

\sphinxcode{LNAME\_ARRAY}
\begin{quote}

A \sphinxcode{DBMS\_UTILITY LNAME\_ARRAY} (as described in the {\hyperref[\detokenize{dbms_utility:lname-array}]{\sphinxcrossref{\DUrole{std,std-ref}{LNAME\_ARRAY}}}} section).
\end{quote}

\sphinxcode{\textless{}UNCL\_ARRAY\textgreater{}}
\begin{quote}

A \sphinxcode{DBMS\_UTILITY UNCL\_ARRAY} (as described in the {\hyperref[\detokenize{dbms_utility:uncl-array}]{\sphinxcrossref{\DUrole{std,std-ref}{UNCL\_ARRAY}}}} section).
\end{quote}

\sphinxstylestrong{Examples}

The following procedure uses the \sphinxcode{COMMA\_TO\_TABLE} procedure to convert a
list of names to a table. The table entries are then displayed.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
CREATE OR REPLACE PROCEDURE comma\PYGZus{}to\PYGZus{}table (
    p\PYGZus{}list      VARCHAR2
)
IS
    r\PYGZus{}lname     DBMS\PYGZus{}UTILITY.LNAME\PYGZus{}ARRAY;
    v\PYGZus{}length    BINARY\PYGZus{}INTEGER;
BEGIN
    DBMS\PYGZus{}UTILITY.COMMA\PYGZus{}TO\PYGZus{}TABLE(p\PYGZus{}list,v\PYGZus{}length,r\PYGZus{}lname);
    FOR i IN 1..v\PYGZus{}length LOOP
        DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(r\PYGZus{}lname(i));
    END LOOP;
END;

EXEC comma\PYGZus{}to\PYGZus{}table(\PYGZsq{}edb.dept, edb.emp, edb.jobhist\PYGZsq{})

edb.dept
edb.emp
edb.jobhist
\end{sphinxVerbatim}

\newpage


\subsection{\index{DB\_VERSION}DB\_VERSION}
\label{\detokenize{dbms_utility:db-version}}
The \sphinxcode{DB\_VERSION} procedure returns the version number of the database.
\begin{quote}

\sphinxcode{DB\_VERSION(\textless{}version\textgreater{} OUT VARCHAR2, \textless{}compatibility\textgreater{} OUT VARCHAR2)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}version\textgreater{}}
\begin{quote}

Database version number.
\end{quote}

\sphinxcode{\textless{}compatibility\textgreater{}}
\begin{quote}

Compatibility setting of the database. (To be implementation-defined as
to its meaning.)
\end{quote}

\sphinxstylestrong{Examples}

The following anonymous block displays the database version information.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    v\PYGZus{}version       VARCHAR2(150);
    v\PYGZus{}compat        VARCHAR2(150);
BEGIN
    DBMS\PYGZus{}UTILITY.DB\PYGZus{}VERSION(v\PYGZus{}version,v\PYGZus{}compat);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Version: \PYGZsq{}       \textbar{}\textbar{} v\PYGZus{}version);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Compatibility: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}compat);
END;

Version: EnterpriseDB 10.0.0 on i686\PYGZhy{}pc\PYGZhy{}linux\PYGZhy{}gnu, compiled by GCC gcc (GCC) 4.1.2 20080704 (Red Hat 4.1.2\PYGZhy{}48), 32\PYGZhy{}bit
Compatibility: EnterpriseDB 10.0.0 on i686\PYGZhy{}pc\PYGZhy{}linux\PYGZhy{}gnu, compiled by GCC gcc (GCC) 4.1.220080704 (Red Hat 4.1.2\PYGZhy{}48), 32\PYGZhy{}bit
\end{sphinxVerbatim}

\newpage


\subsection{\index{EXEC\_DDL\_STATEMENT}EXEC\_DDL\_STATEMENT}
\label{\detokenize{dbms_utility:exec-ddl-statement}}
The \sphinxcode{EXEC\_DDL\_STATEMENT} provides the capability to execute a \sphinxcode{DDL}
command.
\begin{quote}

\sphinxcode{EXEC\_DDL\_STATEMENT(\textless{}parse\_string\textgreater{} VARCHAR2)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}parse\_string\textgreater{}}
\begin{quote}

The DDL command to be executed.
\end{quote}

\sphinxstylestrong{Examples}

The following anonymous block creates the \sphinxcode{job} table.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
BEGIN
    DBMS\PYGZus{}UTILITY.EXEC\PYGZus{}DDL\PYGZus{}STATEMENT(
        \PYGZsq{}CREATE TABLE job (\PYGZsq{} \textbar{}\textbar{}
          \PYGZsq{}jobno NUMBER(3),\PYGZsq{} \textbar{}\textbar{}
          \PYGZsq{}jname VARCHAR2(9))\PYGZsq{}
    );
END;
\end{sphinxVerbatim}

If the \sphinxcode{\textless{}parse\_string\textgreater{}} does not include a valid DDL statement, Advanced Server returns the following error:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
edb=\PYGZsh{}  exec dbms\PYGZus{}utility.exec\PYGZus{}ddl\PYGZus{}statement(\PYGZsq{}select rownum from dual\PYGZsq{});
ERROR:  EDB\PYGZhy{}20001: \PYGZsq{}parse\PYGZus{}string\PYGZsq{} must be a valid DDL statement
\end{sphinxVerbatim}

In this case, Advanced Server’s behavior differs from Oracle’s; Oracle
accepts the invalid \sphinxcode{\textless{}parse\_string\textgreater{}} without complaint.

\newpage


\subsection{\index{FORMAT\_CALL\_STACK}FORMAT\_CALL\_STACK}
\label{\detokenize{dbms_utility:format-call-stack}}
The \sphinxcode{FORMAT\_CALL\_STACK} function returns the formatted contents of the
current call stack.
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{DBMS\_UTILITY.FORMAT\_CALL\_STACK}
\item[] \sphinxcode{return VARCHAR2}
\end{DUlineblock}
\end{quote}

This function can be used in a stored procedure, function or package to
return the current call stack in a readable format. This function is
useful for debugging purposes.

\newpage


\subsection{\index{GET\_CPU\_TIME}GET\_CPU\_TIME}
\label{\detokenize{dbms_utility:get-cpu-time}}
The \sphinxcode{GET\_CPU\_TIME} function returns the CPU time in hundredths of a
second from some arbitrary point in time.
\begin{quote}

\sphinxcode{\textless{}cputime\textgreater{} NUMBER GET\_CPU\_TIME}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}cputime\textgreater{}}
\begin{quote}

Number of hundredths of a second of CPU time.
\end{quote}

\sphinxstylestrong{Examples}

The following \sphinxcode{SELECT} command retrieves the current CPU time, which is
603 hundredths of a second or .0603 seconds.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
SELECT DBMS\PYGZus{}UTILITY.GET\PYGZus{}CPU\PYGZus{}TIME FROM DUAL;

get\PYGZus{}cpu\PYGZus{}time

\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}

        603
\end{sphinxVerbatim}

\newpage


\subsection{\index{GET\_DEPENDENCY}GET\_DEPENDENCY}
\label{\detokenize{dbms_utility:get-dependency}}
The \sphinxcode{GET\_DEPENDENCY} procedure provides the capability to list the
objects that are dependent upon the specified object. \sphinxcode{GET\_DEPENDENCY}
does not show dependencies for functions or procedures.
\begin{quote}

\sphinxcode{GET\_DEPENDENCY(\textless{}type\textgreater{} VARCHAR2, \textless{}schema\textgreater{} VARCHAR2},
\begin{quote}

\sphinxcode{\textless{}name\textgreater{} VARCHAR2)}
\end{quote}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}type\textgreater{}}
\begin{quote}

The object type of \sphinxcode{\textless{}name\textgreater{}}. Valid values are \sphinxcode{INDEX, PACKAGE, PACKAGE
BODY, SEQUENCE, TABLE, TRIGGER, TYPE} and \sphinxcode{VIEW}.
\end{quote}

\sphinxcode{\textless{}schema\textgreater{}}
\begin{quote}

Name of the schema in which \sphinxcode{\textless{}name\textgreater{}} exists.
\end{quote}

\sphinxcode{\textless{}name\textgreater{}}
\begin{quote}

Name of the object for which dependencies are to be obtained.
\end{quote}

\sphinxstylestrong{Examples}

The following anonymous block finds dependencies on the \sphinxcode{EMP table}.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
BEGIN
    DBMS\PYGZus{}UTILITY.GET\PYGZus{}DEPENDENCY(\PYGZsq{}TABLE\PYGZsq{},\PYGZsq{}public\PYGZsq{},\PYGZsq{}EMP\PYGZsq{});
END;

DEPENDENCIES ON public.EMP
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
*TABLE public.EMP()
*   CONSTRAINT c public.emp()
*   CONSTRAINT f public.emp()
*   CONSTRAINT p public.emp()
*   TYPE public.emp()
*   CONSTRAINT c public.emp()
*   CONSTRAINT f public.jobhist()
*   VIEW .empname\PYGZus{}view()
\end{sphinxVerbatim}

\newpage


\subsection{\index{GET\_HASH\_VALUE}GET\_HASH\_VALUE}
\label{\detokenize{dbms_utility:get-hash-value}}
The \sphinxcode{GET\_HASH\_VALUE} function provides the capability to compute a hash value for a given string.
\begin{quote}

\sphinxcode{\textless{}hash\textgreater{} NUMBER GET\_HASH\_VALUE(\textless{}name\textgreater{} VARCHAR2, \textless{}base\textgreater{} NUMBER},
\begin{quote}

\sphinxcode{\textless{}hash\_size\textgreater{} NUMBER)}
\end{quote}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}name\textgreater{}}
\begin{quote}

The string for which a hash value is to be computed.
\end{quote}

\sphinxcode{\textless{}base\textgreater{}}
\begin{quote}

Starting value at which hash values are to be generated.
\end{quote}

\sphinxcode{\textless{}hash\_size\textgreater{}}
\begin{quote}

The number of hash values for the desired hash table.
\end{quote}

\sphinxcode{\textless{}hash\textgreater{}}
\begin{quote}

The generated hash value.
\end{quote}

\sphinxstylestrong{Examples}

The following anonymous block creates a table of hash values using the
\sphinxcode{ename} column of the \sphinxcode{emp} table and then displays the key along with the
hash value. The hash values start at 100 with a maximum of 1024 distinct
values.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    v\PYGZus{}hash          NUMBER;
    TYPE hash\PYGZus{}tab IS TABLE OF NUMBER INDEX BY VARCHAR2(10);
    r\PYGZus{}hash          HASH\PYGZus{}TAB;
    CURSOR emp\PYGZus{}cur IS SELECT ename FROM emp;
BEGIN
    FOR r\PYGZus{}emp IN emp\PYGZus{}cur LOOP
        r\PYGZus{}hash(r\PYGZus{}emp.ename.. code\PYGZhy{}block:: text) :=
            DBMS\PYGZus{}UTILITY.GET\PYGZus{}HASH\PYGZus{}VALUE(r\PYGZus{}emp.ename,100,1024);
    END LOOP;
    FOR r\PYGZus{}emp IN emp\PYGZus{}cur LOOP
        DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(RPAD(r\PYGZus{}emp.ename,10) \textbar{}\textbar{} \PYGZsq{} \PYGZsq{} \textbar{}\textbar{}
            r\PYGZus{}hash(r\PYGZus{}emp.ename));
    END LOOP;
END;

SMITH      377
ALLEN      740
WARD       718.. code\PYGZhy{}block:: text
JONES      131
MARTIN     176
BLAKE      568
CLARK      621
SCOTT      1097
KING       235
TURNER     850
ADAMS      156
JAMES      942
FORD       775
MILLER     148
\end{sphinxVerbatim}

\newpage


\subsection{\index{GET\_PARAMETER\_VALUE}GET\_PARAMETER\_VALUE}
\label{\detokenize{dbms_utility:get-parameter-value}}
The \sphinxcode{GET\_PARAMETER\_VALUE} procedure provides the capability to retrieve
database initialization parameter settings.
\begin{quote}

\sphinxcode{\textless{}status\textgreater{} BINARY\_INTEGER GET\_PARAMETER\_VALUE(\textless{}parnam\textgreater{} VARCHAR2},
\begin{quote}

\sphinxcode{\textless{}intval\textgreater{} OUT INTEGER, \textless{}strval\textgreater{} OUT VARCHAR2)}
\end{quote}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}parnam\textgreater{}}
\begin{quote}

Name of the parameter whose value is to be returned. The parameters are
listed in the \sphinxcode{pg\_settings} system view.
\end{quote}

\sphinxcode{\textless{}intval\textgreater{}}
\begin{quote}

Value of an integer parameter or the length of \sphinxcode{\textless{}strval\textgreater{}}.
\end{quote}

\sphinxcode{\textless{}strval\textgreater{}}
\begin{quote}

Value of a string parameter.
\end{quote}

\sphinxcode{\textless{}status\textgreater{}}
\begin{quote}

Returns 0 if the parameter value is \sphinxcode{INTEGER} or \sphinxcode{BOOLEAN}. Returns 1 if the
parameter value is a string.
\end{quote}

\sphinxstylestrong{Examples}

The following anonymous block shows the values of two initialization
parameters.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    v\PYGZus{}intval        INTEGER;
    v\PYGZus{}strval        VARCHAR2(80);
BEGIN
    DBMS\PYGZus{}UTILITY.GET\PYGZus{}PARAMETER\PYGZus{}VALUE(\PYGZsq{}max\PYGZus{}fsm\PYGZus{}pages\PYGZsq{}, v\PYGZus{}intval, v\PYGZus{}strval);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}max\PYGZus{}fsm\PYGZus{}pages\PYGZsq{} \textbar{}\textbar{} \PYGZsq{}: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}intval);
    DBMS\PYGZus{}UTILITY.GET\PYGZus{}PARAMETER\PYGZus{}VALUE(\PYGZsq{}client\PYGZus{}encoding\PYGZsq{}, v\PYGZus{}intval, v\PYGZus{}strval);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}client\PYGZus{}encoding\PYGZsq{} \textbar{}\textbar{} \PYGZsq{}: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}strval);
END;

max\PYGZus{}fsm\PYGZus{}pages: 72625
client\PYGZus{}encoding: SQL\PYGZus{}ASCII
\end{sphinxVerbatim}

\newpage


\subsection{\index{GET\_TIME}GET\_TIME}
\label{\detokenize{dbms_utility:get-time}}
The \sphinxcode{GET\_TIME} function provides the capability to return the current
time in hundredths of a second.
\begin{quote}

\sphinxcode{\textless{}time\textgreater{} NUMBER GET\_TIME}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}time\textgreater{}}
\begin{quote}

Number of hundredths of a second from the time in which the program is
started.
\end{quote}

\sphinxstylestrong{Examples}

The following example shows calls to the \sphinxcode{GET\_TIME} function.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
SELECT DBMS\PYGZus{}UTILITY.GET\PYGZus{}TIME FROM DUAL;

 get\PYGZus{}time
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
  1555860

SELECT DBMS\PYGZus{}UTILITY.GET\PYGZus{}TIME FROM DUAL;

 get\PYGZus{}time
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
  1556037
\end{sphinxVerbatim}

\newpage


\subsection{\index{NAME\_TOKENIZE}NAME\_TOKENIZE}
\label{\detokenize{dbms_utility:name-tokenize}}
The \sphinxcode{NAME\_TOKENIZE} procedure parses a name into its component parts.
Names without double quotes are uppercased. The double quotes are
stripped from names with double quotes.
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{NAME\_TOKENIZE(\textless{}name\textgreater{} VARCHAR2, \textless{}a\textgreater{} OUT VARCHAR2},
\item[] \sphinxcode{\textless{}b\textgreater{} OUT VARCHAR2, \textless{}c\textgreater{} OUT VARCHAR2, \textless{}dblink\textgreater{} OUT VARCHAR2},
\item[] \sphinxcode{\textless{}nextpos\textgreater{} OUT BINARY\_INTEGER)}
\end{DUlineblock}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}name\textgreater{}}
\begin{quote}

String containing a name in the following format:

\sphinxcode{\textless{}a\textgreater{} {[}.\textless{}b\textgreater{} {[}.\textless{}c\textgreater{}{]}{]}{[}@\textless{}dblink\textgreater{} {]}}
\end{quote}

\sphinxcode{\textless{}a\textgreater{}}
\begin{quote}

Returns the leftmost component.
\end{quote}

\sphinxcode{\textless{}b\textgreater{}}
\begin{quote}

Returns the second component, if any.
\end{quote}

\sphinxcode{\textless{}c\textgreater{}}
\begin{quote}

Returns the third component, if any.
\end{quote}

\sphinxcode{\textless{}dblink\textgreater{}}
\begin{quote}

Returns the database link name.
\end{quote}

\sphinxcode{\textless{}nextpos\textgreater{}}
\begin{quote}

Position of the last character parsed in name.
\end{quote}

\sphinxstylestrong{Examples}

The following stored procedure is used to display the returned parameter
values of the \sphinxcode{NAME\_TOKENIZE} procedure for various names.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
CREATE OR REPLACE PROCEDURE name\PYGZus{}tokenize (
    p\PYGZus{}name          VARCHAR2
)
IS
    v\PYGZus{}a             VARCHAR2(30);
    v\PYGZus{}b             VARCHAR2(30);
    v\PYGZus{}c             VARCHAR2(30);
    v\PYGZus{}dblink        VARCHAR2(30);
    v\PYGZus{}nextpos       BINARY\PYGZus{}INTEGER;
BEGIN
    DBMS\PYGZus{}UTILITY.NAME\PYGZus{}TOKENIZE(p\PYGZus{}name,v\PYGZus{}a,v\PYGZus{}b,v\PYGZus{}c,v\PYGZus{}dblink,v\PYGZus{}nextpos);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}name   : \PYGZsq{} \textbar{}\textbar{} p\PYGZus{}name);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}a      : \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}a);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}b      : \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}b);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}c      : \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}c);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}dblink : \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}dblink);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}nextpos: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}nextpos);
END;
\end{sphinxVerbatim}

\newpage

Tokenize the name, \sphinxcode{emp}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
BEGIN
name\PYGZus{}tokenize(\PYGZsq{}emp\PYGZsq{});
END;
name
: emp
a
: EMP
b
:
c
:
dblink :
nextpos: 3
\end{sphinxVerbatim}

Tokenize the name, \sphinxcode{edb.list\_emp} :

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
BEGIN
name\PYGZus{}tokenize(\PYGZsq{}edb.list\PYGZus{}emp\PYGZsq{});
END;
name
:
a
:
b
:
c
:
dblink :
nextpos:
edb.list\PYGZus{}emp
EDB
LIST\PYGZus{}EMP
12
\end{sphinxVerbatim}

Tokenize the name, \sphinxcode{"edb"."Emp\_Admin".update\_emp\_sal :}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
BEGIN
name\PYGZus{}tokenize(\PYGZsq{}\PYGZdq{}edb\PYGZdq{}.\PYGZdq{}Emp\PYGZus{}Admin\PYGZdq{}.update\PYGZus{}emp\PYGZus{}sal\PYGZsq{});
END;
name
:
a
:
b
:
c
:
dblink :
nextpos:
\PYGZdq{}edb\PYGZdq{}.\PYGZdq{}Emp\PYGZus{}Admin\PYGZdq{}.update\PYGZus{}emp\PYGZus{}sal
edb
Emp\PYGZus{}Admin
UPDATE\PYGZus{}EMP\PYGZus{}SAL
32
\end{sphinxVerbatim}

\newpage

Tokenize the name \sphinxcode{edb.emp@edb\_dblink} :

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
BEGIN
Copyright © 2007 \PYGZhy{} 2019 EnterpriseDB Corporation. All rights reserved.
255Database Compatibility for Oracle® Developers
Built\PYGZhy{}in Package Guide
name\PYGZus{}tokenize(\PYGZsq{}edb.emp@edb\PYGZus{}dblink\PYGZsq{});
END;
name
:
a
:
b
:
c
:
dblink :
nextpos:
edb.emp@edb\PYGZus{}dblink
EDB
EMP
EDB\PYGZus{}DBLINK
18
\end{sphinxVerbatim}

\newpage


\subsection{\index{TABLE\_TO\_COMMA}TABLE\_TO\_COMMA}
\label{\detokenize{dbms_utility:table-to-comma}}
The \sphinxcode{TABLE\_TO\_COMMA} procedure converts table of names into a
comma-delimited list of names. Each table entry becomes a list entry.
The names must be formatted as valid identifiers.

\sphinxcode{TABLE\_TO\_COMMA(\textless{}tab\textgreater{} \{ LNAME\_ARRAY \textbar{} UNCL\_ARRAY \}},
\begin{quote}

\sphinxcode{\textless{}tablen\textgreater{} OUT BINARY\_INTEGER, \textless{}list\textgreater{} OUT VARCHAR2)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}tab\textgreater{}}
\begin{quote}

Table containing names.
\end{quote}

\sphinxcode{LNAME\_ARRAY}
\begin{quote}

A \sphinxcode{DBMS\_UTILITY LNAME\_ARRAY} (as described in the {\hyperref[\detokenize{dbms_utility:lname-array}]{\sphinxcrossref{\DUrole{std,std-ref}{LNAME ARRAY}}}} section.
\end{quote}

\sphinxcode{UNCL\_ARRAY}
\begin{quote}

A \sphinxcode{DBMS\_UTILITY UNCL\_ARRAY} (as described the {\hyperref[\detokenize{dbms_utility:uncl-array}]{\sphinxcrossref{\DUrole{std,std-ref}{UNCL\_ARRAY}}}} section).
\end{quote}

\sphinxcode{\textless{}tablen\textgreater{}}
\begin{quote}

Number of entries in \sphinxcode{\textless{}list\textgreater{}}.
\end{quote}

\sphinxcode{\textless{}list\textgreater{}}
\begin{quote}

Comma-delimited list of names from \sphinxcode{\textless{}tab\textgreater{}}.
\end{quote}

\sphinxstylestrong{Examples}

The following example first uses the \sphinxcode{COMMA\_TO\_TABLE} procedure to
convert a comma-delimited list to a table. The \sphinxcode{TABLE\_TO\_COMMA}
procedure then converts the table back to a comma-delimited list that is
displayed.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
CREATE OR REPLACE PROCEDURE table\PYGZus{}to\PYGZus{}comma (
    p\PYGZus{}list      VARCHAR2
)
IS
    r\PYGZus{}lname     DBMS\PYGZus{}UTILITY.LNAME\PYGZus{}ARRAY;
    v\PYGZus{}length    BINARY\PYGZus{}INTEGER;
    v\PYGZus{}listlen   BINARY\PYGZus{}INTEGER;
    v\PYGZus{}list      VARCHAR2(80);
BEGIN
    DBMS\PYGZus{}UTILITY.COMMA\PYGZus{}TO\PYGZus{}TABLE(p\PYGZus{}list,v\PYGZus{}length,r\PYGZus{}lname);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Table Entries\PYGZsq{});
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZsq{});
    FOR i IN 1..v\PYGZus{}length LOOP
        DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(r\PYGZus{}lname(i));
    END LOOP;
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZsq{});
    DBMS\PYGZus{}UTILITY.TABLE\PYGZus{}TO\PYGZus{}COMMA(r\PYGZus{}lname,v\PYGZus{}listlen,v\PYGZus{}list);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Comma\PYGZhy{}Delimited List: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}list);
END;

EXEC table\PYGZus{}to\PYGZus{}comma(\PYGZsq{}edb.dept, edb.emp, edb.jobhist\PYGZsq{})

Table Entries
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
edb.dept
edb.emp
edb.jobhist
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
Comma\PYGZhy{}Delimited List: edb.dept, edb.emp, edb.jobhist
\end{sphinxVerbatim}

\newpage


\section{\index{UTL\_ENCODE}UTL\_ENCODE}
\label{\detokenize{utl_encode::doc}}\label{\detokenize{utl_encode:utl-encode}}
The \sphinxcode{UTL\_ENCODE} package provides a way to encode and decode data.
Advanced Serve supports the following functions and procedures:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|\Y{0.4}|\Y{0.2}|\Y{0.4}|}
\hline

Function/Procedure
&
Return Type
&
Description
\\
\hline
BASE64\_DECODE(r)
&
RAW
&
Use the BASE64\_DECODE function to translate a Base64 encoded string to the original RAW value.
\\
\hline
BASE64\_ENCODE(r)
&
RAW
&
Use the BASE64\_ENCODE function to translate a RAW string to an encoded Base64 value.
\\
\hline
BASE64\_ENCODE(loid)
&
TEXT
&
Use the BASE64\_ENCODE function to translate a TEXT string to an encoded Base64 value.
\\
\hline
MIMEHEADER\_DECODE(buf)
&
VARCHAR2
&
Use the MIMEHEADER\_DECODE function to translate an encoded MIMEHEADER formatted string to it’s original value.
\\
\hline
MIMEHEADER\_ENCODE(buf, encode\_charset, encoding)
&
VARCHAR2
&
Use the MIMEHEADER\_ENCODE function to convert and encode a string in MIMEHEADER format.
\\
\hline
QUOTED\_PRINTABLE\_DECODE(r)
&
RAW
&
Use the QUOTED\_PRINTABLE\_DECODE function to translate an encoded string to a RAW value.
\\
\hline
QUOTED\_PRINTABLE\_ENCODE(r)
&
RAW
&
Use the QUOTED\_PRINTABLE\_ENCODE function to translate an input string to a quoted-printable formatted RAW value.
\\
\hline
TEXT\_DECODE(buf, encode\_charset, encoding)
&
VARCHAR2
&
Use the TEXT\_DECODE function to decode a string encoded by TEXT\_ENCODE.
\\
\hline
TEXT\_ENCODE(buf, encode\_charset, encoding)
&
VARCHAR2
&
Use the TEXT\_ENCODE function to translate a string to a user-specified character set, and then encode the string.
\\
\hline
UUDECODE(r)
&
RAW
&
Use the UUDECODE function to translate a uuencode encoded string to a RAW value.
\\
\hline
UUENCODE(r, type, filename, permission)
&
RAW
&
Use the UUENCODE function to translate a RAW string to an encoded uuencode value.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\newpage


\subsection{\index{BASE64\_DECODE}BASE64\_DECODE}
\label{\detokenize{base64_decode::doc}}\label{\detokenize{base64_decode:base64-decode}}
Use the \sphinxcode{BASE64\_DECODE} function to translate a Base64 encoded string to
the original value originally encoded by \sphinxcode{BASE64\_ENCODE}. The signature
is:
\begin{quote}

\sphinxcode{BASE64\_DECODE (\textless{}r\textgreater{} IN RAW)}
\end{quote}

This function returns a \sphinxcode{RAW} value.

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}r\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}r\textgreater{}} is the string that contains the Base64 encoded data that will be
translated to \sphinxcode{RAW} form.
\end{quote}

\sphinxstylestrong{Examples}

Before executing the following example, invoke the command:
\begin{quote}

\sphinxcode{SET bytea\_output = escape};
\end{quote}

This command instructs the server to escape any non-printable
characters, and to display \sphinxcode{BYTEA} or \sphinxcode{RAW} values onscreen in readable
form. For more information, please refer to the Postgres Core
Documentation available at:

\sphinxurl{https://www.postgresql.org/docs/12/static/datatype-binary.html}

The following example first encodes (using \sphinxcode{BASE64\_ENCODE}), and then
decodes (using \sphinxcode{BASE64\_DECODE}) a string that contains the text abc:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
edb=\PYGZsh{} SELECT UTL\PYGZus{}ENCODE.BASE64\PYGZus{}ENCODE(CAST (\PYGZsq{}abc\PYGZsq{} AS RAW));
 base64\PYGZus{}encode
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
 YWJj
(1 row)

edb=\PYGZsh{} SELECT UTL\PYGZus{}ENCODE.BASE64\PYGZus{}DECODE(CAST (\PYGZsq{}YWJj\PYGZsq{} AS RAW));
 base64\PYGZus{}decode
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
 abc
(1 row)
\end{sphinxVerbatim}

\newpage


\subsection{\index{BASE64\_ENCODE}BASE64\_ENCODE}
\label{\detokenize{base64_encode::doc}}\label{\detokenize{base64_encode:base64-encode}}
Use the \sphinxcode{BASE64\_ENCODE} function to translate and encode a string in
Base64 format (as described in RFC 4648). This function can be useful
when composing \sphinxcode{MIME} email that you intend to send using the \sphinxcode{UTL\_SMTP}
package. The \sphinxcode{BASE64\_ENCODE} function has two signatures:
\begin{quote}

\sphinxcode{BASE64\_ENCODE(\textless{}r\textgreater{} IN RAW)}
\end{quote}

and
\begin{quote}

\sphinxcode{BASE64\_ENCODE(\textless{}loid\textgreater{} IN OID)}
\end{quote}

This function returns a \sphinxcode{RAW} value or an \sphinxcode{OID}.

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}r\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}r\textgreater{}} specifies the \sphinxcode{RAW} string that will be translated to Base64.
\end{quote}

\sphinxcode{\textless{}loid\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}loid\textgreater{}} specifies the object ID of a large object that will be
translated to Base64.
\end{quote}

\sphinxstylestrong{Examples}

Before executing the following example, invoke the command:
\begin{quote}

\sphinxcode{SET bytea\_output = escape;}
\end{quote}

This command instructs the server to escape any non-printable
characters, and to display \sphinxcode{BYTEA} or \sphinxcode{RAW} values onscreen in readable
form. For more information, please refer to the Postgres Core
Documentation available at:

\sphinxurl{https://www.postgresql.org/docs/12/static/datatype-binary.html}

The following example first encodes (using \sphinxcode{BASE64\_ENCODE}), and then
decodes (using \sphinxcode{BASE64\_DECODE}) a string that contains the text \sphinxcode{abc}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
edb=\PYGZsh{} SELECT UTL\PYGZus{}ENCODE.BASE64\PYGZus{}ENCODE(CAST (\PYGZsq{}abc\PYGZsq{} AS RAW));
 base64\PYGZus{}encode
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
 YWJj
(1 row)

edb=\PYGZsh{} SELECT UTL\PYGZus{}ENCODE.BASE64\PYGZus{}DECODE(CAST (\PYGZsq{}YWJj\PYGZsq{} AS RAW));
 base64\PYGZus{}decode
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
 abc
(1 row)
\end{sphinxVerbatim}

\newpage


\subsection{\index{MIMEHEADER\_DECODE}MIMEHEADER\_DECODE}
\label{\detokenize{mimeheader_decode::doc}}\label{\detokenize{mimeheader_decode:mimeheader-decode}}
Use the \sphinxcode{MIMEHEADER\_DECODE} function to decode values that are encoded by
the \sphinxcode{MIMEHEADER\_ENCODE} function. The signature is:
\begin{quote}

\sphinxcode{MIMEHEADER\_DECODE(\textless{}buf\textgreater{} IN VARCHAR2)}
\end{quote}

This function returns a \sphinxcode{VARCHAR2} value.

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}buf\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}buf\textgreater{}} contains the value (encoded by \sphinxcode{MIMEHEADER\_ENCODE)} that will
be decoded.
\end{quote}

\sphinxstylestrong{Examples}

The following examples use the \sphinxcode{MIMEHEADER\_ENCODE} and \sphinxcode{MIMEHEADER\_DECODE}
functions to first encode, and then decode a string:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
edb=\PYGZsh{} SELECT UTL\PYGZus{}ENCODE.MIMEHEADER\PYGZus{}ENCODE(\PYGZsq{}What is the date?\PYGZsq{}) FROM DUAL;
      mimeheader\PYGZus{}encode
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
 =?UTF8?Q?What is the date??=
(1 row)

edb=\PYGZsh{} SELECT UTL\PYGZus{}ENCODE.MIMEHEADER\PYGZus{}DECODE(\PYGZsq{}=?UTF8?Q?What is the date??=\PYGZsq{}) FROM DUAL;
 mimeheader\PYGZus{}decode
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
 What is the date?
(1 row)
\end{sphinxVerbatim}

\newpage


\subsection{\index{MIMEHEADER\_ENCODE}MIMEHEADER\_ENCODE}
\label{\detokenize{mimeheader_encode::doc}}\label{\detokenize{mimeheader_encode:mimeheader-encode}}
Use the \sphinxcode{MIMEHEADER\_ENCODE} function to convert a string into mime header
format, and then encode the string. The signature is:
\begin{quote}

\sphinxcode{MIMEHEADER\_ENCODE(\textless{}buf\textgreater{} IN VARCHAR2, \textless{}encode\_charset\textgreater{} IN VARCHAR2}
\sphinxcode{DEFAULT NULL, \textless{}encoding\textgreater{} IN INTEGER DEFAULT NULL)}
\end{quote}

This function returns a \sphinxcode{VARCHAR2} value.

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}buf\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}buf\textgreater{}} contains the string that will be formatted and encoded. The
string is a \sphinxcode{VARCHAR2} value.
\end{quote}

\sphinxcode{\textless{}encode\_charset\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}encode\_charset\textgreater{}} specifies the character set to which the string
will be converted before being formatted and encoded. The default
value is \sphinxcode{NULL}.
\end{quote}

\sphinxcode{\textless{}encoding\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}encoding\textgreater{}} specifies the encoding type used when encoding the
string. You can specify:
\end{quote}
\begin{itemize}
\item {} 
\sphinxcode{Q} to enable quoted-printable encoding. If you do not specify a value,
\sphinxcode{MIMEHEADER\_ENCODE} will use quoted-printable encoding.

\item {} 
\sphinxcode{B} to enable base-64 encoding.

\end{itemize}

\sphinxstylestrong{Examples}

The following examples use the \sphinxcode{MIMEHEADER\_ENCODE} and \sphinxcode{MIMEHEADER\_DECODE}
functions to first encode, and then decode a string:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
edb=\PYGZsh{} SELECT UTL\PYGZus{}ENCODE.MIMEHEADER\PYGZus{}ENCODE(\PYGZsq{}What is the date?\PYGZsq{}) FROM DUAL;
      mimeheader\PYGZus{}encode
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
 =?UTF8?Q?What is the date??=
(1 row)

edb=\PYGZsh{} SELECT UTL\PYGZus{}ENCODE.MIMEHEADER\PYGZus{}DECODE(\PYGZsq{}=?UTF8?Q?What is the date??=\PYGZsq{}) FROM DUAL;
 mimeheader\PYGZus{}decode
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
 What is the date?
(1 row)
\end{sphinxVerbatim}

\newpage


\subsection{\index{QUOTED\_PRINTABLE\_DECODE}QUOTED\_PRINTABLE\_DECODE}
\label{\detokenize{quoted_printable_decode::doc}}\label{\detokenize{quoted_printable_decode:quoted-printable-decode}}
Use the \sphinxcode{QUOTED\_PRINTABLE\_DECODE} function to translate an encoded
quoted-printable string into a decoded RAW string.

The signature is:
\begin{quote}

\sphinxcode{QUOTED\_PRINTABLE\_DECODE(\textless{}r\textgreater{} IN RAW)}
\end{quote}

This function returns a \sphinxcode{RAW} value.

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}r\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}r\textgreater{}} contains the encoded string that will be decoded. The string is
a \sphinxcode{RAW} value, encoded by \sphinxcode{QUOTED\_PRINTABLE\_ENCODE}.
\end{quote}

\sphinxstylestrong{Examples}

Before executing the following example, invoke the command:
\begin{quote}

\sphinxcode{SET bytea\_output = escape;}
\end{quote}

This command instructs the server to escape any non-printable
characters, and to display \sphinxcode{BYTEA} or RAW values onscreen in readable
form. For more information, please refer to the Postgres Core
Documentation available at:

\sphinxurl{https://www.postgresql.org/docs/12/static/datatype-binary.html}

The following example first encodes and then decodes a string:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
edb=\PYGZsh{} SELECT UTL\PYGZus{}ENCODE.QUOTED\PYGZus{}PRINTABLE\PYGZus{}ENCODE(\PYGZsq{}E=mc2\PYGZsq{}) FROM DUAL;  quoted\PYGZus{}printable\PYGZus{}encode
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
 E=3Dmc2
(1 row)

edb=\PYGZsh{} SELECT UTL\PYGZus{}ENCODE.QUOTED\PYGZus{}PRINTABLE\PYGZus{}DECODE(\PYGZsq{}E=3Dmc2\PYGZsq{}) FROM DUAL;
 quoted\PYGZus{}printable\PYGZus{}decode
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
 E=mc2
(1 row)
\end{sphinxVerbatim}

\newpage


\subsection{\index{QUOTED\_PRINTABLE\_ENCODE}QUOTED\_PRINTABLE\_ENCODE}
\label{\detokenize{quoted_printable_encode::doc}}\label{\detokenize{quoted_printable_encode:quoted-printable-encode}}
Use the \sphinxcode{QUOTED\_PRINTABLE\_ENCODE} function to translate and encode a
string in quoted-printable format. The signature is:
\begin{quote}

\sphinxcode{QUOTED\_PRINTABLE\_ENCODE(\textless{}r\textgreater{} IN RAW)}
\end{quote}

This function returns a \sphinxcode{RAW} value.

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}r\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}r\textgreater{}} contains the string (a RAW value) that will be encoded in a
quoted-printable format.
\end{quote}

\sphinxstylestrong{Examples}

Before executing the following example, invoke the command:
\begin{quote}

\sphinxcode{SET bytea\_output = escape;}
\end{quote}

This command instructs the server to escape any non-printable
characters, and to display \sphinxcode{BYTEA} or \sphinxcode{RAW} values onscreen in readable
form. For more information, please refer to the Postgres Core
Documentation available at:

\sphinxurl{https://www.postgresql.org/docs/12/static/datatype-binary.html}

The following example first encodes and then decodes a string:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
edb=\PYGZsh{} SELECT UTL\PYGZus{}ENCODE.QUOTED\PYGZus{}PRINTABLE\PYGZus{}ENCODE(\PYGZsq{}E=mc2\PYGZsq{}) FROM DUAL;  quoted\PYGZus{}printable\PYGZus{}encode
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
 E=3Dmc2
(1 row)

edb=\PYGZsh{} SELECT UTL\PYGZus{}ENCODE.QUOTED\PYGZus{}PRINTABLE\PYGZus{}DECODE(\PYGZsq{}E=3Dmc2\PYGZsq{}) FROM DUAL;
 quoted\PYGZus{}printable\PYGZus{}decode
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
 E=mc2
(1 row)
\end{sphinxVerbatim}

\newpage


\subsection{\index{TEXT\_DECODE}TEXT\_DECODE}
\label{\detokenize{text_decode::doc}}\label{\detokenize{text_decode:text-decode}}
Use the \sphinxcode{TEXT\_DECODE} function to translate and decode an encoded string
to the \sphinxcode{VARCHAR2} value that was originally encoded by the \sphinxcode{TEXT\_ENCODE}
function. The signature is:
\begin{quote}

\sphinxcode{TEXT\_DECODE(\textless{}buf\textgreater{} IN VARCHAR2, \textless{}encode\_charset\textgreater{} IN VARCHAR2 DEFAULT}
\sphinxcode{NULL, \textless{}encoding\textgreater{} IN PLS\_INTEGER DEFAULT NULL)}
\end{quote}

This function returns a \sphinxcode{VARCHAR2} value.

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}buf\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}buf\textgreater{}} contains the encoded string that will be translated to the
original value encoded by \sphinxcode{TEXT\_ENCODE}.
\end{quote}

\sphinxcode{\textless{}encode\_charset\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}encode\_charset\textgreater{}} specifies the character set to which the string
will be translated before encoding. The default value is \sphinxcode{NULL}.
\end{quote}

\sphinxcode{\textless{}encoding\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}encoding\textgreater{}} specifies the encoding type used by \sphinxcode{TEXT\_DECODE}.
Specify:
\end{quote}
\begin{itemize}
\item {} 
\sphinxcode{UTL\_ENCODE.BASE64} to specify base-64 encoding.

\item {} 
\sphinxcode{UTL\_ENCODE.QUOTED\_PRINTABLE} to specify quoted printable encoding.
This is the default.

\end{itemize}

\sphinxstylestrong{Examples}

The following example uses the \sphinxcode{TEXT\_ENCODE} and \sphinxcode{TEXT\_DECODE} functions
to first encode, and then decode a string:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
edb=\PYGZsh{} SELECT UTL\PYGZus{}ENCODE.TEXT\PYGZus{}ENCODE(\PYGZsq{}What is the date?\PYGZsq{}, \PYGZsq{}BIG5\PYGZsq{},
UTL\PYGZus{}ENCODE.BASE64) FROM DUAL;
text\PYGZus{}encode
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
V2hhdCBpcyB0aGUgZGF0ZT8=
(1 row)
edb=\PYGZsh{} SELECT UTL\PYGZus{}ENCODE.TEXT\PYGZus{}DECODE(\PYGZsq{}V2hhdCBpcyB0aGUgZGF0ZT8=\PYGZsq{}, \PYGZsq{}BIG5\PYGZsq{},
UTL\PYGZus{}ENCODE.BASE64) FROM DUAL;
text\PYGZus{}decode
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
What is the date?
(1 row)
\end{sphinxVerbatim}

\newpage


\subsection{\index{TEXT\_ENCODE}TEXT\_ENCODE}
\label{\detokenize{text_encode::doc}}\label{\detokenize{text_encode:text-encode}}
Use the \sphinxcode{TEXT\_ENCODE} function to translate a string to a user-specified
character set, and then encode the string. The signature is:
\begin{quote}

\sphinxcode{TEXT\_DECODE(\textless{}buf\textgreater{} IN VARCHAR2, \textless{}encode\_charset\textgreater{} IN VARCHAR2 DEFAULT}
\sphinxcode{NULL, \textless{}encoding\textgreater{} IN PLS\_INTEGER DEFAULT NULL)}
\end{quote}

This function returns a \sphinxcode{VARCHAR2} value.

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}buf\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}buf\textgreater{}} contains the encoded string that will be translated to the
specified character set and encoded by \sphinxcode{TEXT\_ENCODE}.
\end{quote}

\sphinxcode{\textless{}encode\_charset\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}encode\_charset\textgreater{}} specifies the character set to which the value
will be translated before encoding. The default value is \sphinxcode{NULL}.
\end{quote}

\sphinxcode{\textless{}encoding\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}encoding\textgreater{}} specifies the encoding type used by \sphinxcode{TEXT\_ENCODE}.
Specify:
\end{quote}
\begin{itemize}
\item {} 
\sphinxcode{UTL\_ENCODE.BASE64} to specify base-64 encoding.

\item {} 
\sphinxcode{UTL\_ENCODE.QUOTED\_PRINTABLE} to specify quoted printable encoding.
This is the default.

\end{itemize}

\sphinxstylestrong{Examples}

The following example uses the \sphinxcode{TEXT\_ENCODE} and \sphinxcode{TEXT\_DECODE} functions
to first encode, and then decode a string:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
edb=\PYGZsh{} SELECT UTL\PYGZus{}ENCODE.TEXT\PYGZus{}ENCODE(\PYGZsq{}What is the date?\PYGZsq{}, \PYGZsq{}BIG5\PYGZsq{},
UTL\PYGZus{}ENCODE.BASE64) FROM DUAL;
text\PYGZus{}encode
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
V2hhdCBpcyB0aGUgZGF0ZT8=
(1 row)
edb=\PYGZsh{} SELECT UTL\PYGZus{}ENCODE.TEXT\PYGZus{}DECODE(\PYGZsq{}V2hhdCBpcyB0aGUgZGF0ZT8=\PYGZsq{}, \PYGZsq{}BIG5\PYGZsq{},
UTL\PYGZus{}ENCODE.BASE64) FROM DUAL;
text\PYGZus{}decode
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
What is the date?
(1 row)
\end{sphinxVerbatim}

\newpage


\subsection{\index{UUDECODE}UUDECODE}
\label{\detokenize{uudecode::doc}}\label{\detokenize{uudecode:uudecode}}
Use the \sphinxcode{UUDECODE} function to translate and decode a uuencode encoded
string to the \sphinxcode{RAW} value that was originally encoded by the \sphinxcode{UUENCODE}
function. The signature is:
\begin{quote}

\sphinxcode{UUDECODE(\textless{}r\textgreater{} IN RAW)}
\end{quote}

This function returns a \sphinxcode{RAW} value.

If you are using the Advanced Server \sphinxcode{UUDECODE} function to decode uuencoded data that was created by the Oracle implementation of the \sphinxcode{UTL\_ENCODE.UUENCODE} function, then you must first set the Advanced Server configuration parameter \sphinxcode{utl\_encode.uudecode\_redwood} to \sphinxcode{TRUE} before invoking the Advanced Server \sphinxcode{UUDECODE} function on the Oracle-created data. (For example, this situation may occur if you migrated Oracle tables containing uuencoded data to an Advanced Server database.)

The uuencoded data created by the Oracle version of the \sphinxcode{UUENCODE}
function results in a format that differs from the uuencoded data
created by the Advanced Server \sphinxcode{UUENCODE} function. As a result,
attempting to use the Advanced Server \sphinxcode{UUDECODE} function on the Oracle
uuencoded data results in an error unless the configuration parameter
\sphinxcode{utl\_encode.uudecode\_redwood} is set to \sphinxcode{TRUE}.

However, if you are using the Advanced Server \sphinxcode{UUDECODE} function on
uuencoded data created by the Advanced Server \sphinxcode{UUENCODE} function, then
\sphinxcode{utl\_encode.uudecode\_redwood} must be set to \sphinxcode{FALSE}, which is the default
setting.

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}r\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}r\textgreater{}} contains the uuencoded string that will be translated to \sphinxcode{RAW}.
\end{quote}

\sphinxstylestrong{Examples}

Before executing the following example, invoke the command:
\begin{quote}

\sphinxcode{SET bytea\_output = escape;}
\end{quote}

This command instructs the server to escape any non-printable
characters, and to display \sphinxcode{BYTEA} or \sphinxcode{RAW} values onscreen in readable
form. For more information, please refer to the Postgres Core
Documentation available at:

\sphinxurl{https://www.postgresql.org/docs/12/static/datatype-binary.html}

The following example uses \sphinxcode{UUENCODE} and \sphinxcode{UUDECODE} to first encode and
then decode a string:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
edb=\PYGZsh{} SET bytea\PYGZus{}output = escape;
SET
edb=\PYGZsh{} SELECT UTL\PYGZus{}ENCODE.UUENCODE(\PYGZsq{}What is the date?\PYGZsq{}) FROM DUAL;
uuencode
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
begin 0 uuencode.txt\PYGZbs{}01215VAA=\PYGZdq{}!I\PYGZlt{}R!T:\PYGZam{}4@9\PYGZam{}\PYGZpc{}T93\PYGZbs{}\PYGZbs{}{}`\PYGZbs{}012{}`\PYGZbs{}012end\PYGZbs{}012
(1 row)
edb=\PYGZsh{} SELECT UTL\PYGZus{}ENCODE.UUDECODE
edb\PYGZhy{}\PYGZsh{} (\PYGZsq{}begin 0 uuencode.txt\PYGZbs{}01215VAA=\PYGZdq{}!I\PYGZlt{}R!T:\PYGZam{}4@9\PYGZam{}\PYGZpc{}T93\PYGZbs{}\PYGZbs{}{}`\PYGZbs{}012{}`\PYGZbs{}012end\PYGZbs{}012\PYGZsq{})
edb\PYGZhy{}\PYGZsh{} FROM DUAL;
uudecode
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
What is the date?
(1 row)
\end{sphinxVerbatim}

\newpage


\subsection{\index{UUENCODE}UUENCODE}
\label{\detokenize{uuencode::doc}}\label{\detokenize{uuencode:uuencode}}
Use the \sphinxcode{UUENCODE} function to translate \sphinxcode{RAW} data into a uuencode
formatted encoded string. The signature is:
\begin{quote}

\sphinxcode{UUENCODE(\textless{}r\textgreater{} IN RAW, \textless{}type\textgreater{} IN INTEGER DEFAULT 1, \textless{}filename\textgreater{} IN}
\sphinxcode{VARCHAR2 DEFAULT NULL, \textless{}permission\textgreater{} IN VARCHAR2 DEFAULT NULL)}
\end{quote}

This function returns a \sphinxcode{RAW} value.

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}r\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}r\textgreater{}} contains the RAW string that will be translated to uuencode
format.
\end{quote}

\sphinxcode{\textless{}type\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}type\textgreater{}} is an \sphinxcode{INTEGER} value or constant that specifies the type of
uuencoded string that will be returned; the default value is \sphinxcode{1}. The
possible values are:
\end{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
\sphinxstylestrong{Value}
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
\sphinxstylestrong{Constant}
\unskip}\relax \\
\hline
1
&
complete
\\
\hline
2
&
header\_piece
\\
\hline
3
&
middle\_piece
\\
\hline
4
&
end\_piece
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxcode{\textless{}filename\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}filename\textgreater{}} is a \sphinxcode{VARCHAR2} value that specifies the file name that you
want to embed in the encoded form; if you do not specify a file
name, \sphinxcode{UUENCODE} will include a filename of \sphinxcode{uuencode.txt} in the
encoded form.
\end{quote}

\sphinxcode{\textless{}permission\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}permission\textgreater{}} is a \sphinxcode{VARCHAR2} that specifies the permission mode; the
default value is \sphinxcode{NULL}.
\end{quote}

\sphinxstylestrong{Examples}

Before executing the following example, invoke the command:
\begin{quote}

SET bytea\_output = escape;
\end{quote}

This command instructs the server to escape any non-printable
characters, and to display \sphinxcode{BYTEA} or \sphinxcode{RAW} values onscreen in readable
form. For more information, please refer to the Postgres Core
Documentation available at:

\sphinxurl{https://www.postgresql.org/docs/12/static/datatype-binary.html}

\newpage

The following example uses \sphinxcode{UUENCODE} and \sphinxcode{UUDECODE} to first encode and
then decode a string:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
edb=\PYGZsh{} SET bytea\PYGZus{}output = escape;
SET
edb=\PYGZsh{} SELECT UTL\PYGZus{}ENCODE.UUENCODE(\PYGZsq{}What is the date?\PYGZsq{}) FROM DUAL;
                              uuencode
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
 begin 0 uuencode.txt\PYGZbs{}01215VAA=\PYGZdq{}!I\PYGZlt{}R!T:\PYGZam{}4@9\PYGZam{}\PYGZpc{}T93\PYGZbs{}\PYGZbs{}{}`\PYGZbs{}012{}`\PYGZbs{}012end\PYGZbs{}012
(1 row)

edb=\PYGZsh{} SELECT UTL\PYGZus{}ENCODE.UUDECODE
edb\PYGZhy{}\PYGZsh{} (\PYGZsq{}begin 0 uuencode.txt\PYGZbs{}01215VAA=\PYGZdq{}!I\PYGZlt{}R!T:\PYGZam{}4@9\PYGZam{}\PYGZpc{}T93\PYGZbs{}\PYGZbs{}{}`\PYGZbs{}012{}`\PYGZbs{}012end\PYGZbs{}012\PYGZsq{})
edb\PYGZhy{}\PYGZsh{} FROM DUAL;
     uudecode
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
 What is the date?
(1 row)
\end{sphinxVerbatim}

\newpage


\section{\index{UTL\_FILE}UTL\_FILE}
\label{\detokenize{utl_file::doc}}\label{\detokenize{utl_file:utl-file}}
The \sphinxcode{UTL\_FILE} package provides the capability to read from, and write to
files on the operating system’s file system. Non-superusers must be
granted \sphinxcode{EXECUTE} privilege on the \sphinxcode{UTL\_FILE} package by a superuser before
using any of the functions or procedures in the package. For example the
following command grants the privilege to user \sphinxcode{mary}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
GRANT EXECUTE ON PACKAGE SYS.UTL\PYGZus{}FILE TO mary;
\end{sphinxVerbatim}

Also, the operating system username, \sphinxcode{enterprisedb}, must have the
appropriate read and/or write permissions on the directories and files
to be accessed using the \sphinxcode{UTL\_FILE} functions and procedures. If the
required file permissions are not in place, an exception is thrown in
the \sphinxcode{UTL\_FILE} function or procedure.

A handle to the file to be written to, or read from is used to reference
the file. The \sphinxstyleemphasis{file handle} is defined by a public variable in the
\sphinxcode{UTL\_FILE} package named, \sphinxcode{UTL\_FILE.FILE\_TYPE}. A variable of type
\sphinxcode{FILE\_TYPE} must be declared to receive the file handle returned by
calling the \sphinxcode{FOPEN} function. The file handle is then used for all
subsequent operations on the file.

References to directories on the file system are done using the
directory name or alias that is assigned to the directory using the
\sphinxcode{CREATE DIRECTORY} command. The procedures and functions available in the
\sphinxcode{UTL\_FILE} package are listed in the following table:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|\Y{0.4}|\Y{0.2}|\Y{0.4}|}
\hline

Function/Procedure
&
Return Type
&
Description
\\
\hline
FCLOSE(file IN OUT)
&
n/a
&
Closes the specified file identified by file.
\\
\hline
FCLOSE\_ALL
&
n/a
&
Closes all open files.
\\
\hline
FCOPY(location, filename, dest\_dir, dest\_file {[}, start\_line {[}, end\_line {]} {]})
&
n/a
&
Copies filename in the directory identified by location to file, dest\_file, in directory, dest\_dir, starting from line, start\_line, to line, end\_line.
\\
\hline
FFLUSH(file)
&
n/a
&
Forces data in the buffer to be written to disk in the file identified by file.
\\
\hline
FOPEN(location, filename, open\_mode {[}, max\_linesize {]})
&
FILE\_TYPE
&
Opens file, filename, in the directory identified by location.
\\
\hline
FREMOVE(location, filename)
&
n/a
&
Removes the specified file from the file system.
\\
\hline
FRENAME(location, filename, dest\_dir, dest\_file {[}, overwrite {]})
&
n/a
&
Renames the specified file.
\\
\hline
GET\_LINE(file, buffer OUT)
&
n/a
&
Reads a line of text into variable, buffer, from the file identified by file.
\\
\hline
IS\_OPEN(file)
&
BOOLEAN
&
Determines whether or not the given file is open.
\\
\hline
NEW\_LINE(file {[}, lines {]})
&
n/a
&
Writes an end-of-line character sequence into the file.
\\
\hline
PUT(file, buffer)
&
n/a
&
Writes buffer to the given file. PUT does not write an end-of-line character sequence.
\\
\hline
PUT\_LINE(file, buffer)
&
n/a
&
Writes buffer to the given file. An end-of-line character sequence is added by the PUT\_LINE procedure.
\\
\hline
PUTF(file, format {[}, arg1 {]} {[}, …{]})
&
n/a
&
Writes a formatted string to the given file. Up to five substitution parameters, arg1,…arg5 may be specified for replacement in format.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Advanced Server’s implementation of \sphinxcode{UTL\_FILE} is a partial
implementation when compared to Oracle’s version. Only those functions
and procedures listed in the table above are supported.

\sphinxstylestrong{UTL\_FILE Exception Codes}

If a call to a \sphinxcode{UTL\_FILE} procedure or function raises an exception, you
can use the condition name to catch the exception. The \sphinxcode{UTL\_FILE} package
reports the following exception codes compatible with Oracle databases:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
\sphinxstylestrong{Exception Code}
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
\sphinxstylestrong{Condition name}
\unskip}\relax \\
\hline
-29283
&
invalid\_operation
\\
\hline
-29285
&
write\_error
\\
\hline
-29284
&
read\_error
\\
\hline
-29282
&
invalid\_filehandle
\\
\hline
-29287
&
invalid\_maxlinesize
\\
\hline
-29281
&
invalid\_mode
\\
\hline
-29280
&
invalid\_path
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{\index{Setting File Permissions with utl\_file.umask}Setting File Permissions with utl\_file.umask}
\label{\detokenize{utl_file:setting-file-permissions-with-utl-file-umask}}
When a \sphinxcode{UTL\_FILE} function or procedure creates a file, there are default
file permissions as shown by the following.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZhy{}rw\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} 1 enterprisedb enterprisedb 21 Jul 24 16:08 utlfile
\end{sphinxVerbatim}

Note that all permissions are denied on users belonging to the
\sphinxcode{enterprisedb} group as well as all other users. Only the \sphinxcode{enterprisedb}
user has read and write permissions on the created file.

If you wish to have a different set of file permissions on files created
by the \sphinxcode{UTL\_FILE} functions and procedures, you can accomplish this by
setting the \sphinxcode{utl\_file.umask} configuration parameter.

The \sphinxcode{utl\_file.umask} parameter sets the \sphinxstyleemphasis{file mode creation mask} or
simply, the \sphinxstyleemphasis{mask}, in a manner similar to the Linux \sphinxcode{umask} command. This
is for usage only within the Advanced Server \sphinxcode{UTL\_FILE} package.

\begin{sphinxadmonition}{note}{Note:}
The \sphinxcode{utl\_file.umask} parameter is not supported on Windows systems.
\end{sphinxadmonition}

The value specified for \sphinxcode{utl\_file.umask} is a 3 or 4-character octal
string that would be valid for the Linux \sphinxcode{umask} command. The setting
determines the permissions on files created by the \sphinxcode{UTL\_FILE} functions
and procedures. (Refer to any information source regarding Linux or Unix
systems for information on file permissions and the usage of the \sphinxcode{umask}
command.)

The following is an example of setting the file permissions with
\sphinxcode{utl\_file.umask}.

First, set up the directory in the file system to be used by the
\sphinxcode{UTL\_FILE} package. Be sure the operating system account, \sphinxcode{enterprisedb} or
\sphinxcode{postgres}, whichever is applicable, can read and write in the directory.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
mkdir /tmp/utldir
chmod 777 /tmp/utldir
\end{sphinxVerbatim}

The \sphinxcode{CREATE DIRECTORY} command is issued in \sphinxcode{psql} to create the directory
database object using the file system directory created in the preceding
step.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
CREATE DIRECTORY utldir AS \PYGZsq{}/tmp/utldir\PYGZsq{};
\end{sphinxVerbatim}

Set the \sphinxcode{utl\_file.umask} configuration parameter. The following setting
allows the file owner any permission. Group users and other users are
permitted any permission except for the execute permission.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
SET utl\PYGZus{}file.umask TO \PYGZsq{}0011\PYGZsq{};
\end{sphinxVerbatim}

In the same session during which the \sphinxcode{utl\_file.umask} parameter is set to
the desired value, run the \sphinxcode{UTL\_FILE} functions and procedures.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    v\PYGZus{}utlfile       UTL\PYGZus{}FILE.FILE\PYGZus{}TYPE;
    v\PYGZus{}directory     VARCHAR2(50) := \PYGZsq{}utldir\PYGZsq{};
    v\PYGZus{}filename      VARCHAR2(20) := \PYGZsq{}utlfile\PYGZsq{};
BEGIN
    v\PYGZus{}utlfile := UTL\PYGZus{}FILE.FOPEN(v\PYGZus{}directory, v\PYGZus{}filename, \PYGZsq{}w\PYGZsq{});
    UTL\PYGZus{}FILE.PUT\PYGZus{}LINE(v\PYGZus{}utlfile, \PYGZsq{}Simple one\PYGZhy{}line file\PYGZsq{});
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Created file: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}filename);
    UTL\PYGZus{}FILE.FCLOSE(v\PYGZus{}utlfile);
END;
\end{sphinxVerbatim}

The permission settings on the resulting file show that group users and other users have read and write permissions on the file as well as the file owner.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} pwd
/tmp/utldir
\PYGZdl{} ls \PYGZhy{}l
total 4
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{} 1 enterprisedb enterprisedb 21 Jul 24 16:04 utlfile
\end{sphinxVerbatim}

This parameter can also be set on a per role basis with the \sphinxcode{ALTER ROLE}
command, on a per database basis with the \sphinxcode{ALTER DATABASE} command, or for
the entire database server instance by setting it in the \sphinxcode{postgresql.conf}
file.


\subsection{\index{FCLOSE}FCLOSE}
\label{\detokenize{utl_file:fclose}}
The \sphinxcode{FCLOSE} procedure closes an open file.
\begin{quote}

\sphinxcode{FCLOSE(\textless{}file\textgreater{} IN OUT FILE\_TYPE)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}file\textgreater{}}

Variable of type \sphinxcode{FILE\_TYPE} containing a file handle of the file to be
closed.


\subsection{\index{FCLOSE\_ALL}FCLOSE\_ALL}
\label{\detokenize{utl_file:fclose-all}}
The \sphinxcode{FLCLOSE\_ALL} procedures closes all open files. The procedure
executes successfully even if there are no open files to close.
\begin{quote}

\sphinxcode{FCLOSE\_ALL}
\end{quote}


\subsection{\index{FCOPY}FCOPY}
\label{\detokenize{utl_file:fcopy}}
The \sphinxcode{FCOPY} procedure copies text from one file to another.
\begin{quote}

\sphinxcode{FCOPY(\textless{}location\textgreater{} VARCHAR2, \textless{}filename\textgreater{} VARCHAR2},
\begin{quote}

\sphinxcode{\textless{}dest\_dir\textgreater{} VARCHAR2, \textless{}dest\_file\textgreater{} VARCHAR2}

{[}, \sphinxcode{\textless{}start\_line\textgreater{} PLS\_INTEGER {[}, \textless{}end\_line\textgreater{} PLS\_INTEGER} {]} {]})
\end{quote}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}location\textgreater{}}
\begin{quote}

Directory name, as stored in \sphinxcode{pg\_catalog.edb\_dir.dirname}, of the
directory containing the file to be copied.
\end{quote}

\sphinxcode{\textless{}filename\textgreater{}}
\begin{quote}

Name of the source file to be copied.
\end{quote}

\sphinxcode{\textless{}dest\_dir\textgreater{}}
\begin{quote}

Directory name, as stored in \sphinxcode{pg\_catalog.edb\_dir.dirname}, of the
directory to which the file is to be copied.
\end{quote}

\sphinxcode{\textless{}dest\_file\textgreater{}}
\begin{quote}

Name of the destination file.
\end{quote}

\sphinxcode{\textless{}start\_line\textgreater{}}
\begin{quote}

Line number in the source file from which copying will begin. The
default is 1.
\end{quote}

\sphinxcode{\textless{}end\_line\textgreater{}}
\begin{quote}

Line number of the last line in the source file to be copied. If omitted
or null, copying will go to the last line of the file.
\end{quote}

\sphinxstylestrong{Examples}

The following makes a copy of a file, \sphinxcode{C:\textbackslash{}TEMP\textbackslash{}EMPDIR\textbackslash{}empfile.csv},
containing a comma-delimited list of employees from the \sphinxcode{emp} table. The
copy, \sphinxcode{empcopy.csv}, is then listed.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
CREATE DIRECTORY empdir AS \PYGZsq{}C:/TEMP/EMPDIR\PYGZsq{};

DECLARE
    v\PYGZus{}empfile       UTL\PYGZus{}FILE.FILE\PYGZus{}TYPE;
    v\PYGZus{}src\PYGZus{}dir       VARCHAR2(50) := \PYGZsq{}empdir\PYGZsq{};
    v\PYGZus{}src\PYGZus{}file      VARCHAR2(20) := \PYGZsq{}empfile.csv\PYGZsq{};
    v\PYGZus{}dest\PYGZus{}dir      VARCHAR2(50) := \PYGZsq{}empdir\PYGZsq{};
    v\PYGZus{}dest\PYGZus{}file     VARCHAR2(20) := \PYGZsq{}empcopy.csv\PYGZsq{};
    v\PYGZus{}emprec        VARCHAR2(120);
    v\PYGZus{}count         INTEGER := 0;
BEGIN
    UTL\PYGZus{}FILE.FCOPY(v\PYGZus{}src\PYGZus{}dir,v\PYGZus{}src\PYGZus{}file,v\PYGZus{}dest\PYGZus{}dir,v\PYGZus{}dest\PYGZus{}file);
    v\PYGZus{}empfile := UTL\PYGZus{}FILE.FOPEN(v\PYGZus{}dest\PYGZus{}dir,v\PYGZus{}dest\PYGZus{}file,\PYGZsq{}r\PYGZsq{});
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}The following is the destination file, \PYGZsq{}\PYGZsq{}\PYGZsq{} \textbar{}\textbar{}
        v\PYGZus{}dest\PYGZus{}file \textbar{}\textbar{} \PYGZsq{}\PYGZsq{}\PYGZsq{}\PYGZsq{});
    LOOP
        UTL\PYGZus{}FILE.GET\PYGZus{}LINE(v\PYGZus{}empfile,v\PYGZus{}emprec);
        DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(v\PYGZus{}emprec);
        v\PYGZus{}count := v\PYGZus{}count + 1;
    END LOOP;
    EXCEPTION
        WHEN NO\PYGZus{}DATA\PYGZus{}FOUND THEN
            UTL\PYGZus{}FILE.FCLOSE(v\PYGZus{}empfile);
            DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(v\PYGZus{}count \textbar{}\textbar{} \PYGZsq{} records retrieved\PYGZsq{});
        WHEN OTHERS THEN
            DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}SQLERRM: \PYGZsq{} \textbar{}\textbar{} SQLERRM);
            DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}SQLCODE: \PYGZsq{} \textbar{}\textbar{} SQLCODE);
END;

The following is the destination file, \PYGZsq{}empcopy.csv\PYGZsq{}
7369,SMITH,CLERK,7902,17\PYGZhy{}DEC\PYGZhy{}80,800,,20
7499,ALLEN,SALESMAN,7698,20\PYGZhy{}FEB\PYGZhy{}81,1600,300,30
7521,WARD,SALESMAN,7698,22\PYGZhy{}FEB\PYGZhy{}81,1250,500,30
7566,JONES,MANAGER,7839,02\PYGZhy{}APR\PYGZhy{}81,2975,,20
7654,MARTIN,SALESMAN,7698,28\PYGZhy{}SEP\PYGZhy{}81,1250,1400,30
7698,BLAKE,MANAGER,7839,01\PYGZhy{}MAY\PYGZhy{}81,2850,,30
7782,CLARK,MANAGER,7839,09\PYGZhy{}JUN\PYGZhy{}81,2450,,10
7788,SCOTT,ANALYST,7566,19\PYGZhy{}APR\PYGZhy{}87,3000,,20
7839,KING,PRESIDENT,,17\PYGZhy{}NOV\PYGZhy{}81,5000,,10
7844,TURNER,SALESMAN,7698,08\PYGZhy{}SEP\PYGZhy{}81,1500,0,30
7876,ADAMS,CLERK,7788,23\PYGZhy{}MAY\PYGZhy{}87,1100,,20
7900,JAMES,CLERK,7698,03\PYGZhy{}DEC\PYGZhy{}81,950,,30
7902,FORD,ANALYST,7566,03\PYGZhy{}DEC\PYGZhy{}81,3000,,20
7934,MILLER,CLERK,7782,23\PYGZhy{}JAN\PYGZhy{}82,1300,,10
14 records retrieved
\end{sphinxVerbatim}


\subsection{\index{FFLUSH}FFLUSH}
\label{\detokenize{utl_file:fflush}}
The \sphinxcode{FFLUSH} procedure flushes unwritten data from the write buffer to the
file.
\begin{quote}

\sphinxcode{FFLUSH(\textless{}file\textgreater{} FILE\_TYPE)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}file\textgreater{}}
\begin{quote}

Variable of type \sphinxcode{FILE\_TYPE} containing a file handle.
\end{quote}

\sphinxstylestrong{Examples}

Each line is flushed after the \sphinxcode{NEW\_LINE} procedure is called.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    v\PYGZus{}empfile       UTL\PYGZus{}FILE.FILE\PYGZus{}TYPE;
    v\PYGZus{}directory     VARCHAR2(50) := \PYGZsq{}empdir\PYGZsq{};
    v\PYGZus{}filename      VARCHAR2(20) := \PYGZsq{}empfile.csv\PYGZsq{};
    CURSOR emp\PYGZus{}cur IS SELECT * FROM emp ORDER BY empno;
BEGIN
    v\PYGZus{}empfile := UTL\PYGZus{}FILE.FOPEN(v\PYGZus{}directory,v\PYGZus{}filename,\PYGZsq{}w\PYGZsq{});
    FOR i IN emp\PYGZus{}cur LOOP
        UTL\PYGZus{}FILE.PUT(v\PYGZus{}empfile,i.empno);
        UTL\PYGZus{}FILE.PUT(v\PYGZus{}empfile,\PYGZsq{},\PYGZsq{});
        UTL\PYGZus{}FILE.PUT(v\PYGZus{}empfile,i.ename);
        UTL\PYGZus{}FILE.PUT(v\PYGZus{}empfile,\PYGZsq{},\PYGZsq{});
        UTL\PYGZus{}FILE.PUT(v\PYGZus{}empfile,i.job);
        UTL\PYGZus{}FILE.PUT(v\PYGZus{}empfile,\PYGZsq{},\PYGZsq{});
        UTL\PYGZus{}FILE.PUT(v\PYGZus{}empfile,i.mgr);
        UTL\PYGZus{}FILE.PUT(v\PYGZus{}empfile,\PYGZsq{},\PYGZsq{});
        UTL\PYGZus{}FILE.PUT(v\PYGZus{}empfile,i.hiredate);
        UTL\PYGZus{}FILE.PUT(v\PYGZus{}empfile,\PYGZsq{},\PYGZsq{});
        UTL\PYGZus{}FILE.PUT(v\PYGZus{}empfile,i.sal);
        UTL\PYGZus{}FILE.PUT(v\PYGZus{}empfile,\PYGZsq{},\PYGZsq{});
        UTL\PYGZus{}FILE.PUT(v\PYGZus{}empfile,i.comm);
        UTL\PYGZus{}FILE.PUT(v\PYGZus{}empfile,\PYGZsq{},\PYGZsq{});
        UTL\PYGZus{}FILE.PUT(v\PYGZus{}empfile,i.deptno);
        UTL\PYGZus{}FILE.NEW\PYGZus{}LINE(v\PYGZus{}empfile);
        UTL\PYGZus{}FILE.FFLUSH(v\PYGZus{}empfile);
    END LOOP;
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Created file: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}filename);
    UTL\PYGZus{}FILE.FCLOSE(v\PYGZus{}empfile);
END;
\end{sphinxVerbatim}


\subsection{\index{FOPEN}FOPEN}
\label{\detokenize{utl_file:fopen}}
The \sphinxcode{FOPEN} function opens a file for I/O.
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{\textless{}filetype\textgreater{} FILE\_TYPE FOPEN(\textless{}location\textgreater{} VARCHAR2},
\item[] \sphinxcode{\textless{}filename\textgreater{} VARCHAR2,\textless{}open\_mode\textgreater{} VARCHAR2}
\item[] {[}, \sphinxcode{\textless{}max\_linesize\textgreater{} BINARY\_INTEGER {]})}
\end{DUlineblock}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}location\textgreater{}}
\begin{quote}

Directory name, as stored in \sphinxcode{pg\_catalog.edb\_dir.dirname}, of the
directory containing the file to be opened.
\end{quote}

\sphinxcode{\textless{}filename\textgreater{}}
\begin{quote}

Name of the file to be opened.
\end{quote}

\sphinxcode{\textless{}open\_mode\textgreater{}}
\begin{quote}

Mode in which the file will be opened. Modes are: \sphinxcode{a} - append to file; \sphinxcode{r}
- read from file; \sphinxcode{w} - write to file.
\end{quote}

\sphinxcode{\textless{}max\_linesize\textgreater{}}
\begin{quote}

Maximum size of a line in characters. In read mode, an exception is
thrown if an attempt is made to read a line exceeding \sphinxcode{\textless{}max\_linesize\textgreater{}}.
In write and append modes, an exception is thrown if an attempt is made
to write a line exceeding \sphinxcode{\textless{}max\_linesize\textgreater{}}. The end-of-line character(s)
are not included in determining if the maximum line size is exceeded.
This behavior is not compatible with Oracle databases; Oracle does count
the end-of-line character(s).
\end{quote}

\sphinxcode{\textless{}filetype\textgreater{}}
\begin{quote}

Variable of type \sphinxcode{FILE\_TYPE} containing the file handle of the opened
file.
\end{quote}


\subsection{\index{FREMOVE}FREMOVE}
\label{\detokenize{utl_file:fremove}}
The \sphinxcode{FREMOVE} procedure removes a file from the system.
\begin{quote}

\sphinxcode{FREMOVE(\textless{}location\textgreater{} VARCHAR2, \textless{}filename\textgreater{} VARCHAR2)}
\end{quote}

An exception is thrown if the file to be removed does not exist.

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}location\textgreater{}}
\begin{quote}

Directory name, as stored in \sphinxcode{pg\_catalog.edb\_dir.dirname}, of the
directory containing the file to be removed.
\end{quote}

\sphinxcode{\textless{}filename\textgreater{}}
\begin{quote}

Name of the file to be removed.
\end{quote}

\sphinxstylestrong{Examples}

The following removes file \sphinxcode{empfile.csv}.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    v\PYGZus{}directory     VARCHAR2(50) := \PYGZsq{}empdir\PYGZsq{};
    v\PYGZus{}filename      VARCHAR2(20) := \PYGZsq{}empfile.csv\PYGZsq{};
BEGIN
    UTL\PYGZus{}FILE.FREMOVE(v\PYGZus{}directory,v\PYGZus{}filename);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Removed file: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}filename);
    EXCEPTION
        WHEN OTHERS THEN
            DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}SQLERRM: \PYGZsq{} \textbar{}\textbar{} SQLERRM);
            DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}SQLCODE: \PYGZsq{} \textbar{}\textbar{} SQLCODE);
END;

Removed file: empfile.csv
\end{sphinxVerbatim}


\subsection{\index{FRENAME}FRENAME}
\label{\detokenize{utl_file:frename}}
The \sphinxcode{FRENAME} procedure renames a given file. This effectively moves a
file from one location to another.
\begin{quote}

\sphinxcode{FRENAME(\textless{}location\textgreater{} VARCHAR2, \textless{}filename\textgreater{} VARCHAR2},

\begin{DUlineblock}{0em}
\item[] \sphinxcode{\textless{}dest\_dir\textgreater{} VARCHAR2, \textless{}dest\_file\textgreater{} VARCHAR2},
\end{DUlineblock}

\begin{DUlineblock}{0em}
\item[] {[} \sphinxcode{\textless{}overwrite\textgreater{} BOOLEAN} {]})
\end{DUlineblock}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}location\textgreater{}}
\begin{quote}

Directory name, as stored in \sphinxcode{pg\_catalog.edb\_dir.dirname}, of the
directory containing the file to be renamed.
\end{quote}

\sphinxcode{\textless{}filename\textgreater{}}
\begin{quote}

Name of the source file to be renamed.
\end{quote}

\sphinxcode{\textless{}dest\_dir\textgreater{}}
\begin{quote}

Directory name, as stored in \sphinxcode{pg\_catalog.edb\_dir.dirname}, of the
directory to which the renamed file is to exist.
\end{quote}

\sphinxcode{\textless{}dest\_file\textgreater{}}
\begin{quote}

New name of the original file.
\end{quote}

\sphinxcode{\textless{}overwrite\textgreater{}}
\begin{quote}

Replaces any existing file named \sphinxcode{\textless{}dest\_file\textgreater{}} in \sphinxcode{\textless{}dest\_dir\textgreater{}} if set to
\sphinxcode{TRUE}, otherwise an exception is thrown if set to \sphinxcode{FALSE}. This is the
default.
\end{quote}

\newpage

\sphinxstylestrong{Examples}

The following renames a file, \sphinxcode{C:\textbackslash{}TEMP\textbackslash{}EMPDIR\textbackslash{}empfile.csv}, containing
a comma-delimited list of employees from the \sphinxcode{emp} table. The renamed
file, \sphinxcode{C:\textbackslash{}TEMP\textbackslash{}NEWDIR\textbackslash{}newemp.csv}, is then listed.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
CREATE DIRECTORY \PYGZdq{}newdir\PYGZdq{} AS \PYGZsq{}C:/TEMP/NEWDIR\PYGZsq{};

DECLARE
    v\PYGZus{}empfile       UTL\PYGZus{}FILE.FILE\PYGZus{}TYPE;
    v\PYGZus{}src\PYGZus{}dir       VARCHAR2(50) := \PYGZsq{}empdir\PYGZsq{};
    v\PYGZus{}src\PYGZus{}file      VARCHAR2(20) := \PYGZsq{}empfile.csv\PYGZsq{};
    v\PYGZus{}dest\PYGZus{}dir      VARCHAR2(50) := \PYGZsq{}newdir\PYGZsq{};
    v\PYGZus{}dest\PYGZus{}file     VARCHAR2(50) := \PYGZsq{}newemp.csv\PYGZsq{};
    v\PYGZus{}replace       BOOLEAN := FALSE;
    v\PYGZus{}emprec        VARCHAR2(120);
    v\PYGZus{}count         INTEGER := 0;
BEGIN
    UTL\PYGZus{}FILE.FRENAME(v\PYGZus{}src\PYGZus{}dir,v\PYGZus{}src\PYGZus{}file,v\PYGZus{}dest\PYGZus{}dir,
        v\PYGZus{}dest\PYGZus{}file,v\PYGZus{}replace);
    v\PYGZus{}empfile := UTL\PYGZus{}FILE.FOPEN(v\PYGZus{}dest\PYGZus{}dir,v\PYGZus{}dest\PYGZus{}file,\PYGZsq{}r\PYGZsq{});
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}The following is the renamed file, \PYGZsq{}\PYGZsq{}\PYGZsq{} \textbar{}\textbar{}
        v\PYGZus{}dest\PYGZus{}file \textbar{}\textbar{} \PYGZsq{}\PYGZsq{}\PYGZsq{}\PYGZsq{});
    LOOP
        UTL\PYGZus{}FILE.GET\PYGZus{}LINE(v\PYGZus{}empfile,v\PYGZus{}emprec);
        DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(v\PYGZus{}emprec);
        v\PYGZus{}count := v\PYGZus{}count + 1;
    END LOOP;
    EXCEPTION
        WHEN NO\PYGZus{}DATA\PYGZus{}FOUND THEN
            UTL\PYGZus{}FILE.FCLOSE(v\PYGZus{}empfile);
            DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(v\PYGZus{}count \textbar{}\textbar{} \PYGZsq{} records retrieved\PYGZsq{});
        WHEN OTHERS THEN
            DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}SQLERRM: \PYGZsq{} \textbar{}\textbar{} SQLERRM);
            DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}SQLCODE: \PYGZsq{} \textbar{}\textbar{} SQLCODE);
END;

The following is the renamed file, \PYGZsq{}newemp.csv\PYGZsq{}
7369,SMITH,CLERK,7902,17\PYGZhy{}DEC\PYGZhy{}80 00:00:00,800.00,,20
7499,ALLEN,SALESMAN,7698,20\PYGZhy{}FEB\PYGZhy{}81 00:00:00,1600.00,300.00,30
7521,WARD,SALESMAN,7698,22\PYGZhy{}FEB\PYGZhy{}81 00:00:00,1250.00,500.00,30
7566,JONES,MANAGER,7839,02\PYGZhy{}APR\PYGZhy{}81 00:00:00,2975.00,,20
7654,MARTIN,SALESMAN,7698,28\PYGZhy{}SEP\PYGZhy{}81 00:00:00,1250.00,1400.00,30
7698,BLAKE,MANAGER,7839,01\PYGZhy{}MAY\PYGZhy{}81 00:00:00,2850.00,,30
7782,CLARK,MANAGER,7839,09\PYGZhy{}JUN\PYGZhy{}81 00:00:00,2450.00,,10
7788,SCOTT,ANALYST,7566,19\PYGZhy{}APR\PYGZhy{}87 00:00:00,3000.00,,20
7839,KING,PRESIDENT,,17\PYGZhy{}NOV\PYGZhy{}81 00:00:00,5000.00,,10
7844,TURNER,SALESMAN,7698,08\PYGZhy{}SEP\PYGZhy{}81 00:00:00,1500.00,0.00,30
7876,ADAMS,CLERK,7788,23\PYGZhy{}MAY\PYGZhy{}87 00:00:00,1100.00,,20
7900,JAMES,CLERK,7698,03\PYGZhy{}DEC\PYGZhy{}81 00:00:00,950.00,,30
7902,FORD,ANALYST,7566,03\PYGZhy{}DEC\PYGZhy{}81 00:00:00,3000.00,,20
7934,MILLER,CLERK,7782,23\PYGZhy{}JAN\PYGZhy{}82 00:00:00,1300.00,,10
14 records retrieved
\end{sphinxVerbatim}

\newpage


\subsection{\index{GET\_LINE}GET\_LINE}
\label{\detokenize{utl_file:get-line}}
The \sphinxcode{GET\_LINE} procedure reads a line of text from a given file up to,
but not including the end-of-line terminator. A \sphinxcode{NO\_DATA\_FOUND}
exception is thrown when there are no more lines to read.
\begin{quote}

\sphinxcode{GET\_LINE(\textless{}file\textgreater{} FILE\_TYPE, \textless{}buffer\textgreater{} OUT VARCHAR2)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}file\textgreater{}}
\begin{quote}

Variable of type \sphinxcode{FILE\_TYPE} containing the file handle of the opened
file.
\end{quote}

\sphinxcode{\textless{}buffer\textgreater{}}
\begin{quote}

Variable to receive a line from the file.
\end{quote}

\sphinxstylestrong{Examples}

The following anonymous block reads through and displays the records in
file \sphinxcode{empfile.csv}.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    v\PYGZus{}empfile       UTL\PYGZus{}FILE.FILE\PYGZus{}TYPE;
    v\PYGZus{}directory     VARCHAR2(50) := \PYGZsq{}empdir\PYGZsq{};
    v\PYGZus{}filename      VARCHAR2(20) := \PYGZsq{}empfile.csv\PYGZsq{};
    v\PYGZus{}emprec        VARCHAR2(120);
    v\PYGZus{}count         INTEGER := 0;
BEGIN
    v\PYGZus{}empfile := UTL\PYGZus{}FILE.FOPEN(v\PYGZus{}directory,v\PYGZus{}filename,\PYGZsq{}r\PYGZsq{});
    LOOP
        UTL\PYGZus{}FILE.GET\PYGZus{}LINE(v\PYGZus{}empfile,v\PYGZus{}emprec);
        DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(v\PYGZus{}emprec);
        v\PYGZus{}count := v\PYGZus{}count + 1;
    END LOOP;
    EXCEPTION
        WHEN NO\PYGZus{}DATA\PYGZus{}FOUND THEN
            UTL\PYGZus{}FILE.FCLOSE(v\PYGZus{}empfile);
            DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}End of file \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}filename \textbar{}\textbar{} \PYGZsq{} \PYGZhy{} \PYGZsq{} \textbar{}\textbar{}
                v\PYGZus{}count \textbar{}\textbar{} \PYGZsq{} records retrieved\PYGZsq{});
        WHEN OTHERS THEN
            DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}SQLERRM: \PYGZsq{} \textbar{}\textbar{} SQLERRM);
            DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}SQLCODE: \PYGZsq{} \textbar{}\textbar{} SQLCODE);
END;

7369,SMITH,CLERK,7902,17\PYGZhy{}DEC\PYGZhy{}80 00:00:00,800.00,,20
7499,ALLEN,SALESMAN,7698,20\PYGZhy{}FEB\PYGZhy{}81 00:00:00,1600.00,300.00,30
7521,WARD,SALESMAN,7698,22\PYGZhy{}FEB\PYGZhy{}81 00:00:00,1250.00,500.00,30
7566,JONES,MANAGER,7839,02\PYGZhy{}APR\PYGZhy{}81 00:00:00,2975.00,,20
7654,MARTIN,SALESMAN,7698,28\PYGZhy{}SEP\PYGZhy{}81 00:00:00,1250.00,1400.00,30
7698,BLAKE,MANAGER,7839,01\PYGZhy{}MAY\PYGZhy{}81 00:00:00,2850.00,,30
7782,CLARK,MANAGER,7839,09\PYGZhy{}JUN\PYGZhy{}81 00:00:00,2450.00,,10
7788,SCOTT,ANALYST,7566,19\PYGZhy{}APR\PYGZhy{}87 00:00:00,3000.00,,20
7839,KING,PRESIDENT,,17\PYGZhy{}NOV\PYGZhy{}81 00:00:00,5000.00,,10
7844,TURNER,SALESMAN,7698,08\PYGZhy{}SEP\PYGZhy{}81 00:00:00,1500.00,0.00,30
7876,ADAMS,CLERK,7788,23\PYGZhy{}MAY\PYGZhy{}87 00:00:00,1100.00,,20
7900,JAMES,CLERK,7698,03\PYGZhy{}DEC\PYGZhy{}81 00:00:00,950.00,,30
7902,FORD,ANALYST,7566,03\PYGZhy{}DEC\PYGZhy{}81 00:00:00,3000.00,,20
7934,MILLER,CLERK,7782,23\PYGZhy{}JAN\PYGZhy{}82 00:00:00,1300.00,,10
End of file empfile.csv \PYGZhy{} 14 records retrieved
\end{sphinxVerbatim}


\subsection{\index{IS\_OPEN}IS\_OPEN}
\label{\detokenize{utl_file:is-open}}
The \sphinxcode{IS\_OPEN} function determines whether or not the given file is open.
\begin{quote}

\sphinxcode{\textless{}status\textgreater{} BOOLEAN IS\_OPEN(\textless{}file\textgreater{} FILE\_TYPE)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}file\textgreater{}}
\begin{quote}

Variable of type \sphinxcode{FILE\_TYPE} containing the file handle of the file to be
tested.
\end{quote}

\sphinxcode{\textless{}status\textgreater{}}
\begin{quote}

\sphinxcode{TRUE} if the given file is open, \sphinxcode{FALSE} otherwise.
\end{quote}


\subsection{\index{NEW\_LINE}NEW\_LINE}
\label{\detokenize{utl_file:new-line}}
The \sphinxcode{NEW\_LINE} procedure writes an end-of-line character sequence in the
file.
\begin{quote}

\sphinxcode{NEW\_LINE(\textless{}file\textgreater{} FILE\_TYPE {[}, \textless{}lines\textgreater{} INTEGER {]})}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}file\textgreater{}}
\begin{quote}

Variable of type \sphinxcode{FILE\_TYPE} containing the file handle of the file to
which end-of-line character sequences are to be written.
\end{quote}

\sphinxcode{\textless{}lines\textgreater{}}
\begin{quote}

Number of end-of-line character sequences to be written. The default is
one.
\end{quote}

\sphinxstylestrong{Examples}

A file containing a double-spaced list of employee records is written.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    v\PYGZus{}empfile       UTL\PYGZus{}FILE.FILE\PYGZus{}TYPE;
    v\PYGZus{}directory     VARCHAR2(50) := \PYGZsq{}empdir\PYGZsq{};
    v\PYGZus{}filename      VARCHAR2(20) := \PYGZsq{}empfile.csv\PYGZsq{};
    CURSOR emp\PYGZus{}cur IS SELECT * FROM emp ORDER BY empno;
BEGIN
    v\PYGZus{}empfile := UTL\PYGZus{}FILE.FOPEN(v\PYGZus{}directory,v\PYGZus{}filename,\PYGZsq{}w\PYGZsq{});
    FOR i IN emp\PYGZus{}cur LOOP
        UTL\PYGZus{}FILE.PUT(v\PYGZus{}empfile,i.empno);
        UTL\PYGZus{}FILE.PUT(v\PYGZus{}empfile,\PYGZsq{},\PYGZsq{});
        UTL\PYGZus{}FILE.PUT(v\PYGZus{}empfile,i.ename);
        UTL\PYGZus{}FILE.PUT(v\PYGZus{}empfile,\PYGZsq{},\PYGZsq{});
        UTL\PYGZus{}FILE.PUT(v\PYGZus{}empfile,i.job);
        UTL\PYGZus{}FILE.PUT(v\PYGZus{}empfile,\PYGZsq{},\PYGZsq{});
        UTL\PYGZus{}FILE.PUT(v\PYGZus{}empfile,i.mgr);
        UTL\PYGZus{}FILE.PUT(v\PYGZus{}empfile,\PYGZsq{},\PYGZsq{});
        UTL\PYGZus{}FILE.PUT(v\PYGZus{}empfile,i.hiredate);
        UTL\PYGZus{}FILE.PUT(v\PYGZus{}empfile,\PYGZsq{},\PYGZsq{});
        UTL\PYGZus{}FILE.PUT(v\PYGZus{}empfile,i.sal);
        UTL\PYGZus{}FILE.PUT(v\PYGZus{}empfile,\PYGZsq{},\PYGZsq{});
        UTL\PYGZus{}FILE.PUT(v\PYGZus{}empfile,i.comm);
        UTL\PYGZus{}FILE.PUT(v\PYGZus{}empfile,\PYGZsq{},\PYGZsq{});
        UTL\PYGZus{}FILE.PUT(v\PYGZus{}empfile,i.deptno);
        UTL\PYGZus{}FILE.NEW\PYGZus{}LINE(v\PYGZus{}empfile,2);
    END LOOP;
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Created file: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}filename);
    UTL\PYGZus{}FILE.FCLOSE(v\PYGZus{}empfile);
END;

Created file: empfile.csv
\end{sphinxVerbatim}

This file is then displayed:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
C:\PYGZbs{}TEMP\PYGZbs{}EMPDIR\PYGZgt{}TYPE empfile.csv

7369,SMITH,CLERK,7902,17\PYGZhy{}DEC\PYGZhy{}80 00:00:00,800.00,,20

7499,ALLEN,SALESMAN,7698,20\PYGZhy{}FEB\PYGZhy{}81 00:00:00,1600.00,300.00,30

7521,WARD,SALESMAN,7698,22\PYGZhy{}FEB\PYGZhy{}81 00:00:00,1250.00,500.00,30

7566,JONES,MANAGER,7839,02\PYGZhy{}APR\PYGZhy{}81 00:00:00,2975.00,,20

7654,MARTIN,SALESMAN,7698,28\PYGZhy{}SEP\PYGZhy{}81 00:00:00,1250.00,1400.00,30

7698,BLAKE,MANAGER,7839,01\PYGZhy{}MAY\PYGZhy{}81 00:00:00,2850.00,,30

7782,CLARK,MANAGER,7839,09\PYGZhy{}JUN\PYGZhy{}81 00:00:00,2450.00,,10

7788,SCOTT,ANALYST,7566,19\PYGZhy{}APR\PYGZhy{}87 00:00:00,3000.00,,20

7839,KING,PRESIDENT,,17\PYGZhy{}NOV\PYGZhy{}81 00:00:00,5000.00,,10

7844,TURNER,SALESMAN,7698,08\PYGZhy{}SEP\PYGZhy{}81 00:00:00,1500.00,0.00,30

7876,ADAMS,CLERK,7788,23\PYGZhy{}MAY\PYGZhy{}87 00:00:00,1100.00,,20

7900,JAMES,CLERK,7698,03\PYGZhy{}DEC\PYGZhy{}81 00:00:00,950.00,,30

7902,FORD,ANALYST,7566,03\PYGZhy{}DEC\PYGZhy{}81 00:00:00,3000.00,,20

7934,MILLER,CLERK,7782,23\PYGZhy{}JAN\PYGZhy{}82 00:00:00,1300.00,,10
\end{sphinxVerbatim}

\index{UTL\_FILE\_PUT}\ignorespaces 

\subsection{PUT}
\label{\detokenize{utl_file:put}}\label{\detokenize{utl_file:index-12}}
The \sphinxcode{PUT} procedure writes a string to the given file. No end-of-line
character sequence is written at the end of the string. Use the
\sphinxcode{NEW\_LINE} procedure to add an end-of-line character sequence.
\begin{quote}

\sphinxcode{PUT(\textless{}file\textgreater{} FILE\_TYPE, \textless{}buffer\textgreater{} \{ DATE \textbar{} NUMBER \textbar{} TIMESTAMP \textbar{}}

\sphinxcode{VARCHAR2 \})}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}file\textgreater{}}
\begin{quote}

Variable of type \sphinxcode{FILE\_TYPE} containing the file handle of the file to
which the given string is to be written.
\end{quote}

\sphinxcode{\textless{}buffer\textgreater{}}
\begin{quote}

Text to be written to the specified file.
\end{quote}

\newpage

\sphinxstylestrong{Examples}

The following example uses the \sphinxcode{PUT} procedure to create a comma-delimited
file of employees from the \sphinxcode{emp} table.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    v\PYGZus{}empfile       UTL\PYGZus{}FILE.FILE\PYGZus{}TYPE;
    v\PYGZus{}directory     VARCHAR2(50) := \PYGZsq{}empdir\PYGZsq{};
    v\PYGZus{}filename      VARCHAR2(20) := \PYGZsq{}empfile.csv\PYGZsq{};
    CURSOR emp\PYGZus{}cur IS SELECT * FROM emp ORDER BY empno;
BEGIN
    v\PYGZus{}empfile := UTL\PYGZus{}FILE.FOPEN(v\PYGZus{}directory,v\PYGZus{}filename,\PYGZsq{}w\PYGZsq{});
    FOR i IN emp\PYGZus{}cur LOOP
        UTL\PYGZus{}FILE.PUT(v\PYGZus{}empfile,i.empno);
        UTL\PYGZus{}FILE.PUT(v\PYGZus{}empfile,\PYGZsq{},\PYGZsq{});
        UTL\PYGZus{}FILE.PUT(v\PYGZus{}empfile,i.ename);
        UTL\PYGZus{}FILE.PUT(v\PYGZus{}empfile,\PYGZsq{},\PYGZsq{});
        UTL\PYGZus{}FILE.PUT(v\PYGZus{}empfile,i.job);
        UTL\PYGZus{}FILE.PUT(v\PYGZus{}empfile,\PYGZsq{},\PYGZsq{});
        UTL\PYGZus{}FILE.PUT(v\PYGZus{}empfile,i.mgr);
        UTL\PYGZus{}FILE.PUT(v\PYGZus{}empfile,\PYGZsq{},\PYGZsq{});
        UTL\PYGZus{}FILE.PUT(v\PYGZus{}empfile,i.hiredate);
        UTL\PYGZus{}FILE.PUT(v\PYGZus{}empfile,\PYGZsq{},\PYGZsq{});
        UTL\PYGZus{}FILE.PUT(v\PYGZus{}empfile,i.sal);
        UTL\PYGZus{}FILE.PUT(v\PYGZus{}empfile,\PYGZsq{},\PYGZsq{});
        UTL\PYGZus{}FILE.PUT(v\PYGZus{}empfile,i.comm);
        UTL\PYGZus{}FILE.PUT(v\PYGZus{}empfile,\PYGZsq{},\PYGZsq{});
        UTL\PYGZus{}FILE.PUT(v\PYGZus{}empfile,i.deptno);
        UTL\PYGZus{}FILE.NEW\PYGZus{}LINE(v\PYGZus{}empfile);
    END LOOP;
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Created file: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}filename);
    UTL\PYGZus{}FILE.FCLOSE(v\PYGZus{}empfile);
END;

Created file: empfile.csv
\end{sphinxVerbatim}

The following is the contents of \sphinxcode{empfile.csv} created above:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
C:\PYGZbs{}TEMP\PYGZbs{}EMPDIR\PYGZgt{}TYPE empfile.csv

7369,SMITH,CLERK,7902,17\PYGZhy{}DEC\PYGZhy{}80 00:00:00,800.00,,20
7499,ALLEN,SALESMAN,7698,20\PYGZhy{}FEB\PYGZhy{}81 00:00:00,1600.00,300.00,30
7521,WARD,SALESMAN,7698,22\PYGZhy{}FEB\PYGZhy{}81 00:00:00,1250.00,500.00,30
7566,JONES,MANAGER,7839,02\PYGZhy{}APR\PYGZhy{}81 00:00:00,2975.00,,20
7654,MARTIN,SALESMAN,7698,28\PYGZhy{}SEP\PYGZhy{}81 00:00:00,1250.00,1400.00,30
7698,BLAKE,MANAGER,7839,01\PYGZhy{}MAY\PYGZhy{}81 00:00:00,2850.00,,30
7782,CLARK,MANAGER,7839,09\PYGZhy{}JUN\PYGZhy{}81 00:00:00,2450.00,,10
7788,SCOTT,ANALYST,7566,19\PYGZhy{}APR\PYGZhy{}87 00:00:00,3000.00,,20
7839,KING,PRESIDENT,,17\PYGZhy{}NOV\PYGZhy{}81 00:00:00,5000.00,,10
7844,TURNER,SALESMAN,7698,08\PYGZhy{}SEP\PYGZhy{}81 00:00:00,1500.00,0.00,30
7876,ADAMS,CLERK,7788,23\PYGZhy{}MAY\PYGZhy{}87 00:00:00,1100.00,,20
7900,JAMES,CLERK,7698,03\PYGZhy{}DEC\PYGZhy{}81 00:00:00,950.00,,30
7902,FORD,ANALYST,7566,03\PYGZhy{}DEC\PYGZhy{}81 00:00:00,3000.00,,20
7934,MILLER,CLERK,7782,23\PYGZhy{}JAN\PYGZhy{}82 00:00:00,1300.00,,10
\end{sphinxVerbatim}

\newpage

\index{UTL\_FILE\_PUT\_LINE}\ignorespaces 

\subsection{PUT\_LINE}
\label{\detokenize{utl_file:index-13}}\label{\detokenize{utl_file:put-line}}
The \sphinxcode{PUT\_LINE} procedure writes a single line to the given file including
an end-of-line character sequence.
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{PUT\_LINE(\textless{}file\textgreater{} FILE\_TYPE},
\item[] \sphinxcode{\textless{}buffer\textgreater{} \{DATE\textbar{}NUMBER\textbar{}TIMESTAMP\textbar{}VARCHAR2\})}
\end{DUlineblock}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}file\textgreater{}}
\begin{quote}

Variable of type \sphinxcode{FILE\_TYPE} containing the file handle of the file to
which the given line is to be written.
\end{quote}

\sphinxcode{\textless{}buffer\textgreater{}}
\begin{quote}

Text to be written to the specified file.
\end{quote}

\sphinxstylestrong{Examples}

The following example uses the \sphinxcode{PUT\_LINE} procedure to create a
comma-delimited file of employees from the \sphinxcode{emp} table.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    v\PYGZus{}empfile       UTL\PYGZus{}FILE.FILE\PYGZus{}TYPE;
    v\PYGZus{}directory     VARCHAR2(50) := \PYGZsq{}empdir\PYGZsq{};
    v\PYGZus{}filename      VARCHAR2(20) := \PYGZsq{}empfile.csv\PYGZsq{};
    v\PYGZus{}emprec        VARCHAR2(120);
    CURSOR emp\PYGZus{}cur IS SELECT * FROM emp ORDER BY empno;
BEGIN
    v\PYGZus{}empfile := UTL\PYGZus{}FILE.FOPEN(v\PYGZus{}directory,v\PYGZus{}filename,\PYGZsq{}w\PYGZsq{});
    FOR i IN emp\PYGZus{}cur LOOP
        v\PYGZus{}emprec := i.empno \textbar{}\textbar{} \PYGZsq{},\PYGZsq{} \textbar{}\textbar{} i.ename \textbar{}\textbar{} \PYGZsq{},\PYGZsq{} \textbar{}\textbar{} i.job \textbar{}\textbar{} \PYGZsq{},\PYGZsq{} \textbar{}\textbar{}
            NVL(LTRIM(TO\PYGZus{}CHAR(i.mgr,\PYGZsq{}9999\PYGZsq{})),\PYGZsq{}\PYGZsq{}) \textbar{}\textbar{} \PYGZsq{},\PYGZsq{} \textbar{}\textbar{} i.hiredate \textbar{}\textbar{}
            \PYGZsq{},\PYGZsq{} \textbar{}\textbar{} i.sal \textbar{}\textbar{} \PYGZsq{},\PYGZsq{} \textbar{}\textbar{}
            NVL(LTRIM(TO\PYGZus{}CHAR(i.comm,\PYGZsq{}9990.99\PYGZsq{})),\PYGZsq{}\PYGZsq{}) \textbar{}\textbar{} \PYGZsq{},\PYGZsq{} \textbar{}\textbar{} i.deptno;
        UTL\PYGZus{}FILE.PUT\PYGZus{}LINE(v\PYGZus{}empfile,v\PYGZus{}emprec);
    END LOOP;
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Created file: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}filename);
    UTL\PYGZus{}FILE.FCLOSE(v\PYGZus{}empfile);
END;
\end{sphinxVerbatim}

The following is the contents of \sphinxcode{empfile.csv} created above:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
C:\PYGZbs{}TEMP\PYGZbs{}EMPDIR\PYGZgt{}TYPE empfile.csv

7369,SMITH,CLERK,7902,17\PYGZhy{}DEC\PYGZhy{}80 00:00:00,800.00,,20
7499,ALLEN,SALESMAN,7698,20\PYGZhy{}FEB\PYGZhy{}81 00:00:00,1600.00,300.00,30
7521,WARD,SALESMAN,7698,22\PYGZhy{}FEB\PYGZhy{}81 00:00:00,1250.00,500.00,30
7566,JONES,MANAGER,7839,02\PYGZhy{}APR\PYGZhy{}81 00:00:00,2975.00,,20
7654,MARTIN,SALESMAN,7698,28\PYGZhy{}SEP\PYGZhy{}81 00:00:00,1250.00,1400.00,30
7698,BLAKE,MANAGER,7839,01\PYGZhy{}MAY\PYGZhy{}81 00:00:00,2850.00,,30
7782,CLARK,MANAGER,7839,09\PYGZhy{}JUN\PYGZhy{}81 00:00:00,2450.00,,10
7788,SCOTT,ANALYST,7566,19\PYGZhy{}APR\PYGZhy{}87 00:00:00,3000.00,,20
7839,KING,PRESIDENT,,17\PYGZhy{}NOV\PYGZhy{}81 00:00:00,5000.00,,10
7844,TURNER,SALESMAN,7698,08\PYGZhy{}SEP\PYGZhy{}81 00:00:00,1500.00,0.00,30
7876,ADAMS,CLERK,7788,23\PYGZhy{}MAY\PYGZhy{}87 00:00:00,1100.00,,20
7900,JAMES,CLERK,7698,03\PYGZhy{}DEC\PYGZhy{}81 00:00:00,950.00,,30
7902,FORD,ANALYST,7566,03\PYGZhy{}DEC\PYGZhy{}81 00:00:00,3000.00,,20
7934,MILLER,CLERK,7782,23\PYGZhy{}JAN\PYGZhy{}82 00:00:00,1300.00,,10
\end{sphinxVerbatim}


\subsection{\index{PUTF}PUTF}
\label{\detokenize{utl_file:putf}}
The \sphinxcode{PUTF} procedure writes a formatted string to the given file.
\begin{quote}

\sphinxcode{PUTF(\textless{}file\textgreater{} FILE\_TYPE, \textless{}format\textgreater{} VARCHAR2 {[}, \textless{}arg1\textgreater{} VARCHAR2{]}}

\sphinxcode{{[}, ...{]})}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}file\textgreater{}}
\begin{quote}

Variable of type \sphinxcode{FILE\_TYPE} containing the file handle of the file to
which the formatted line is to be written.
\end{quote}

\sphinxcode{\textless{}format\textgreater{}}
\begin{quote}

String to format the text written to the file. The special character
sequence, \sphinxcode{\%s}, is substituted by the value of arg. The special character
sequence, \sphinxcode{\textbackslash{}n}, indicates a new line. Note, however, in Advanced Server,
a new line character must be specified with two consecutive backslashes
instead of one - \sphinxcode{\textbackslash{}\textbackslash{}n}. This characteristic is not compatible with
Oracle databases.
\end{quote}

\sphinxcode{\textless{}arg1\textgreater{}}
\begin{quote}

Up to five arguments, \sphinxcode{\textless{}arg1\textgreater{}},…\sphinxcode{\textless{}arg5\textgreater{}}, to be substituted in the
format string for each occurrence of \sphinxcode{\%s}. The first arg is substituted
for the first occurrence of \sphinxcode{\%s}, the second arg is substituted for the
second occurrence of \sphinxcode{\%s}, etc.
\end{quote}

\sphinxstylestrong{Examples}

The following anonymous block produces formatted output containing data
from the \sphinxcode{emp} table. Note the use of the E literal syntax and double
backslashes for the new line character sequence in the format string
which are not compatible with Oracle databases.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    v\PYGZus{}empfile       UTL\PYGZus{}FILE.FILE\PYGZus{}TYPE;
    v\PYGZus{}directory     VARCHAR2(50) := \PYGZsq{}empdir\PYGZsq{};
    v\PYGZus{}filename      VARCHAR2(20) := \PYGZsq{}empfile.csv\PYGZsq{};
    v\PYGZus{}format        VARCHAR2(200);
    CURSOR emp\PYGZus{}cur IS SELECT * FROM emp ORDER BY empno;
BEGIN
    v\PYGZus{}format := E\PYGZsq{}\PYGZpc{}s \PYGZpc{}s, \PYGZpc{}s\PYGZbs{}\PYGZbs{}nSalary: \PYGZdl{}\PYGZpc{}s Commission: \PYGZdl{}\PYGZpc{}s\PYGZbs{}\PYGZbs{}n\PYGZbs{}\PYGZbs{}n\PYGZsq{};
    v\PYGZus{}empfile := UTL\PYGZus{}FILE.FOPEN(v\PYGZus{}directory,v\PYGZus{}filename,\PYGZsq{}w\PYGZsq{});
    FOR i IN emp\PYGZus{}cur LOOP
        UTL\PYGZus{}FILE.PUTF(v\PYGZus{}empfile,v\PYGZus{}format,i.empno,i.ename,i.job,i.sal,
            NVL(i.comm,0));
    END LOOP;
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Created file: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}filename);
    UTL\PYGZus{}FILE.FCLOSE(v\PYGZus{}empfile);
EXCEPTION
    WHEN OTHERS THEN
        DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}SQLERRM: \PYGZsq{} \textbar{}\textbar{} SQLERRM);
        DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}SQLCODE: \PYGZsq{} \textbar{}\textbar{} SQLCODE);
END;

Created file: empfile.csv
\end{sphinxVerbatim}

The following is the contents of \sphinxcode{empfile.csv} created above:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
C:\PYGZbs{}TEMP\PYGZbs{}EMPDIR\PYGZgt{}TYPE empfile.csv
7369 SMITH, CLERK
Salary: \PYGZdl{}800.00 Commission: \PYGZdl{}0
7499 ALLEN, SALESMAN
Salary: \PYGZdl{}1600.00 Commission: \PYGZdl{}300.00
7521 WARD, SALESMAN
Salary: \PYGZdl{}1250.00 Commission: \PYGZdl{}500.00
7566 JONES, MANAGER
Salary: \PYGZdl{}2975.00 Commission: \PYGZdl{}0
7654 MARTIN, SALESMAN
Salary: \PYGZdl{}1250.00 Commission: \PYGZdl{}1400.00
7698 BLAKE, MANAGER
Salary: \PYGZdl{}2850.00 Commission: \PYGZdl{}0
7782 CLARK, MANAGER
Salary: \PYGZdl{}2450.00 Commission: \PYGZdl{}0
7788 SCOTT, ANALYST
Salary: \PYGZdl{}3000.00 Commission: \PYGZdl{}0
7839 KING, PRESIDENT
Salary: \PYGZdl{}5000.00 Commission: \PYGZdl{}0
7844 TURNER, SALESMAN
Salary: \PYGZdl{}1500.00 Commission: \PYGZdl{}0.00
7876 ADAMS, CLERK
Salary: \PYGZdl{}1100.00 Commission: \PYGZdl{}0
7900 JAMES, CLERK
Salary: \PYGZdl{}950.00 Commission: \PYGZdl{}0
7902 FORD, ANALYST
Salary: \PYGZdl{}3000.00 Commission: \PYGZdl{}0
7934 MILLER, CLERK
Salary: \PYGZdl{}1300.00 Commission: \PYGZdl{}0
\end{sphinxVerbatim}

\newpage


\section{\index{UTL\_HTTP}UTL\_HTTP}
\label{\detokenize{utl_http::doc}}\label{\detokenize{utl_http:utl-http}}
The \sphinxcode{UTL\_HTTP} package provides a way to use the HTTP or HTTPS protocol
to retrieve information found at an URL. Advanced Server supports the
following functions and procedures:


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}{|\X{4}{10}|\X{2}{10}|\X{4}{10}|}
\hline

\endfirsthead

\multicolumn{3}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{3}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot

Function/Procedure
&
Return Type
&
Description
\\
\hline
BEGIN\_REQUEST(url, method, http\_version)
&
UTL\_HTTP.REQ
&
Initiates a new HTTP request.
\\
\hline
END\_REQUEST(r IN OUT)
&
n/a
&
Ends an HTTP request before allowing it to complete.
\\
\hline
END\_RESPONSE(r IN OUT)
&
n/a
&
Ends the HTTP response.
\\
\hline
GET\_BODY\_CHARSET
&
VARCHAR2
&
Returns the default character set of the body of future HTTP requests.
\\
\hline
GET\_BODY\_CHARSET(charset OUT)
&
n/a
&
Returns the default character set of the body of future HTTP requests.
\\
\hline
GET\_FOLLOW\_REDIRECT(max\_redirects OUT)
&
n/a
&
Current setting for the maximum number of redirections allowed.
\\
\hline
GET\_HEADER(r IN OUT, n, name OUT, value OUT)
&
n/a
&
Returns the nth header of the HTTP response.
\\
\hline
GET\_HEADER\_BY\_NAME(r IN OUT, name, value OUT, n)
&
n/a
&
Returns the HTTP response header for the specified name.
\\
\hline
GET\_HEADER\_COUNT(r IN OUT)
&
INTEGER
&
Returns the number of HTTP response headers.
\\
\hline
GET\_RESPONSE(r IN OUT)
&
UTL\_HTTP.RESP
&
Returns the HTTP response.
\\
\hline
GET\_RESPONSE\_ERROR\_CHECK(enable OUT)
&
n/a
&
Returns whether or not response error check is set.
\\
\hline
GET\_TRANSFER\_TIMEOUT(timeout OUT)
&
n/a
&
Returns the transfer timeout setting for HTTP requests.
\\
\hline
(r IN OUT, data OUT, remove\_crlf)
&
n/a
&
Returns the HTTP response body in text form until the end of line.
\\
\hline
READ\_RAW(r IN OUT, data OUT, len)
&
n/a
&
Returns the HTTP response body in binary form for a specified number of bytes.
\\
\hline
READ\_TEXT(r IN OUT, data OUT, len)
&
n/a
&
Returns the HTTP response body in text form for a specified number of characters.
\\
\hline
REQUEST(url)
&
VARCHAR2
&
Returns the content of a web page.
\\
\hline
REQUEST\_PIECES(url, max\_pieces)
&
UTL\_HTTP.
HTML\_PIECES
&
Returns a table of 2000-byte segments retrieved from an URL.
\\
\hline
SET\_BODY\_CHARSET(charset)
&
n/a
&
Sets the default character set of the body of future HTTP requests.
\\
\hline
SET\_FOLLOW\_REDIRECT(max\_redirects)
&
n/a
&
Sets the maximum number of times to follow the redirect instruction.
\\
\hline
SET\_FOLLOW\_REDIRECT(r IN OUT, max\_redirects)
&
n/a
&
Sets the maximum number of times to follow the redirect instruction for an individual request.
\\
\hline
SET\_HEADER(r IN OUT, name, value)
&
n/a
&
Sets the HTTP request header.
\\
\hline
SET\_RESPONSE\_ERROR\_CHECK(enable)
&
n/a
&
Determines whether or not HTTP 4xx and 5xx status codes are to be treated as errors.
\\
\hline
SET\_TRANSFER\_TIMEOUT(timeout)
&
n/a
&
Sets the default, transfer timeout value for HTTP requests.
\\
\hline
SET\_TRANSFER\_TIMEOUT(r IN OUT, timeout)
&
n/a
&
Sets the transfer timeout value for an individual HTTP request.
\\
\hline
WRITE\_LINE(r IN OUT, data)
&
n/a
&
Writes CRLF terminated data to the HTTP request body in TEXT form.
\\
\hline
WRITE\_RAW(r IN OUT, data)
&
n/a
&
Writes data to the HTTP request body in BINARY form.
\\
\hline
WRITE\_TEXT(r IN OUT, data)
&
n/a
&
Writes data to the HTTP request body in TEXT form.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}

Advanced Server’s implementation of \sphinxcode{UTL\_HTTP} is a partial
implementation when compared to Oracle’s version. Only those functions
and procedures listed in the table above are supported.

\begin{sphinxadmonition}{note}{Note:}
In Advanced Server, an \sphinxcode{HTTP 4xx} or \sphinxcode{HTTP 5xx} response produces a database error; in Oracle, this is configurable but \sphinxcode{FALSE} by default.
\end{sphinxadmonition}

In Advanced Server, the \sphinxcode{UTL\_HTTP} text interfaces expect the downloaded
data to be in the database encoding. All currently-available interfaces
are text interfaces. In Oracle, the encoding is detected from HTTP
headers; in the absence of the header, the default is configurable and
defaults to \sphinxcode{ISO-8859-1}.

Advanced Server ignores all cookies it receives.

The \sphinxcode{UTL\_HTTP} exceptions that can be raised in Oracle are not recognized
by Advanced Server. In addition, the error codes returned by Advanced
Server are not the same as those returned by Oracle.

There are various public constants available with \sphinxcode{UTL\_HTTP}. These are
listed in the following tables.

The following table contains \sphinxcode{UTL\_HTTP} public constants defining HTTP
versions and port assignments.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{2}}
\sphinxstylethead{\sphinxstyletheadfamily \sphinxstylestrong{HTTP VERSIONS}
\unskip}\relax \par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline
HTTP\_VERSION\_1\_0
&
CONSTANT VARCHAR2(64) := ‘HTTP/1.0’;
\\
\hline
HTTP\_VERSION\_1\_1
&
CONSTANT VARCHAR2(64) := ‘HTTP/1.1’;
\\
\hline\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{2}}
\sphinxstylestrong{STANDARD PORT ASSIGNMENTS}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline
DEFAULT\_HTTP\_PORT
&
CONSTANT INTEGER := 80;
\\
\hline
DEFAULT\_HTTPS\_PORT
&
CONSTANT INTEGER := 443;
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

The following table contains \sphinxcode{UTL\_HTTP} public status code constants.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{2}}
\sphinxstylethead{\sphinxstyletheadfamily \sphinxstylestrong{1XX INFORMATIONAL}
\unskip}\relax \par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline
HTTP\_CONTINUE
&
CONSTANT INTEGER := 100;
\\
\hline
HTTP\_SWITCHING\_PROTOCOLS
&
CONSTANT INTEGER := 101;
\\
\hline
HTTP\_PROCESSING
&
CONSTANT INTEGER := 102;
\\
\hline\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{2}}
\sphinxstylestrong{2XX SUCCESS}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline
HTTP\_OK
&
CONSTANT INTEGER := 200;
\\
\hline
HTTP\_CREATED
&
CONSTANT INTEGER := 201;
\\
\hline
HTTP\_ACCEPTED
&
CONSTANT INTEGER := 202;
\\
\hline
HTTP\_NON\_AUTHORITATIVE\_INFO
&
CONSTANT INTEGER := 203;
\\
\hline
HTTP\_NO\_CONTENT
&
CONSTANT INTEGER := 204;
\\
\hline
HTTP\_RESET\_CONTENT
&
CONSTANT INTEGER := 205;
\\
\hline
HTTP\_PARTIAL\_CONTENT
&
CONSTANT INTEGER := 206;
\\
\hline
HTTP\_MULTI\_STATUS
&
CONSTANT INTEGER := 207;
\\
\hline
HTTP\_ALREADY\_REPORTED
&
CONSTANT INTEGER := 208;
\\
\hline
HTTP\_IM\_USED
&
CONSTANT INTEGER := 226;
\\
\hline\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{2}}
\sphinxstylestrong{3XX REDIRECTION}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline
HTTP\_MULTIPLE\_CHOICES
&
CONSTANT INTEGER := 300;
\\
\hline
HTTP\_MOVED\_PERMANENTLY
&
CONSTANT INTEGER := 301;
\\
\hline
HTTP\_FOUND
&
CONSTANT INTEGER := 302;
\\
\hline
HTTP\_SEE\_OTHER
&
CONSTANT INTEGER := 303;
\\
\hline
HTTP\_NOT\_MODIFIED
&
CONSTANT INTEGER := 304;
\\
\hline
HTTP\_USE\_PROXY
&
CONSTANT INTEGER := 305;
\\
\hline
HTTP\_SWITCH\_PROXY
&
CONSTANT INTEGER := 306;
\\
\hline
HTTP\_TEMPORARY\_REDIRECT
&
CONSTANT INTEGER := 307;
\\
\hline
HTTP\_PERMANENT\_REDIRECT
&
CONSTANT INTEGER := 308;
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\newpage


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}{|l|l|}
\hline
\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{2}}
\sphinxstylethead{\sphinxstyletheadfamily \sphinxstylestrong{4XX CLIENT ERROR}
\unskip}\relax \par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline
\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline
\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{2}}
\sphinxstylethead{\sphinxstyletheadfamily \sphinxstylestrong{4XX CLIENT ERROR}
\unskip}\relax \par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline
\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot

HTTP\_BAD\_REQUEST
&
CONSTANT INTEGER := 400;
\\
\hline
HTTP\_UNAUTHORIZED
&
CONSTANT INTEGER := 401;
\\
\hline
HTTP\_PAYMENT\_REQUIRED
&
CONSTANT INTEGER := 402;
\\
\hline
HTTP\_FORBIDDEN
&
CONSTANT INTEGER := 403;
\\
\hline
HTTP\_NOT\_FOUND
&
CONSTANT INTEGER := 404;
\\
\hline
HTTP\_METHOD\_NOT\_ALLOWED
&
CONSTANT INTEGER := 405;
\\
\hline
HTTP\_NOT\_ACCEPTABLE
&
CONSTANT INTEGER := 406;
\\
\hline
HTTP\_PROXY\_AUTH\_REQUIRED
&
CONSTANT INTEGER := 407;
\\
\hline
HTTP\_REQUEST\_TIME\_OUT
&
CONSTANT INTEGER := 408;
\\
\hline
HTTP\_CONFLICT
&
CONSTANT INTEGER := 409;
\\
\hline
HTTP\_GONE
&
CONSTANT INTEGER := 410;
\\
\hline
HTTP\_LENGTH\_REQUIRED
&
CONSTANT INTEGER := 411;
\\
\hline
HTTP\_PRECONDITION\_FAILED
&
CONSTANT INTEGER := 412;
\\
\hline
HTTP\_REQUEST\_ENTITY\_TOO\_LARGE
&
CONSTANT INTEGER := 413;
\\
\hline
HTTP\_REQUEST\_URI\_TOO\_LARGE
&
CONSTANT INTEGER := 414;
\\
\hline
HTTP\_UNSUPPORTED\_MEDIA\_TYPE
&
CONSTANT INTEGER := 415;
\\
\hline
HTTP\_REQ\_RANGE\_NOT\_SATISFIABLE
&
CONSTANT INTEGER := 416;
\\
\hline
HTTP\_EXPECTATION\_FAILED
&
CONSTANT INTEGER := 417;
\\
\hline
HTTP\_I\_AM\_A\_TEAPOT
&
CONSTANT INTEGER := 418;
\\
\hline
HTTP\_AUTHENTICATION\_TIME\_OUT
&
CONSTANT INTEGER := 419;
\\
\hline
HTTP\_ENHANCE\_YOUR\_CALM
&
CONSTANT INTEGER := 420;
\\
\hline
HTTP\_UNPROCESSABLE\_ENTITY
&
CONSTANT INTEGER := 422;
\\
\hline
HTTP\_LOCKED
&
CONSTANT INTEGER := 423;
\\
\hline
HTTP\_FAILED\_DEPENDENCY
&
CONSTANT INTEGER := 424;
\\
\hline
HTTP\_UNORDERED\_COLLECTION
&
CONSTANT INTEGER := 425;
\\
\hline
HTTP\_UPGRADE\_REQUIRED
&
CONSTANT INTEGER := 426;
\\
\hline
HTTP\_PRECONDITION\_REQUIRED
&
CONSTANT INTEGER := 428;
\\
\hline
HTTP\_TOO\_MANY\_REQUESTS
&
CONSTANT INTEGER := 429;
\\
\hline
HTTP\_REQUEST\_HEADER\_FIELDS\_TOO\_LARGE
&
CONSTANT INTEGER := 431;
\\
\hline
HTTP\_NO\_RESPONSE
&
CONSTANT INTEGER := 444;
\\
\hline
HTTP\_RETRY\_WITH
&
CONSTANT INTEGER := 449;
\\
\hline
HTTP\_BLOCKED\_BY\_WINDOWS\_PARENTAL\_CONTROLS
&
CONSTANT INTEGER := 450;
\\
\hline
HTTP\_REDIRECT
&
CONSTANT INTEGER := 451;
\\
\hline
HTTP\_REQUEST\_HEADER\_TOO\_LARGE
&
CONSTANT INTEGER := 494;
\\
\hline
HTTP\_CERT\_ERROR
&
CONSTANT INTEGER := 495;
\\
\hline
HTTP\_NO\_CERT
&
CONSTANT INTEGER := 496;
\\
\hline
HTTP\_HTTP\_TO\_HTTPS
&
CONSTANT INTEGER := 497;
\\
\hline
HTTP\_CLIENT\_CLOSED\_REQUEST
&
CONSTANT INTEGER := 499;
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}

\newpage


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{2}}
\sphinxstylethead{\sphinxstyletheadfamily \sphinxstylestrong{5XX SERVER ERROR}
\unskip}\relax \par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline
HTTP\_INTERNAL\_SERVER\_ERROR
&
CONSTANT INTEGER := 500;
\\
\hline
HTTP\_NOT\_IMPLEMENTED
&
CONSTANT INTEGER := 501;
\\
\hline
HTTP\_BAD\_GATEWAY
&
CONSTANT INTEGER := 502;
\\
\hline
HTTP\_SERVICE\_UNAVAILABLE
&
CONSTANT INTEGER := 503;
\\
\hline
HTTP\_GATEWAY\_TIME\_OUT
&
CONSTANT INTEGER := 504;
\\
\hline
HTTP\_VERSION\_NOT\_SUPPORTED
&
CONSTANT INTEGER := 505;
\\
\hline
HTTP\_VARIANT\_ALSO\_NEGOTIATES
&
CONSTANT INTEGER := 506;
\\
\hline
HTTP\_INSUFFICIENT\_STORAGE
&
CONSTANT INTEGER := 507;
\\
\hline
HTTP\_LOOP\_DETECTED
&
CONSTANT INTEGER := 508;
\\
\hline
HTTP\_BANDWIDTH\_LIMIT\_EXCEEDED
&
CONSTANT INTEGER := 509;
\\
\hline
HTTP\_NOT\_EXTENDED
&
CONSTANT INTEGER := 510;
\\
\hline
HTTP\_NETWORK\_AUTHENTICATION\_REQUIRED
&
CONSTANT INTEGER := 511;
\\
\hline
HTTP\_NETWORK\_READ\_TIME\_OUT\_ERROR
&
CONSTANT INTEGER := 598;
\\
\hline
HTTP\_NETWORK\_CONNECT\_TIME\_OUT\_ERROR
&
CONSTANT INTEGER := 599;
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{\index{HTML\_PIECES}HTML\_PIECES}
\label{\detokenize{utl_http:html-pieces}}
The \sphinxcode{UTL\_HTTP} package declares a type named \sphinxcode{HTML\_PIECES}, which is a
table of type \sphinxcode{VARCHAR2 (2000)} indexed by \sphinxcode{BINARY INTEGER}. A value of this
type is returned by the \sphinxcode{REQUEST\_PIECES} function.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
TYPE html\PYGZus{}pieces IS TABLE OF VARCHAR2(2000) INDEX BY BINARY\PYGZus{}INTEGER;
\end{sphinxVerbatim}


\subsection{\index{REQ}REQ}
\label{\detokenize{utl_http:req}}
The \sphinxcode{REQ} record type holds information about each HTTP request.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
TYPE req IS RECORD (
    url             VARCHAR2(32767),    \PYGZhy{}\PYGZhy{} URL to be accessed
    method          VARCHAR2(64),       \PYGZhy{}\PYGZhy{} HTTP method
    http\PYGZus{}version    VARCHAR2(64),       \PYGZhy{}\PYGZhy{} HTTP version
    private\PYGZus{}hndl    INTEGER             \PYGZhy{}\PYGZhy{} Holds handle for this request
);
\end{sphinxVerbatim}


\subsection{\index{RESP}RESP}
\label{\detokenize{utl_http:resp}}
The \sphinxcode{RESP} record type holds information about the response from each HTTP
request.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
TYPE resp IS RECORD (
    status\PYGZus{}code     INTEGER,            \PYGZhy{}\PYGZhy{} HTTP status code
    reason\PYGZus{}phrase   VARCHAR2(256),      \PYGZhy{}\PYGZhy{} HTTP response reason phrase
    http\PYGZus{}version    VARCHAR2(64),       \PYGZhy{}\PYGZhy{} HTTP version
    private\PYGZus{}hndl    INTEGER             \PYGZhy{}\PYGZhy{} Holds handle for this response
);
\end{sphinxVerbatim}


\subsection{\index{BEGIN\_REQUEST}BEGIN\_REQUEST}
\label{\detokenize{utl_http:begin-request}}
The \sphinxcode{BEGIN\_REQUEST} function initiates a new HTTP request. A network
connection is established to the web server with the specified URL. The
signature is:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{BEGIN\_REQUEST(\textless{}url\textgreater{} IN VARCHAR2, \textless{}method\textgreater{} IN VARCHAR2 DEFAULT}
\item[] \sphinxcode{'GET ', \textless{}http\_version\textgreater{} IN VARCHAR2 DEFAULT NULL) RETURN}
\item[] \sphinxcode{UTL\_HTTP.REQ}
\end{DUlineblock}
\end{quote}

The \sphinxcode{BEGIN\_REQUEST} function returns a record of type \sphinxcode{UTL\_HTTP.REQ}.

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}url\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}url\textgreater{}} is the Uniform Resource Locator from which \sphinxcode{UTL\_HTTP} will
return content.
\end{quote}

\sphinxcode{\textless{}method\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}method\textgreater{}} is the HTTP method to be used. The default is \sphinxcode{GET}.
\end{quote}

\sphinxcode{\textless{}http\_version\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}http\_version\textgreater{}} is the HTTP protocol version sending the request.
The specified values should be either \sphinxcode{HTTP/1.0 or HTTP/1.1}. The
default is null in which case the latest HTTP protocol version
supported by the \sphinxcode{UTL\_HTTP} package is used which is 1.1.
\end{quote}


\subsection{\index{END\_REQUEST}END\_REQUEST}
\label{\detokenize{utl_http:end-request}}
The \sphinxcode{END\_REQUEST} procedure terminates an HTTP request. Use the
\sphinxcode{END\_REQUEST} procedure to terminate an HTTP request without completing
it and waiting for the response. The normal process is to begin the
request, get the response, then close the response. The signature is:
\begin{quote}

\sphinxcode{END\_REQUEST(\textless{}r\textgreater{} IN OUT UTL\_HTTP.REQ)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}r\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}r\textgreater{}} is the HTTP request record.
\end{quote}


\subsection{\index{END\_RESPONSE}END\_RESPONSE}
\label{\detokenize{utl_http:end-response}}
The \sphinxcode{END\_RESPONSE} procedure terminates the HTTP response. The
\sphinxcode{END\_RESPONSE} procedure completes the HTTP request and response. This is
the normal method to end the request and response process. The signature
is:
\begin{quote}

\sphinxcode{END\_RESPONSE(\textless{}r\textgreater{} IN OUT UTL\_HTTP.RESP)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}r\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}r\textgreater{}} is the HTTP response record.
\end{quote}


\subsection{\index{GET\_BODY\_CHARSET}GET\_BODY\_CHARSET}
\label{\detokenize{utl_http:get-body-charset}}
The \sphinxcode{GET\_BODY\_CHARSET} program is available in the form of both a
procedure and a function. A call to \sphinxcode{GET\_BODY\_CHARSET} returns the
default character set of the body of future HTTP requests.

The procedure signature is:
\begin{quote}

\sphinxcode{GET\_BODY\_CHARSET(\textless{}charset\textgreater{} OUT VARCHAR2)}
\end{quote}

\newpage

The function signature is:
\begin{quote}

\sphinxcode{GET\_BODY\_CHARSET() RETURN VARCHAR2}
\end{quote}

This function returns a \sphinxcode{VARCHAR2} value.

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}charset\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}charset\textgreater{}} is the character set of the body.
\end{quote}

\sphinxstylestrong{Examples}

The following is an example of the \sphinxcode{GET\_BODY\_CHARSET} function.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
edb=\PYGZsh{} SELECT UTL\PYGZus{}HTTP.GET\PYGZus{}BODY\PYGZus{}CHARSET() FROM DUAL;
 get\PYGZus{}body\PYGZus{}charset
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
 ISO\PYGZhy{}8859\PYGZhy{}1
(1 row)
\end{sphinxVerbatim}


\subsection{\index{GET\_FOLLOW\_REDIRECT}GET\_FOLLOW\_REDIRECT}
\label{\detokenize{utl_http:get-follow-redirect}}
The \sphinxcode{GET\_FOLLOW\_REDIRECT} procedure returns the current setting for the
maximum number of redirections allowed. The signature is:
\begin{quote}

\sphinxcode{GET\_FOLLOW\_REDIRECT(\textless{}max\_redirects\textgreater{} OUT INTEGER)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}max\_redirects\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}max\_redirects\textgreater{}} is maximum number of redirections allowed.
\end{quote}


\subsection{\index{GET\_HEADER}GET\_HEADER}
\label{\detokenize{utl_http:get-header}}
The \sphinxcode{GET\_HEADER} procedure returns the \sphinxcode{nth} header of the HTTP
response. The signature is:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{GET\_HEADER(\textless{}r\textgreater{} IN OUT UTL\_HTTP.RESP, \textless{}n\textgreater{} INTEGER, \textless{}name\textgreater{} OUT}
\item[] \sphinxcode{VARCHAR2, \textless{}value\textgreater{} OUT VARCHAR2)}
\end{DUlineblock}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}r\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}r\textgreater{}} is the HTTP response record.
\end{quote}

\sphinxcode{\textless{}n\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}n\textgreater{}} is the \sphinxcode{nth} header of the HTTP response record to retrieve.
\end{quote}

\sphinxcode{\textless{}name\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}name\textgreater{}} is the name of the response header.
\end{quote}

\sphinxcode{\textless{}value\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}value\textgreater{}} is the value of the response header.
\end{quote}

\newpage

\sphinxstylestrong{Examples}

The following example retrieves the header count, then the headers.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    v\PYGZus{}req           UTL\PYGZus{}HTTP.REQ;
    v\PYGZus{}resp          UTL\PYGZus{}HTTP.RESP;
    v\PYGZus{}name          VARCHAR2(30);
    v\PYGZus{}value         VARCHAR2(200);
    v\PYGZus{}header\PYGZus{}cnt    INTEGER;
BEGIN
 \PYGZhy{}\PYGZhy{} Initiate request and get response
    v\PYGZus{}req := UTL\PYGZus{}HTTP.BEGIN\PYGZus{}REQUEST(\PYGZsq{}www.enterprisedb.com\PYGZsq{});
    v\PYGZus{}resp := UTL\PYGZus{}HTTP.GET\PYGZus{}RESPONSE(v\PYGZus{}req);

 \PYGZhy{}\PYGZhy{} Get header count
    v\PYGZus{}header\PYGZus{}cnt := UTL\PYGZus{}HTTP.GET\PYGZus{}HEADER\PYGZus{}COUNT(v\PYGZus{}resp);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Header Count: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}header\PYGZus{}cnt);

 \PYGZhy{}\PYGZhy{} Get all headers
    FOR i IN 1 .. v\PYGZus{}header\PYGZus{}cnt LOOP
        UTL\PYGZus{}HTTP.GET\PYGZus{}HEADER(v\PYGZus{}resp, i, v\PYGZus{}name, v\PYGZus{}value);
        DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(v\PYGZus{}name \textbar{}\textbar{} \PYGZsq{}: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}value);
    END LOOP;

 \PYGZhy{}\PYGZhy{} Terminate request
    UTL\PYGZus{}HTTP.END\PYGZus{}RESPONSE(v\PYGZus{}resp);
END;
\end{sphinxVerbatim}

The following is the output from the example.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Header Count: 23
Age: 570
Cache\PYGZhy{}Control: must\PYGZhy{}revalidate
Content\PYGZhy{}Type: text/html; charset=utf\PYGZhy{}8
Date: Wed, 30 Apr 2015 14:57:52 GMT
ETag: \PYGZdq{}aab02f2bd2d696eed817ca89ef411dda\PYGZdq{}
Expires: Sun, 19 Nov 1978 05:00:00 GMT
Last\PYGZhy{}Modified: Wed, 30 Apr 2015 14:15:49 GMT
RTSS: 1\PYGZhy{}1307\PYGZhy{}3
Server: Apache/2.2.3 (Red Hat)
Set\PYGZhy{}Cookie: SESS2771d0952de2a1a84d322a262e0c173c=jn1u1j1etmdi5gg4lh8hakvs01; expires=Fri, 23\PYGZhy{}May\PYGZhy{}2015 18:21:43 GMT; path=/; domain=.enterprisedb.com
Vary: Accept\PYGZhy{}Encoding
Via: 1.1 varnish
X\PYGZhy{}EDB\PYGZhy{}Backend: ec
X\PYGZhy{}EDB\PYGZhy{}Cache: HIT
X\PYGZhy{}EDB\PYGZhy{}Cache\PYGZhy{}Address: 10.31.162.212
X\PYGZhy{}EDB\PYGZhy{}Cache\PYGZhy{}Server: ip\PYGZhy{}10\PYGZhy{}31\PYGZhy{}162\PYGZhy{}212
X\PYGZhy{}EDB\PYGZhy{}Cache\PYGZhy{}TTL: 600.000
X\PYGZhy{}EDB\PYGZhy{}Cacheable: MAYBE: The user has a cookie of some sort. Maybe it\PYGZsq{}s double choc\PYGZhy{}chip!
X\PYGZhy{}EDB\PYGZhy{}Do\PYGZhy{}GZIP: false
X\PYGZhy{}Powered\PYGZhy{}By: PHP/5.2.17
X\PYGZhy{}Varnish: 484508634 484506789
transfer\PYGZhy{}encoding: chunked
Connection: keep\PYGZhy{}alive
\end{sphinxVerbatim}

\newpage


\subsection{\index{GET\_HEADER\_BY\_NAME}GET\_HEADER\_BY\_NAME}
\label{\detokenize{utl_http:get-header-by-name}}
The \sphinxcode{GET\_HEADER\_BY\_NAME} procedure returns the header of the HTTP
response according to the specified name. The signature is:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{GET\_HEADER\_BY\_NAME(\textless{}r\textgreater{} IN OUT UTL\_HTTP.RESP, \textless{}name\textgreater{} VARCHAR2},
\item[] \sphinxcode{\textless{}value\textgreater{} OUT VARCHAR2, \textless{}n\textgreater{} INTEGER DEFAULT 1)}
\end{DUlineblock}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}r\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}r\textgreater{}} is the HTTP response record.
\end{quote}

\sphinxcode{\textless{}name\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}name\textgreater{}} is the name of the response header to retrieve.
\end{quote}

\sphinxcode{\textless{}value\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}value\textgreater{}} is the value of the response header.
\end{quote}

\sphinxcode{\textless{}n\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}n\textgreater{}} is the \sphinxcode{nth} header of the HTTP response record to retrieve
according to the values specified by \sphinxcode{\textless{}name\textgreater{}}. The default is 1.
\end{quote}

\sphinxstylestrong{Examples}

The following example retrieves the header for Content-Type.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    v\PYGZus{}req           UTL\PYGZus{}HTTP.REQ;
    v\PYGZus{}resp          UTL\PYGZus{}HTTP.RESP;
    v\PYGZus{}name          VARCHAR2(30) := \PYGZsq{}Content\PYGZhy{}Type\PYGZsq{};
    v\PYGZus{}value         VARCHAR2(200);
BEGIN
    v\PYGZus{}req := UTL\PYGZus{}HTTP.BEGIN\PYGZus{}REQUEST(\PYGZsq{}www.enterprisedb.com\PYGZsq{});
    v\PYGZus{}resp := UTL\PYGZus{}HTTP.GET\PYGZus{}RESPONSE(v\PYGZus{}req);
    UTL\PYGZus{}HTTP.GET\PYGZus{}HEADER\PYGZus{}BY\PYGZus{}NAME(v\PYGZus{}resp, v\PYGZus{}name, v\PYGZus{}value);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(v\PYGZus{}name \textbar{}\textbar{} \PYGZsq{}: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}value);
    UTL\PYGZus{}HTTP.END\PYGZus{}RESPONSE(v\PYGZus{}resp);
END;

Content\PYGZhy{}Type: text/html; charset=utf\PYGZhy{}8
\end{sphinxVerbatim}


\subsection{\index{GET\_HEADER\_COUNT}GET\_HEADER\_COUNT}
\label{\detokenize{utl_http:get-header-count}}
The \sphinxcode{GET\_HEADER\_COUNT} function returns the number of HTTP response
headers. The signature is:
\begin{quote}

\sphinxcode{GET\_HEADER\_COUNT(\textless{}r\textgreater{} IN OUT UTL\_HTTP.RESP) RETURN INTEGER}
\end{quote}

This function returns an \sphinxcode{INTEGER} value.

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}r\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}r\textgreater{}} is the HTTP response record.
\end{quote}


\subsection{\index{GET\_RESPONSE}GET\_RESPONSE}
\label{\detokenize{utl_http:get-response}}
The \sphinxcode{GET\_RESPONSE} function sends the network request and returns any
HTTP response. The signature is:
\begin{quote}

\sphinxcode{GET\_RESPONSE(\textless{}r\textgreater{} IN OUT UTL\_HTTP.REQ) RETURN UTL\_HTTP.RESP}
\end{quote}

This function returns a \sphinxcode{UTL\_HTTP.RESP} record.

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}r\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}r\textgreater{}} is the HTTP request record.
\end{quote}


\subsection{\index{GET\_RESPONSE\_ERROR\_CHECK}GET\_RESPONSE\_ERROR\_CHECK}
\label{\detokenize{utl_http:get-response-error-check}}
The \sphinxcode{GET\_RESPONSE\_ERROR\_CHECK} procedure returns whether or not
response error check is set. The signature is:
\begin{quote}

\sphinxcode{GET\_RESPONSE\_ERROR\_CHECK(\textless{}enable\textgreater{} OUT BOOLEAN)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}enable\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}enable\textgreater{}} returns \sphinxcode{TRUE} if response error check is set, otherwise it
returns \sphinxcode{FALSE}.
\end{quote}


\subsection{\index{GET\_TRANSFER\_TIMEOUT}GET\_TRANSFER\_TIMEOUT}
\label{\detokenize{utl_http:get-transfer-timeout}}
The \sphinxcode{GET\_TRANSFER\_TIMEOUT} procedure returns the current, default
transfer timeout setting for HTTP requests. The signature is:
\begin{quote}

\sphinxcode{GET\_TRANSFER\_TIMEOUT(\textless{}timeout\textgreater{} OUT INTEGER)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}timeout\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}timeout\textgreater{}} is the transfer timeout setting in seconds.
\end{quote}

\newpage


\subsection{\index{READ\_LINE}READ\_LINE}
\label{\detokenize{utl_http:read-line}}
The \sphinxcode{READ\_LINE} procedure returns the data from the HTTP response body in
text form until the end of line is reached. A \sphinxcode{CR} character, a \sphinxcode{LF}
character, a \sphinxcode{CR LF} sequence, or the end of the response body constitutes
the end of line. The signature is:
\begin{quote}

\sphinxcode{READ\_LINE(\textless{}r\textgreater{} IN OUT UTL\_HTTP.RESP, \textless{}data\textgreater{} OUT VARCHAR2},
\sphinxcode{\textless{}remove\_crlf\textgreater{} BOOLEAN DEFAULT FALSE)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}r\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}r\textgreater{}} is the HTTP response record.
\end{quote}

\sphinxcode{\textless{}data\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}data\textgreater{}} is the response body in text form.
\end{quote}

\sphinxcode{\textless{}remove\_crlf\textgreater{}}
\begin{quote}

Set \sphinxcode{\textless{}remove\_crlf\textgreater{}} to \sphinxcode{TRUE} to remove new line characters, otherwise
set to \sphinxcode{FALSE}. The default is \sphinxcode{FALSE}.
\end{quote}

\sphinxstylestrong{Examples}

The following example retrieves and displays the body of the specified
website.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    v\PYGZus{}req           UTL\PYGZus{}HTTP.REQ;
    v\PYGZus{}resp          UTL\PYGZus{}HTTP.RESP;
    v\PYGZus{}value         VARCHAR2(1024);
BEGIN
    v\PYGZus{}req := UTL\PYGZus{}HTTP.BEGIN\PYGZus{}REQUEST(\PYGZsq{}http://www.enterprisedb.com\PYGZsq{});
    v\PYGZus{}resp := UTL\PYGZus{}HTTP.GET\PYGZus{}RESPONSE(v\PYGZus{}req);
    LOOP
        UTL\PYGZus{}HTTP.READ\PYGZus{}LINE(v\PYGZus{}resp, v\PYGZus{}value, TRUE);
        DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(v\PYGZus{}value);
    END LOOP;
    EXCEPTION
        WHEN OTHERS THEN
            UTL\PYGZus{}HTTP.END\PYGZus{}RESPONSE(v\PYGZus{}resp);
END;
\end{sphinxVerbatim}

The following is the output.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}!DOCTYPE html PUBLIC \PYGZdq{}\PYGZhy{}//W3C//DTD XHTML 1.0 Strict//EN\PYGZdq{}
  \PYGZdq{}http://www.w3.org/TR/xhtml1/DTD/xhtml1\PYGZhy{}strict.dtd\PYGZdq{}\PYGZgt{}
\PYGZlt{}html xmlns=\PYGZdq{}http://www.w3.org/1999/xhtml\PYGZdq{} xml:lang=\PYGZdq{}en\PYGZdq{} lang=\PYGZdq{}en\PYGZdq{} dir=\PYGZdq{}ltr\PYGZdq{}\PYGZgt{}

  \PYGZlt{}!\PYGZhy{}\PYGZhy{} \PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{} HEAD \PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{} \PYGZhy{}\PYGZhy{}\PYGZgt{}

  \PYGZlt{}head\PYGZgt{}
\PYGZlt{}meta http\PYGZhy{}equiv=\PYGZdq{}Content\PYGZhy{}Type\PYGZdq{} content=\PYGZdq{}text/html; charset=utf\PYGZhy{}8\PYGZdq{} /\PYGZgt{}


    \PYGZlt{}title\PYGZgt{}EnterpriseDB \textbar{} The Postgres Database Company\PYGZlt{}/title\PYGZgt{}

    \PYGZlt{}meta http\PYGZhy{}equiv=\PYGZdq{}Content\PYGZhy{}Type\PYGZdq{} content=\PYGZdq{}text/html; charset=utf\PYGZhy{}8\PYGZdq{} /\PYGZgt{}
\PYGZlt{}meta name=\PYGZdq{}keywords\PYGZdq{} content=\PYGZdq{}postgres, postgresql, postgresql installer, mysql migration, open source database, training, replication\PYGZdq{} /\PYGZgt{}
\PYGZlt{}meta name=\PYGZdq{}description\PYGZdq{} content=\PYGZdq{}The leader in open source database products, services, support, training and expertise based on PostgreSQL. Free downloads, documentation, and tutorials.\PYGZdq{} /\PYGZgt{}
\PYGZlt{}meta name=\PYGZdq{}abstract\PYGZdq{} content=\PYGZdq{}The Enterprise PostgreSQL Company\PYGZdq{} /\PYGZgt{}
\PYGZlt{}link rel=\PYGZdq{}EditURI\PYGZdq{} type=\PYGZdq{}application/rsd+xml\PYGZdq{} title=\PYGZdq{}RSD\PYGZdq{} href=\PYGZdq{}http://www.enterprisedb.com/blogapi/rsd\PYGZdq{} /\PYGZgt{}
\PYGZlt{}link rel=\PYGZdq{}alternate\PYGZdq{} type=\PYGZdq{}application/rss+xml\PYGZdq{} title=\PYGZdq{}EnterpriseDB RSS\PYGZdq{} href=\PYGZdq{}http://www.enterprisedb.com/rss.xml\PYGZdq{} /\PYGZgt{}
\PYGZlt{}link rel=\PYGZdq{}shortcut icon\PYGZdq{} href=\PYGZdq{}/sites/all/themes/edb\PYGZus{}pixelcrayons/favicon.ico\PYGZdq{} type=\PYGZdq{}image/x\PYGZhy{}icon\PYGZdq{} /\PYGZgt{}
    \PYGZlt{}link type=\PYGZdq{}text/css\PYGZdq{} rel=\PYGZdq{}stylesheet\PYGZdq{} media=\PYGZdq{}all\PYGZdq{} href=\PYGZdq{}/sites/default/files/css/css\PYGZus{}db11adabae0aed6b79a2c3c52def4754.css\PYGZdq{} /\PYGZgt{}
\PYGZlt{}!\PYGZhy{}\PYGZhy{}[if IE 6]\PYGZgt{}
\PYGZlt{}link type=\PYGZdq{}text/css\PYGZdq{} rel=\PYGZdq{}stylesheet\PYGZdq{} media=\PYGZdq{}all\PYGZdq{} href=\PYGZdq{}/sites/all/themes/oho\PYGZus{}basic/css/ie6.css?g\PYGZdq{} /\PYGZgt{}
\PYGZlt{}![endif]\PYGZhy{}\PYGZhy{}\PYGZgt{}
\PYGZlt{}!\PYGZhy{}\PYGZhy{}[if IE 7]\PYGZgt{}
\PYGZlt{}link type=\PYGZdq{}text/css\PYGZdq{} rel=\PYGZdq{}stylesheet\PYGZdq{} media=\PYGZdq{}all\PYGZdq{} href=\PYGZdq{}/sites/all/themes/oho\PYGZus{}basic/css/ie7.css?g\PYGZdq{} /\PYGZgt{}
\PYGZlt{}![endif]\PYGZhy{}\PYGZhy{}\PYGZgt{}
    \PYGZlt{}script type=\PYGZdq{}text/javascript\PYGZdq{} src=\PYGZdq{}/sites/default/files/js/js\PYGZus{}74d97b1176812e2fd6e43d62503a5204.js\PYGZdq{}\PYGZgt{}\PYGZlt{}/script\PYGZgt{}
\PYGZlt{}script type=\PYGZdq{}text/javascript\PYGZdq{}\PYGZgt{}
\PYGZlt{}!\PYGZhy{}\PYGZhy{}//\PYGZhy{}\PYGZhy{}\PYGZgt{}\PYGZlt{}![CDATA[//\PYGZgt{}\PYGZlt{}!\PYGZhy{}\PYGZhy{}
\end{sphinxVerbatim}

\newpage


\subsection{\index{READ\_RAW}READ\_RAW}
\label{\detokenize{utl_http:read-raw}}
The \sphinxcode{READ\_RAW} procedure returns the data from the HTTP response body in
binary form. The number of bytes returned is specified by the \sphinxcode{\textless{}len\textgreater{}}
parameter. The signature is:
\begin{quote}

\sphinxcode{READ\_RAW(\textless{}r\textgreater{} IN OUT UTL\_HTTP.RESP, \textless{}data\textgreater{} OUT RAW, \textless{}len\textgreater{}}
\sphinxcode{INTEGER)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}r\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}r\textgreater{}} is the HTTP response record.
\end{quote}

\sphinxcode{\textless{}data\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}data\textgreater{}} is the response body in binary form.
\end{quote}

\sphinxcode{\textless{}len\textgreater{}}
\begin{quote}

Set \sphinxcode{\textless{}len\textgreater{}} to the number of bytes of data to be returned.
\end{quote}

\sphinxstylestrong{Examples}

The following example retrieves and displays the first 150 bytes in
binary form.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    v\PYGZus{}req           UTL\PYGZus{}HTTP.REQ;
    v\PYGZus{}resp          UTL\PYGZus{}HTTP.RESP;
    v\PYGZus{}data          RAW;
BEGIN
    v\PYGZus{}req := UTL\PYGZus{}HTTP.BEGIN\PYGZus{}REQUEST(\PYGZsq{}http://www.enterprisedb.com\PYGZsq{});
    v\PYGZus{}resp := UTL\PYGZus{}HTTP.GET\PYGZus{}RESPONSE(v\PYGZus{}req);
    UTL\PYGZus{}HTTP.READ\PYGZus{}RAW(v\PYGZus{}resp, v\PYGZus{}data, 150);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(v\PYGZus{}data);
    UTL\PYGZus{}HTTP.END\PYGZus{}RESPONSE(v\PYGZus{}resp);
END;
\end{sphinxVerbatim}

The following is the output from the example.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZbs{}x3c21444f43545950452068746d6c205055424c494320222d2f2f5733432f2f4454442058485
44d4c20312e30205374726963742f2f454e220d0a202022687474703a2f2f7777772e77332e6f
72672f54522f7868746d6c312f4454442f7868746d6c312d7374726963742e647464223e0d0a3
c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f
\end{sphinxVerbatim}


\subsection{\index{READ\_TEXT}READ\_TEXT}
\label{\detokenize{utl_http:read-text}}
The \sphinxcode{READ\_TEXT} procedure returns the data from the HTTP response body in
text form. The maximum number of characters returned is specified by the
\sphinxcode{\textless{}len\textgreater{}} parameter. The signature is:
\begin{quote}

\sphinxcode{READ\_TEXT(\textless{}r\textgreater{} IN OUT UTL\_HTTP.RESP, \textless{}data\textgreater{} OUT VARCHAR2, \textless{}len\textgreater{}}
\sphinxcode{INTEGER)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}r\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}r\textgreater{}} is the HTTP response record.
\end{quote}

\sphinxcode{\textless{}data\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}data\textgreater{}} is the response body in text form.
\end{quote}

\sphinxcode{\textless{}len\textgreater{}}
\begin{quote}

Set \sphinxcode{\textless{}len\textgreater{}} to the maximum number of characters to be returned.
\end{quote}

\sphinxstylestrong{Examples}

The following example retrieves the first 150 characters.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    v\PYGZus{}req           UTL\PYGZus{}HTTP.REQ;
    v\PYGZus{}resp          UTL\PYGZus{}HTTP.RESP;
    v\PYGZus{}data          VARCHAR2(150);
BEGIN
    v\PYGZus{}req := UTL\PYGZus{}HTTP.BEGIN\PYGZus{}REQUEST(\PYGZsq{}http://www.enterprisedb.com\PYGZsq{});
    v\PYGZus{}resp := UTL\PYGZus{}HTTP.GET\PYGZus{}RESPONSE(v\PYGZus{}req);
    UTL\PYGZus{}HTTP.READ\PYGZus{}TEXT(v\PYGZus{}resp, v\PYGZus{}data, 150);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(v\PYGZus{}data);
    UTL\PYGZus{}HTTP.END\PYGZus{}RESPONSE(v\PYGZus{}resp);
END;
\end{sphinxVerbatim}

The following is the output.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}!DOCTYPE html PUBLIC \PYGZdq{}\PYGZhy{}//W3C//DTD XHTML 1.0 Strict//EN\PYGZdq{}
  \PYGZdq{}http://www.w3.org/TR/xhtml1/DTD/xhtml1\PYGZhy{}strict.dtd\PYGZdq{}\PYGZgt{}
\PYGZlt{}html xmlns=\PYGZdq{}http://www.w3.org/1999/
\end{sphinxVerbatim}


\subsection{\index{REQUEST}REQUEST}
\label{\detokenize{utl_http:request}}
The \sphinxcode{REQUEST} function returns the first 2000 bytes retrieved from a
user-specified URL. The signature is:
\begin{quote}

\sphinxcode{REQUEST(\textless{}url\textgreater{} IN VARCHAR2) RETURN VARCHAR2}
\end{quote}

If the data found at the given URL is longer than 2000 bytes, the
remainder will be discarded. If the data found at the given URL is
shorter than 2000 bytes, the result will be shorter than 2000 bytes.

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}url\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}url\textgreater{}} is the Uniform Resource Locator from which UTL\_HTTP will
return content.
\end{quote}

\sphinxstylestrong{Example}

The following command returns the first 2000 bytes retrieved from the
EnterpriseDB website:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
SELECT UTL\PYGZus{}HTTP.REQUEST(\PYGZsq{}http://www.enterprisedb.com/\PYGZsq{}) FROM DUAL;
\end{sphinxVerbatim}

\newpage


\subsection{\index{REQUEST\_PIECES}REQUEST\_PIECES}
\label{\detokenize{utl_http:request-pieces}}
The \sphinxcode{REQUEST\_PIECES} function returns a table of 2000-byte segments
retrieved from an URL. The signature is:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{REQUEST\_PIECES(\textless{}url\textgreater{} IN VARCHAR2, \textless{}max\_pieces\textgreater{} NUMBER IN}
\item[] \sphinxcode{DEFAULT 32767) RETURN UTL\_HTTP.HTML\_PIECES}
\end{DUlineblock}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}url\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}url\textgreater{}} is the Uniform Resource Locator from which \sphinxcode{UTL\_HTTP} will
return content.
\end{quote}

\sphinxcode{\textless{}max\_pieces\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}max\_pieces\textgreater{}} specifies the maximum number of 2000-byte segments
that the \sphinxcode{REQUEST\_PIECES} function will return. If \sphinxcode{\textless{}max\_pieces\textgreater{}}
specifies more units than are available at the specified \sphinxcode{\textless{}url\textgreater{}}, the
final unit will contain fewer bytes.
\end{quote}

\sphinxstylestrong{Example}

The following example returns the first four 2000 byte segments
retrieved from the EnterpriseDB website:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    result UTL\PYGZus{}HTTP.HTML\PYGZus{}PIECES;
BEGIN
result := UTL\PYGZus{}HTTP.REQUEST\PYGZus{}PIECES(\PYGZsq{}http://www.enterprisedb.com/\PYGZsq{}, 4);
END
\end{sphinxVerbatim}


\subsection{\index{SET\_BODY\_CHARSET}SET\_BODY\_CHARSET}
\label{\detokenize{utl_http:set-body-charset}}
The \sphinxcode{SET\_BODY\_CHARSET} procedure sets the default character set of the
body of future HTTP requests. The signature is:
\begin{quote}

\sphinxcode{SET\_BODY\_CHARSET(\textless{}charset\textgreater{} VARCHAR2 DEFAULT NULL)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}charset\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}charset\textgreater{}} is the character set of the body of future requests. The
default is null in which case the database character set is assumed.
\end{quote}


\subsection{\index{SET\_FOLLOW\_REDIRECT}SET\_FOLLOW\_REDIRECT}
\label{\detokenize{utl_http:set-follow-redirect}}
The \sphinxcode{SET\_FOLLOW\_REDIRECT} procedure sets the maximum number of times the
HTTP redirect instruction is to be followed in the response to this
request or future requests. This procedures has two signatures:
\begin{quote}

\sphinxcode{SET\_FOLLOW\_REDIRECT(\textless{}max\_redirects\textgreater{} IN INTEGER DEFAULT 3)}
\end{quote}

and
\begin{quote}

\sphinxcode{SET\_FOLLOW\_REDIRECT(\textless{}r\textgreater{} IN OUT UTL\_HTTP.REQ, \textless{}max\_redirects\textgreater{}}
\sphinxcode{IN INTEGER DEFAULT 3)}
\end{quote}

Use the second form to change the maximum number of redirections for an
individual request that a request inherits from the session default
settings.

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}r\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}r\textgreater{}} is the HTTP request record.
\end{quote}

\sphinxcode{\textless{}max\_redirects\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}max\_redirects\textgreater{}} is maximum number of redirections allowed. Set to 0
to disable redirections. The default is 3.
\end{quote}


\subsection{\index{SET\_HEADER}SET\_HEADER}
\label{\detokenize{utl_http:set-header}}
The \sphinxcode{SET\_HEADER} procedure sets the HTTP request header. The signature
is:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{SET\_HEADER(\textless{}r\textgreater{} IN OUT UTL\_HTTP.REQ, \textless{}name\textgreater{} IN VARCHAR2, \textless{}value\textgreater{}}
\item[] \sphinxcode{IN VARCHAR2 DEFAULT NULL)}
\end{DUlineblock}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}r\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}r\textgreater{}} is the HTTP request record.
\end{quote}

\sphinxcode{\textless{}name\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}name\textgreater{}} is the name of the request header.
\end{quote}

\sphinxcode{\textless{}value\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}value\textgreater{}} is the value of the request header. The default is null.
\end{quote}


\subsection{\index{SET\_RESPONSE\_ERROR\_CHECK}SET\_RESPONSE\_ERROR\_CHECK}
\label{\detokenize{utl_http:set-response-error-check}}
The \sphinxcode{SET\_RESPONSE\_ERROR\_CHECK} procedure determines whether or not HTTP
4xx and 5xx status codes returned by the \sphinxcode{GET\_RESPONSE} function should
be interpreted as errors. The signature is:
\begin{quote}

\sphinxcode{SET\_RESPONSE\_ERROR\_CHECK(\textless{}enable\textgreater{} IN BOOLEAN DEFAULT FALSE)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}enable\textgreater{}}
\begin{quote}

Set \sphinxcode{\textless{}enable\textgreater{}} to \sphinxcode{TRUE} if HTTP 4xx and 5xx status codes are to be
treated as errors, otherwise set to \sphinxcode{FALSE}. The default is \sphinxcode{FALSE}.
\end{quote}


\subsection{\index{SET\_TRANSFER\_TIMEOUT}SET\_TRANSFER\_TIMEOUT}
\label{\detokenize{utl_http:set-transfer-timeout}}
The \sphinxcode{SET\_TRANSFER\_TIMEOUT} procedure sets the default, transfer timeout
setting for waiting for a response from an HTTP request. This procedure
has two signatures:
\begin{quote}

\sphinxcode{SET\_TRANSFER\_TIMEOUT(\textless{}timeout\textgreater{} IN INTEGER DEFAULT 60)}
\end{quote}

and
\begin{quote}

\sphinxcode{SET\_TRANSFER\_TIMEOUT(\textless{}r\textgreater{} IN OUT UTL\_HTTP.REQ, \textless{}timeout\textgreater{} IN}
\sphinxcode{INTEGER DEFAULT 60)}
\end{quote}

Use the second form to change the transfer timeout setting for an
individual request that a request inherits from the session default
settings.

\newpage

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}r\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}r\textgreater{}} is the HTTP request record.
\end{quote}

\sphinxcode{\textless{}timeout\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}timeout\textgreater{}} is the transfer timeout setting in seconds for HTTP
requests. The default is 60 seconds.
\end{quote}


\subsection{\index{WRITE\_LINE}WRITE\_LINE}
\label{\detokenize{utl_http:write-line}}
The \sphinxcode{WRITE\_LINE} procedure writes data to the HTTP request body in text
form; the text is terminated with a CRLF character pair. The signature
is:
\begin{quote}

\sphinxcode{WRITE\_LINE(\textless{}r\textgreater{} IN OUT UTL\_HTTP.REQ, \textless{}data\textgreater{} IN VARCHAR2)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}r\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}r\textgreater{}} is the HTTP request record.
\end{quote}

\sphinxcode{\textless{}data\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}data\textgreater{}} is the request body in \sphinxcode{TEXT} form.
\end{quote}

\sphinxstylestrong{Example}

The following example writes data (\sphinxcode{Account balance \$500.00}) in text form
to the request body to be sent using the HTTP \sphinxcode{POST} method. The data is
sent to a hypothetical web application (\sphinxcode{post.php}) that accepts and
processes data.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    v\PYGZus{}req           UTL\PYGZus{}HTTP.REQ;
    v\PYGZus{}resp          UTL\PYGZus{}HTTP.RESP;
BEGIN
    v\PYGZus{}req := UTL\PYGZus{}HTTP.BEGIN\PYGZus{}REQUEST(\PYGZsq{}http://www.example.com/post.php\PYGZsq{},
       \PYGZsq{}POST\PYGZsq{});
    UTL\PYGZus{}HTTP.SET\PYGZus{}HEADER(v\PYGZus{}req, \PYGZsq{}Content\PYGZhy{}Length\PYGZsq{}, \PYGZsq{}23\PYGZsq{});
    UTL\PYGZus{}HTTP.WRITE\PYGZus{}LINE(v\PYGZus{}req, \PYGZsq{}Account balance \PYGZdl{}500.00\PYGZsq{});
    v\PYGZus{}resp := UTL\PYGZus{}HTTP.GET\PYGZus{}RESPONSE(v\PYGZus{}req);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Status Code: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}resp.status\PYGZus{}code);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Reason Phrase: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}resp.reason\PYGZus{}phrase);
    UTL\PYGZus{}HTTP.END\PYGZus{}RESPONSE(v\PYGZus{}resp);
END;
\end{sphinxVerbatim}

Assuming the web application successfully processed the \sphinxcode{POST} method, the following output would be displayed:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Status Code: 200
Reason Phrase: OK
\end{sphinxVerbatim}

\newpage


\subsection{\index{WRITE\_RAW}WRITE\_RAW}
\label{\detokenize{utl_http:write-raw}}
The \sphinxcode{WRITE\_RAW} procedure writes data to the HTTP request body in binary
form. The signature is:
\begin{quote}

\sphinxcode{WRITE\_RAW(\textless{}r\textgreater{} IN OUT UTL\_HTTP.REQ, \textless{}data\textgreater{} IN RAW)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}r\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}r\textgreater{}} is the HTTP request record.
\end{quote}

\sphinxcode{\textless{}data\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}data\textgreater{}} is the request body in binary form.
\end{quote}

\sphinxstylestrong{Example}

The following example writes data in binary form to the request body to
be sent using the HTTP POST method to a hypothetical web application
that accepts and processes such data.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    v\PYGZus{}req           UTL\PYGZus{}HTTP.REQ;
    v\PYGZus{}resp          UTL\PYGZus{}HTTP.RESP;
BEGIN
    v\PYGZus{}req := UTL\PYGZus{}HTTP.BEGIN\PYGZus{}REQUEST(\PYGZsq{}http://www.example.com/post.php\PYGZsq{},
       \PYGZsq{}POST\PYGZsq{});
    UTL\PYGZus{}HTTP.SET\PYGZus{}HEADER(v\PYGZus{}req, \PYGZsq{}Content\PYGZhy{}Length\PYGZsq{}, \PYGZsq{}23\PYGZsq{});
    UTL\PYGZus{}HTTP.WRITE\PYGZus{}RAW(v\PYGZus{}req, HEXTORAW
(\PYGZsq{}54657374696e6720504f5354206d6574686f6420696e20485454502072657175657374\PYGZsq{}));
    v\PYGZus{}resp := UTL\PYGZus{}HTTP.GET\PYGZus{}RESPONSE(v\PYGZus{}req);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Status Code: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}resp.status\PYGZus{}code);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Reason Phrase: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}resp.reason\PYGZus{}phrase);
    UTL\PYGZus{}HTTP.END\PYGZus{}RESPONSE(v\PYGZus{}resp);
END;
\end{sphinxVerbatim}

The text string shown in the \sphinxcode{HEXTORAW} function is the hexadecimal
translation of the text \sphinxcode{Testing POST method in HTTP request}.

Assuming the web application successfully processed the \sphinxcode{POST} method, the
following output would be displayed:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Status Code: 200
Reason Phrase: OK
\end{sphinxVerbatim}

\newpage


\subsection{\index{WRITE\_TEXT}WRITE\_TEXT}
\label{\detokenize{utl_http:write-text}}
The \sphinxcode{WRITE\_TEXT} procedure writes data to the HTTP request body in text
form. The signature is:
\begin{quote}

\sphinxcode{WRITE\_TEXT(\textless{}r\textgreater{} IN OUT UTL\_HTTP.REQ, \textless{}data\textgreater{} IN VARCHAR2)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}r\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}r\textgreater{}} is the HTTP request record.
\end{quote}

\sphinxcode{\textless{}data\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}data\textgreater{}} is the request body in text form.
\end{quote}

\sphinxstylestrong{Example}

The following example writes data (\sphinxcode{Account balance \$500.00}) in text form
to the request body to be sent using the HTTP \sphinxcode{POST} method. The data is
sent to a hypothetical web application (\sphinxcode{post.php}) that accepts and
processes data.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    v\PYGZus{}req           UTL\PYGZus{}HTTP.REQ;
    v\PYGZus{}resp          UTL\PYGZus{}HTTP.RESP;
BEGIN
    v\PYGZus{}req := UTL\PYGZus{}HTTP.BEGIN\PYGZus{}REQUEST(\PYGZsq{}http://www.example.com/post.php\PYGZsq{},
       \PYGZsq{}POST\PYGZsq{});
    UTL\PYGZus{}HTTP.SET\PYGZus{}HEADER(v\PYGZus{}req, \PYGZsq{}Content\PYGZhy{}Length\PYGZsq{}, \PYGZsq{}23\PYGZsq{});
    UTL\PYGZus{}HTTP.WRITE\PYGZus{}TEXT(v\PYGZus{}req, \PYGZsq{}Account balance \PYGZdl{}500.00\PYGZsq{});
    v\PYGZus{}resp := UTL\PYGZus{}HTTP.GET\PYGZus{}RESPONSE(v\PYGZus{}req);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Status Code: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}resp.status\PYGZus{}code);
    DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(\PYGZsq{}Reason Phrase: \PYGZsq{} \textbar{}\textbar{} v\PYGZus{}resp.reason\PYGZus{}phrase);
    UTL\PYGZus{}HTTP.END\PYGZus{}RESPONSE(v\PYGZus{}resp);
END;
\end{sphinxVerbatim}

Assuming the web application successfully processed the \sphinxcode{POST} method, the
following output would be displayed:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Status Code: 200
Reason Phrase: OK
\end{sphinxVerbatim}

\newpage


\section{\index{UTL\_MAIL}UTL\_MAIL}
\label{\detokenize{utl_mail:utl-mail}}\label{\detokenize{utl_mail::doc}}
The \sphinxcode{UTL\_MAIL} package provides the capability to manage e-mail. Advanced
Server supports the following procedures:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

Function/Procedure
&
Return Type
&
Description
\\
\hline
SEND(\textless{}sender\textgreater{}, \textless{}recipients\textgreater{}, \textless{}cc\textgreater{}, \textless{}bcc\textgreater{}, \textless{}subject\textgreater{}, \textless{}message\textgreater{} {[}, \textless{}mime\_type\textgreater{} {[}, \textless{}priority\textgreater{} {]}{]})
&
n/a
&
Packages and sends an e-mail to an SMTP server.
\\
\hline
SEND\_ATTACH\_RAW(\textless{}sender\textgreater{}, \textless{}recipients\textgreater{}, \textless{}cc\textgreater{}, \textless{}bcc\textgreater{}, \textless{}subject\textgreater{}, \textless{}message\textgreater{}, \textless{}mime\_type\textgreater{}, \textless{}priority\textgreater{}, \textless{}attachment\textgreater{} {[}, \textless{}att\_inline\textgreater{} {[}, \textless{}att\_mime\_type\textgreater{} {[}, \textless{}att\_filename\textgreater{} {]}{]}{]})
&
n/a
&
Same as the SEND procedure, but with BYTEA or large object attachments.
\\
\hline
SEND\_ATTACH\_VARCHAR2(\textless{}sender\textgreater{}, \textless{}recipients\textgreater{}, \textless{}cc\textgreater{}, \textless{}bcc\textgreater{}, \textless{}subject\textgreater{}, \textless{}message\textgreater{}, \textless{}mime\_type\textgreater{}, \textless{}priority\textgreater{}, \textless{}attachment\textgreater{} {[}, \textless{}att\_inline\textgreater{} {[}, \textless{}att\_mime\_type\textgreater{} {[}, \textless{}att\_filename\textgreater{} {]}{]}{]})
&
n/a
&
Same as the SEND procedure, but with VARCHAR2 attachments.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{sphinxadmonition}{note}{Note:}
An administrator must grant execute privileges to each user or group before they can use this package.
\end{sphinxadmonition}

\newpage


\subsection{\index{SEND}SEND}
\label{\detokenize{utl_mail:send}}
The \sphinxcode{SEND} procedure provides the capability to send an e-mail to an SMTP
server.

\sphinxcode{SEND(\textless{}sender\textgreater{} VARCHAR2, \textless{}recipients\textgreater{} VARCHAR2, \textless{}cc\textgreater{} VARCHAR2, \textless{}bcc\textgreater{} VARCHAR2, \textless{}subject\textgreater{} VARCHAR2, \textless{}message\textgreater{} VARCHAR2 {[}, \textless{}mime\_type\textgreater{} VARCHAR2 {[}, \textless{}priority\textgreater{} PLS\_INTEGER {]}{]})}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}sender\textgreater{}}
\begin{quote}

E-mail address of the sender.
\end{quote}

\sphinxcode{\textless{}recipients\textgreater{}}
\begin{quote}

Comma-separated e-mail addresses of the recipients.
\end{quote}

\sphinxcode{\textless{}cc\textgreater{}}
\begin{quote}

Comma-separated e-mail addresses of copy recipients.
\end{quote}

\sphinxcode{\textless{}bcc\textgreater{}}
\begin{quote}

Comma-separated e-mail addresses of blind copy recipients.
\end{quote}

\sphinxcode{\textless{}subject\textgreater{}}
\begin{quote}

Subject line of the e-mail.
\end{quote}

\sphinxcode{\textless{}message\textgreater{}}
\begin{quote}

Body of the e-mail.
\end{quote}

\sphinxcode{\textless{}mime\_type\textgreater{}}
\begin{quote}

Mime type of the message. The default is \sphinxcode{text/plain; charset=us-ascii}.
\end{quote}

\sphinxcode{\textless{}priority\textgreater{}}
\begin{quote}

Priority of the e-mail The default is 3.
\end{quote}

\sphinxstylestrong{Examples}

The following anonymous block sends a simple e-mail message.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
    v\PYGZus{}sender        VARCHAR2(30);
    v\PYGZus{}recipients    VARCHAR2(60);
    v\PYGZus{}subj          VARCHAR2(20);
    v\PYGZus{}msg           VARCHAR2(200);
BEGIN
    v\PYGZus{}sender := \PYGZsq{}jsmith@enterprisedb.com\PYGZsq{};
    v\PYGZus{}recipients := \PYGZsq{}ajones@enterprisedb.com,rrogers@enterprisedb.com\PYGZsq{};
    v\PYGZus{}subj := \PYGZsq{}Holiday Party\PYGZsq{};
    v\PYGZus{}msg := \PYGZsq{}This year\PYGZsq{}\PYGZsq{}s party is scheduled for Friday, Dec. 21 at \PYGZsq{} \textbar{}\textbar{}
             \PYGZsq{}6:00 PM. Please RSVP by Dec. 15th.\PYGZsq{};
    UTL\PYGZus{}MAIL.SEND(v\PYGZus{}sender,v\PYGZus{}recipients,NULL,NULL,v\PYGZus{}subj,v\PYGZus{}msg);
END;
\end{sphinxVerbatim}

\newpage


\subsection{\index{SEND\_ATTACH\_RAW}SEND\_ATTACH\_RAW}
\label{\detokenize{utl_mail:send-attach-raw}}
The \sphinxcode{SEND\_ATTACH\_RAW} procedure provides the capability to send an
e-mail to an SMTP server with an attachment containing either \sphinxcode{BYTEA} data
or a large object (identified by the large object’s \sphinxcode{OID}). The call to
\sphinxcode{SEND\_ATTACH\_RAW} can be written in two ways:

\sphinxcode{SEND\_ATTACH\_RAW(\textless{}sender\textgreater{} VARCHAR2, \textless{}recipients\textgreater{} VARCHAR2, \textless{}cc\textgreater{} VARCHAR2, \textless{}bcc\textgreater{} VARCHAR2, \textless{}subject\textgreater{} VARCHAR2, \textless{}message\textgreater{} VARCHAR2, \textless{}mime\_type\textgreater{} VARCHAR2, \textless{}priority\textgreater{} PLS\_INTEGER, \textless{}attachment\textgreater{} BYTEA{[}, \textless{}att\_inline\textgreater{} BOOLEAN {[}, \textless{}att\_mime\_type\textgreater{} VARCHAR2{[}, \textless{}att\_filename\textgreater{} VARCHAR2 {]}{]}{]})}

or

\sphinxcode{SEND\_ATTACH\_RAW(\textless{}sender\textgreater{} VARCHAR2, \textless{}recipients\textgreater{} VARCHAR2, \textless{}cc\textgreater{} VARCHAR2, \textless{}bcc\textgreater{} VARCHAR2, \textless{}subject\textgreater{} VARCHAR2, \textless{}message\textgreater{} VARCHAR2, \textless{}mime\_type\textgreater{} VARCHAR2, \textless{}priority\textgreater{} PLS\_INTEGER, \textless{}attachment\textgreater{} OID  {[}, \textless{}att\_inline\textgreater{} BOOLEAN {[}, \textless{}att\_mime\_type\textgreater{} VARCHAR2  {[}, \textless{}att\_filename\textgreater{} VARCHAR2 {]}{]}{]})}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}sender\textgreater{}}
\begin{quote}

E-mail address of the sender.
\end{quote}

\sphinxcode{\textless{}recipients\textgreater{}}
\begin{quote}

Comma-separated e-mail addresses of the recipients.
\end{quote}

\sphinxcode{\textless{}cc\textgreater{}}
\begin{quote}

Comma-separated e-mail addresses of copy recipients.
\end{quote}

\sphinxcode{\textless{}bcc\textgreater{}}
\begin{quote}

Comma-separated e-mail addresses of blind copy recipients.
\end{quote}

\sphinxcode{\textless{}subject\textgreater{}}
\begin{quote}

Subject line of the e-mail.
\end{quote}

\sphinxcode{\textless{}message\textgreater{}}
\begin{quote}

Body of the e-mail.
\end{quote}

\sphinxcode{\textless{}mime\_type\textgreater{}}
\begin{quote}

Mime type of the message. The default is \sphinxcode{text/plain; charset=us-ascii}.
\end{quote}

\newpage

\sphinxcode{\textless{}priority\textgreater{}}
\begin{quote}

Priority of the e-mail. The default is \sphinxcode{3}.
\end{quote}

\sphinxcode{\textless{}attachment\textgreater{}}
\begin{quote}

The attachment.
\end{quote}

\sphinxcode{\textless{}att\_inline\textgreater{}}
\begin{quote}

If set to \sphinxcode{TRUE}, then the attachment is viewable inline, \sphinxcode{FALSE} otherwise.
The default is \sphinxcode{TRUE}.
\end{quote}

\sphinxcode{\textless{}att\_mime\_type\textgreater{}}
\begin{quote}

Mime type of the attachment. The default is \sphinxcode{application/octet}.
\end{quote}

\sphinxcode{\textless{}att\_filename\textgreater{}}
\begin{quote}

The file name containing the attachment. The default is \sphinxcode{null}.
\end{quote}

\newpage


\subsection{\index{SEND\_ATTACH\_VARCHAR2}SEND\_ATTACH\_VARCHAR2}
\label{\detokenize{utl_mail:send-attach-varchar2}}
The \sphinxcode{SEND\_ATTACH\_VARCHAR2} procedure provides the capability to send an
e-mail to an SMTP server with a text attachment.

\sphinxcode{SEND\_ATTACH\_VARCHAR2(\textless{}sender\textgreater{} VARCHAR2, \textless{}recipients\textgreater{} VARCHAR2, \textless{}cc\textgreater{} VARCHAR2, \textless{}bcc\textgreater{} VARCHAR2, \textless{}subject\textgreater{} VARCHAR2, \textless{}message\textgreater{} VARCHAR2, \textless{}mime\_type\textgreater{} VARCHAR2, \textless{}priority\textgreater{} PLS\_INTEGER, \textless{}attachment\textgreater{} VARCHAR2 {[}, \textless{}att\_inline\textgreater{} BOOLEAN {[}, \textless{}att\_mime\_type\textgreater{} VARCHAR2 {[}, \textless{}att\_filename\textgreater{} VARCHAR2 {]}{]}{]})}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}sender\textgreater{}}
\begin{quote}

E-mail address of the sender.
\end{quote}

\sphinxcode{\textless{}recipients\textgreater{}}
\begin{quote}

Comma-separated e-mail addresses of the recipients.
\end{quote}

\sphinxcode{\textless{}cc\textgreater{}}
\begin{quote}

Comma-separated e-mail addresses of copy recipients.
\end{quote}

\sphinxcode{\textless{}bcc\textgreater{}}
\begin{quote}

Comma-separated e-mail addresses of blind copy recipients.
\end{quote}

\sphinxcode{\textless{}subject\textgreater{}}
\begin{quote}

Subject line of the e-mail.
\end{quote}

\sphinxcode{\textless{}message\textgreater{}}
\begin{quote}

Body of the e-mail.
\end{quote}

\sphinxcode{\textless{}mime\_type\textgreater{}}
\begin{quote}

Mime type of the message. The default is \sphinxcode{text/plain; charset=us-ascii}.
\end{quote}

\sphinxcode{\textless{}priority\textgreater{}}
\begin{quote}

Priority of the e-mail The default is \sphinxcode{3.}
\end{quote}

\sphinxcode{\textless{}attachment\textgreater{}}
\begin{quote}

The \sphinxcode{VARCHAR2} attachment.
\end{quote}

\sphinxcode{\textless{}att\_inline\textgreater{}}
\begin{quote}

If set to \sphinxcode{TRUE}, then the attachment is viewable inline, \sphinxcode{FALSE} otherwise.
The default is \sphinxcode{TRUE}.
\end{quote}

\sphinxcode{\textless{}att\_mime\_type\textgreater{}}
\begin{quote}

Mime type of the attachment. The default is \sphinxcode{text/plain;
charset=us-ascii}.
\end{quote}

\sphinxcode{\textless{}att\_filename\textgreater{}}
\begin{quote}

The file name containing the attachment. The default is \sphinxcode{null}.
\end{quote}

\newpage


\section{\index{UTL\_RAW}UTL\_RAW}
\label{\detokenize{utl_raw::doc}}\label{\detokenize{utl_raw:utl-raw}}
The \sphinxcode{UTL\_RAW} package allows you to manipulate or retrieve the length of
raw data types.

\begin{sphinxadmonition}{note}{Note:}
An administrator must grant execute privileges to each user or group before they can use this package.
\end{sphinxadmonition}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|\Y{0.3}|\Y{0.2}|\Y{0.2}|\Y{0.3}|}
\hline

Function/Procedure
&
Function or Procedure
&
Return Type
&
Description
\\
\hline
CAST\_TO\_RAW(c IN VARCHAR2)
&
Function
&
RAW
&
Converts a VARCHAR2 string to a RAW value.
\\
\hline
CAST\_TO\_VARCHAR2(r IN RAW)
&
Function
&
VARCHAR2
&
Converts a RAW value to a VARCHAR2 string.
\\
\hline
CONCAT(r1 IN RAW, r2 IN RAW, r3 IN RAW,…)
&
Function
&
RAW
&
Concatenate multiple RAW values into a single RAW value.
\\
\hline
CONVERT(r IN RAW, to\_charset IN VARCHAR2, from\_charset IN VARCHAR2
&
Function
&
RAW
&
Converts encoded data from one encoding to another, and returns the result as a RAW value.
\\
\hline
LENGTH(r IN RAW)
&
Function
&
NUMBER
&
Returns the length of a RAW value.
\\
\hline
SUBSTR(r IN RAW, pos IN INTEGER, len IN INTEGER)
&
Function
&
RAW
&
Returns a portion of a RAW value.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Advanced Server’s implementation of \sphinxcode{UTL\_RAW} is a partial implementation
when compared to Oracle’s version. Only those functions and procedures
listed in the table above are supported.


\subsection{\index{CAST\_TO\_RAW}CAST\_TO\_RAW}
\label{\detokenize{utl_raw:cast-to-raw}}
The \sphinxcode{CAST\_TO\_RAW} function converts a \sphinxcode{VARCHAR2} string to a RAW value.
The signature is:
\begin{quote}

\sphinxcode{CAST\_TO\_RAW(\textless{}c\textgreater{} VARCHAR2)}
\end{quote}

The function returns a \sphinxcode{RAW} value if you pass a non-\sphinxcode{NULL} value; if you
pass a \sphinxcode{NULL} value, the function will return \sphinxcode{NULL}.

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}c\textgreater{}}
\begin{quote}

The \sphinxcode{VARCHAR2} value that will be converted to \sphinxcode{RAW}.
\end{quote}

\sphinxstylestrong{Example}

The following example uses the \sphinxcode{CAST\_TO\_RAW} function to convert a
\sphinxcode{VARCHAR2} string to a \sphinxcode{RAW} value:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
  v VARCHAR2;
  r RAW;
BEGIN
  v := \PYGZsq{}Accounts\PYGZsq{};
  dbms\PYGZus{}output.put\PYGZus{}line(v);
  r := UTL\PYGZus{}RAW.CAST\PYGZus{}TO\PYGZus{}RAW(v);
  dbms\PYGZus{}output.put\PYGZus{}line(r);
END;
\end{sphinxVerbatim}

The result set includes the content of the original string and the converted RAW value:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Accounts
\PYGZbs{}x4163636f756e7473
\end{sphinxVerbatim}


\subsection{\index{CAST\_TO\_VARCHAR2}CAST\_TO\_VARCHAR2}
\label{\detokenize{utl_raw:cast-to-varchar2}}
The \sphinxcode{CAST\_TO\_VARCHAR2} function converts \sphinxcode{RAW} data to \sphinxcode{VARCHAR2} data. The
signature is:
\begin{quote}

\sphinxcode{CAST\_TO\_VARCHAR2(\textless{}r\textgreater{} RAW)}
\end{quote}

The function returns a \sphinxcode{VARCHAR2} value if you pass a non-\sphinxcode{NULL} value; if
you pass a \sphinxcode{NULL} value, the function will return \sphinxcode{NULL}.

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}r\textgreater{}}
\begin{quote}

The \sphinxcode{RAW} value that will be converted to a \sphinxcode{VARCHAR2} value.
\end{quote}

\sphinxstylestrong{Example}

The following example uses the \sphinxcode{CAST\_TO\_VARCHAR2} function to convert a
\sphinxcode{RAW} value to a \sphinxcode{VARCHAR2} string:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
  r RAW;
  v VARCHAR2;
BEGIN
  r := \PYGZsq{}\PYGZbs{}x4163636f756e7473\PYGZsq{}
  dbms\PYGZus{}output.put\PYGZus{}line(v);
  v := UTL\PYGZus{}RAW.CAST\PYGZus{}TO\PYGZus{}VARCHAR2(r);
  dbms\PYGZus{}output.put\PYGZus{}line(r);
END;
\end{sphinxVerbatim}

The result set includes the content of the original string and the converted \sphinxcode{RAW} value:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZbs{}x4163636f756e7473
Accounts
\end{sphinxVerbatim}

\newpage


\subsection{\index{CONCAT}CONCAT}
\label{\detokenize{utl_raw:concat}}
The \sphinxcode{CONCAT} function concatenates multiple \sphinxcode{RAW} values into a single \sphinxcode{RAW}
value. The signature is:
\begin{quote}

\sphinxcode{CONCAT(\textless{}r1\textgreater{} RAW, \textless{}r2\textgreater{} RAW, \textless{}r3\textgreater{} RAW,…)}
\end{quote}

The function returns a \sphinxcode{RAW} value. Unlike the Oracle implementation, the
Advanced Server implementation is a variadic function, and does not
place a restriction on the number of values that can be concatenated.

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}r1, r2, r3,…\textgreater{}}
\begin{quote}

The \sphinxcode{RAW} values that \sphinxcode{CONCAT} will concatenate.
\end{quote}

\sphinxstylestrong{Example}

The following example uses the \sphinxcode{CONCAT} function to concatenate multiple
\sphinxcode{RAW} values into a single \sphinxcode{RAW} value:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\textbar{} SELECT UTL\PYGZus{}RAW.CAST\PYGZus{}TO\PYGZus{}VARCHAR2(UTL\PYGZus{}RAW.CONCAT(\PYGZsq{}\PYGZbs{}x61\PYGZsq{}, \PYGZsq{}\PYGZbs{}x62\PYGZsq{},
\textbar{} \PYGZsq{}\PYGZbs{}x63\PYGZsq{})) FROM DUAL;
\textbar{} concat
\textbar{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
\textbar{} abc
\textbar{} (1 row)
\end{sphinxVerbatim}

The result (the concatenated values) is then converted to \sphinxcode{VARCHAR2}
format by the \sphinxcode{CAST\_TO\_VARCHAR2} function.

\newpage


\subsection{\index{CONVERT}CONVERT}
\label{\detokenize{utl_raw:convert}}
The \sphinxcode{CONVERT} function converts a string from one encoding to another
encoding and returns the result as a \sphinxcode{RAW} value. The signature is:
\begin{quote}

\sphinxcode{CONVERT(\textless{}r\textgreater{} RAW, \textless{}to\_charset\textgreater{} VARCHAR2, \textless{}from\_charset\textgreater{} VARCHAR2)}
\end{quote}

The function returns a \sphinxcode{RAW} value.

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}r\textgreater{}}
\begin{quote}

The \sphinxcode{RAW} value that will be converted.
\end{quote}

\sphinxcode{\textless{}to\_charset\textgreater{}}
\begin{quote}

The name of the encoding to which \sphinxcode{\textless{}r\textgreater{}} will be converted.
\end{quote}

\sphinxcode{\textless{}from\_charset\textgreater{}}
\begin{quote}

The name of the encoding from which \sphinxcode{\textless{}r\textgreater{}} will be converted.
\end{quote}

\sphinxstylestrong{Example}

The following example uses the \sphinxcode{UTL\_RAW.CAST\_TO\_RAW} function to
convert a \sphinxcode{VARCHAR2} string (\sphinxcode{Accounts}) to a raw value, and then convert
the value from \sphinxcode{UTF8} to \sphinxcode{LATIN7}, and then from \sphinxcode{LATIN7} to \sphinxcode{UTF8}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
  r RAW;
  v VARCHAR2;
BEGIN
  v:= \PYGZsq{}Accounts\PYGZsq{};
  dbms\PYGZus{}output.put\PYGZus{}line(v);
  r:= UTL\PYGZus{}RAW.CAST\PYGZus{}TO\PYGZus{}RAW(v);
  dbms\PYGZus{}output.put\PYGZus{}line(r);
  r:= UTL\PYGZus{}RAW.CONVERT(r, \PYGZsq{}UTF8\PYGZsq{}, \PYGZsq{}LATIN7\PYGZsq{});
  dbms\PYGZus{}output.put\PYGZus{}line(r);
  r:= UTL\PYGZus{}RAW.CONVERT(r, \PYGZsq{}LATIN7\PYGZsq{}, \PYGZsq{}UTF8\PYGZsq{});
  dbms\PYGZus{}output.put\PYGZus{}line(r);
\end{sphinxVerbatim}

The example returns the \sphinxcode{VARCHAR2} value, the \sphinxcode{RAW} value, and the converted values:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Accounts
\PYGZbs{}x4163636f756e7473
\PYGZbs{}x4163636f756e7473
\PYGZbs{}x4163636f756e7473
\end{sphinxVerbatim}

\newpage


\subsection{\index{LENGTH}LENGTH}
\label{\detokenize{utl_raw:length}}
The \sphinxcode{LENGTH} function returns the length of a \sphinxcode{RAW} value. The signature is:
\begin{quote}

\sphinxcode{LENGTH(\textless{}r\textgreater{} RAW)}
\end{quote}

The function returns a \sphinxcode{RAW} value.

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}r\textgreater{}}

The \sphinxcode{RAW} value that \sphinxcode{LENGTH} will evaluate.

\sphinxstylestrong{Example}

The following example uses the \sphinxcode{LENGTH} function to return the length of a
\sphinxcode{RAW} value:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
SELECT UTL\PYGZus{}RAW.LENGTH(UTL\PYGZus{}RAW.CAST\PYGZus{}TO\PYGZus{}RAW(\PYGZsq{}Accounts\PYGZsq{})) FROM DUAL;
length
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
8
(1 row)
\end{sphinxVerbatim}

The following example uses the \sphinxcode{LENGTH} function to return the length of a \sphinxcode{RAW} value that includes multi-byte characters:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
SELECT UTL\PYGZus{}RAW.LENGTH(UTL\PYGZus{}RAW.CAST\PYGZus{}TO\PYGZus{}RAW(\PYGZsq{}hello\PYGZsq{}));
length
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
     5
(1 row)
\end{sphinxVerbatim}

\newpage

\index{UTL\_RAW\_SUBSTR}\ignorespaces 

\subsection{SUBSTR}
\label{\detokenize{utl_raw:index-6}}\label{\detokenize{utl_raw:substr}}
The \sphinxcode{SUBSTR} function returns a substring of a \sphinxcode{RAW} value. The signature
is:
\begin{quote}

\sphinxcode{SUBSTR (\textless{}r\textgreater{} RAW, \textless{}pos\textgreater{} INTEGER, \textless{}len\textgreater{} INTEGER)}
\end{quote}

This function returns a \sphinxcode{RAW} value.

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}r\textgreater{}}

The \sphinxcode{RAW} value from which the substring will be returned.

\sphinxcode{\textless{}pos\textgreater{}}
\begin{quote}

The position within the \sphinxcode{RAW} value of the first byte of the returned
substring.
\end{quote}
\begin{itemize}
\item {} 
If \sphinxcode{\textless{}pos\textgreater{}} is \sphinxcode{0} or \sphinxcode{1}, the substring begins at the first byte of the \sphinxcode{RAW}
value.

\item {} 
If \sphinxcode{\textless{}pos\textgreater{}} is greater than one, the substring begins at the first byte
specified by \sphinxcode{\textless{}pos\textgreater{}}. For example, if \sphinxcode{\textless{}pos\textgreater{}} is \sphinxcode{3}, the substring
begins at the third byte of the value.

\item {} 
If \sphinxcode{\textless{}pos\textgreater{}} is negative, the substring begins at \sphinxcode{\textless{}pos\textgreater{}} bytes from the
end of the source value. For example, if \sphinxcode{\textless{}pos\textgreater{}} is \sphinxcode{-3}, the
substring begins at the third byte from the end of the value.

\end{itemize}

\sphinxcode{\textless{}len\textgreater{}}
\begin{quote}

The maximum number of bytes that will be returned.
\end{quote}

\sphinxstylestrong{Example}

The following example uses the \sphinxcode{SUBSTR} function to select a substring
that begins \sphinxcode{3} bytes from the start of a \sphinxcode{RAW} value:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
SELECT UTL\PYGZus{}RAW.SUBSTR(UTL\PYGZus{}RAW.CAST\PYGZus{}TO\PYGZus{}RAW(\PYGZsq{}Accounts\PYGZsq{}), 3, 5) FROM DUAL;
 substr
 \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
 count
 (1 row)
\end{sphinxVerbatim}

The following example uses the \sphinxcode{SUBSTR} function to select a substring
that starts \sphinxcode{5} bytes from the end of a \sphinxcode{RAW} value:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
SELECT UTL\PYGZus{}RAW.SUBSTR(UTL\PYGZus{}RAW.CAST\PYGZus{}TO\PYGZus{}RAW(\PYGZsq{}Accounts\PYGZsq{}), \PYGZhy{}5 , 3) FROM
DUAL;
substr
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
oun
(1 row)
\end{sphinxVerbatim}

\newpage


\section{\index{UTL\_SMTP}UTL\_SMTP}
\label{\detokenize{utl_smtp::doc}}\label{\detokenize{utl_smtp:utl-smtp}}
The \sphinxcode{UTL\_SMTP} package provides the capability to send e-mails over the
Simple Mail Transfer Protocol (SMTP).

\begin{sphinxadmonition}{note}{Note:}
An administrator must grant execute privileges to each user or group before they can use this package.
\end{sphinxadmonition}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|\Y{0.3}|\Y{0.2}|\Y{0.2}|\Y{0.3}|}
\hline

Function/Procedure
&
Function or Procedure
&
Return Type
&
Description
\\
\hline
CLOSE\_DATA(c IN OUT)
&
Procedure
&
n/a
&
Ends an e-mail message.
\\
\hline
COMMAND(c IN OUT, cmd {[}, arg {]})
&
Both
&
REPLY
&
Execute an SMTP command.
\\
\hline
COMMAND\_REPLIES(c IN OUT, cmd {[}, arg {]})
&
Function
&
REPLIES
&
Execute an SMTP command where multiple reply lines are expected.
\\
\hline
DATA(c IN OUT, body VARCHAR2)
&
Procedure
&
n/a
&
Specify the body of an e-mail message.
\\
\hline
EHLO(c IN OUT, domain)
&
Procedure
&
n/a
&
Perform initial handshaking with an SMTP server and return extended information.
\\
\hline
HELO(c IN OUT, domain)
&
Procedure
&
n/a
&
Perform initial handshaking with an SMTP server
\\
\hline
HELP(c IN OUT {[}, command {]})
&
Function
&
REPLIES
&
Send the HELP command.
\\
\hline
MAIL(c IN OUT, sender {[}, parameters {]})
&
Procedure
&
n/a
&
Start a mail transaction.
\\
\hline
NOOP(c IN OUT)
&
Both
&
REPLY
&
Send the null command.
\\
\hline
OPEN\_CONNECTION(host {[}, port {[}, tx\_timeout {]}{]})
&
Function
&
CONNECTION
&
Open a connection.
\\
\hline
OPEN\_DATA(c IN OUT)
&
Both
&
REPLY
&
Send the DATA command.
\\
\hline
QUIT(c IN OUT)
&
Procedure
&
n/a
&
Terminate the SMTP session and disconnect.
\\
\hline
RCPT(c IN OUT, recipient {[}, parameters {]})
&
Procedure
&
n/a
&
Specify the recipient of an e-mail message.
\\
\hline
RSET(c IN OUT)
&
Procedure
&
n/a
&
Terminate the current mail transaction.
\\
\hline
VRFY(c IN OUT, recipient)
&
Function
&
REPLY
&
Validate an e-mail address.
\\
\hline
WRITE\_DATA(c IN OUT, data)
&
Procedure
&
n/a
&
Write a portion of the e-mail message.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Advanced Server’s implementation of \sphinxcode{UTL\_SMTP} is a partial
implementation when compared to Oracle’s version. Only those functions
and procedures listed in the table above are supported.

The following table lists the public variables available in the
\sphinxcode{UTL\_SMTP} package.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline

Public Variables
&
Data Type
&
Value
&
Description
\\
\hline
connection
&
RECORD
&&
Description of an SMTP connection.
\\
\hline
reply
&
RECORD
&&
SMTP reply line.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\newpage


\subsection{\index{CONNECTION}CONNECTION}
\label{\detokenize{utl_smtp:connection}}
The \sphinxcode{CONNECTION} record type provides a description of an SMTP connection.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
TYPE connection IS RECORD (
    host            VARCHAR2(255),
    port            PLS\PYGZus{}INTEGER,
    tx\PYGZus{}timeout      PLS\PYGZus{}INTEGER
);
\end{sphinxVerbatim}


\subsection{\index{REPLY/REPLIES}REPLY/REPLIES}
\label{\detokenize{utl_smtp:reply-replies}}\label{\detokenize{utl_smtp:id1}}
The \sphinxcode{REPLY} record type provides a description of an SMTP reply line.
\sphinxcode{REPLIES} is a table of multiple SMTP reply lines.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
TYPE reply IS RECORD (
    code            INTEGER,
    text            VARCHAR2(508)
);
TYPE replies IS TABLE OF reply INDEX BY BINARY\PYGZus{}INTEGER;
\end{sphinxVerbatim}


\subsection{\index{CLOSE\_DATA}CLOSE\_DATA}
\label{\detokenize{utl_smtp:close-data}}
The \sphinxcode{CLOSE\_DATA} procedure terminates an e-mail message by sending the
following sequence:
\begin{quote}

\sphinxcode{\textless{}CR\textgreater{}\textless{}LF\textgreater{}.\textless{}CR\textgreater{}\textless{}LF\textgreater{}}
\end{quote}

This is a single period at the beginning of a line.

\sphinxcode{CLOSE\_DATA(\textless{}c\textgreater{} IN OUT CONNECTION)}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}c\textgreater{}}
\begin{quote}

The SMTP connection to be closed.
\end{quote}


\subsection{\index{COMMAND}COMMAND}
\label{\detokenize{utl_smtp:command}}
The \sphinxcode{COMMAND} procedure provides the capability to execute an SMTP
command. If you are expecting multiple reply lines, use
\sphinxcode{COMMAND\_REPLIES}.
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{\textless{}reply\textgreater{} REPLY COMMAND(\textless{}c\textgreater{} IN OUT CONNECTION, \textless{}cmd\textgreater{} VARCHAR2}
\item[] \sphinxcode{{[}, \textless{}arg\textgreater{} VARCHAR2 {]})}
\item[] \sphinxcode{COMMAND(\textless{}c\textgreater{} IN OUT CONNECTION, \textless{}cmd\textgreater{} VARCHAR2 {[}, \textless{}arg\textgreater{} VARCHAR2 {]})}
\end{DUlineblock}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}c\textgreater{}}
\begin{quote}

The SMTP connection to which the command is to be sent.
\end{quote}

\sphinxcode{\textless{}cmd\textgreater{}}
\begin{quote}

The SMTP command to be processed.
\end{quote}

\newpage

\sphinxcode{\textless{}arg\textgreater{}}
\begin{quote}

An argument to the SMTP command. The default is null.
\end{quote}

\sphinxcode{\textless{}reply\textgreater{}}
\begin{quote}

SMTP reply to the command. If SMTP returns multiple replies, only the
last one is returned in \sphinxcode{\textless{}reply\textgreater{}}.

See {\hyperref[\detokenize{utl_smtp:reply-replies}]{\sphinxcrossref{\DUrole{std,std-ref}{Reply/Replies}}}} for a description of \sphinxcode{REPLY} and \sphinxcode{REPLIES}.
\end{quote}


\subsection{\index{COMMAND\_REPLIES}COMMAND\_REPLIES}
\label{\detokenize{utl_smtp:command-replies}}
The \sphinxcode{COMMAND\_REPLIES} function processes an SMTP command that returns
multiple reply lines. Use \sphinxcode{COMMAND} if only a single reply line is
expected.
\begin{quote}

\sphinxcode{\textless{}replies\textgreater{} REPLIES COMMAND(\textless{}c\textgreater{} IN OUT CONNECTION, \textless{}cmd\textgreater{} VARCHAR2}

\sphinxcode{{[}, \textless{}arg\textgreater{} VARCHAR2 {]})}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}c\textgreater{}}
\begin{quote}

The SMTP connection to which the command is to be sent.
\end{quote}

\sphinxcode{\textless{}cmd\textgreater{}}
\begin{quote}

The SMTP command to be processed.
\end{quote}

\sphinxcode{\textless{}arg\textgreater{}}
\begin{quote}

An argument to the SMTP command. The default is null.
\end{quote}

\sphinxcode{\textless{}replies\textgreater{}}
\begin{quote}

SMTP reply lines to the command. See {\hyperref[\detokenize{utl_smtp:reply-replies}]{\sphinxcrossref{\DUrole{std,std-ref}{Reply/Replies}}}} for a description
of \sphinxcode{REPLY} and \sphinxcode{REPLIES}.
\end{quote}


\subsection{\index{DATA}DATA}
\label{\detokenize{utl_smtp:data}}
The \sphinxcode{DATA} procedure provides the capability to specify the body of the
e-mail message. The message is terminated with a \sphinxcode{\textless{}CR\textgreater{}\textless{}LF\textgreater{}.\textless{}CR\textgreater{}\textless{}LF\textgreater{}}
sequence.
\begin{quote}

\sphinxcode{DATA(\textless{}c\textgreater{} IN OUT CONNECTION, \textless{}body\textgreater{} VARCHAR2)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}c\textgreater{}}
\begin{quote}

The SMTP connection to which the command is to be sent.
\end{quote}

\sphinxcode{\textless{}body\textgreater{}}
\begin{quote}

Body of the e-mail message to be sent.
\end{quote}

\newpage


\subsection{\index{EHLO}EHLO}
\label{\detokenize{utl_smtp:ehlo}}
The \sphinxcode{EHLO} procedure performs initial handshaking with the SMTP server
after establishing the connection. The \sphinxcode{EHLO} procedure allows the client
to identify itself to the SMTP server according to RFC 821. RFC 1869
specifies the format of the information returned in the server’s reply.
The \sphinxstyleemphasis{HELO} procedure performs the equivalent functionality, but returns
less information about the server.
\begin{quote}

\sphinxcode{EHLO(\textless{}c\textgreater{} IN OUT CONNECTION, \textless{}domain\textgreater{} VARCHAR2)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}c\textgreater{}}
\begin{quote}

The connection to the SMTP server over which to perform handshaking.
\end{quote}

\sphinxcode{\textless{}domain\textgreater{}}
\begin{quote}

Domain name of the sending host.
\end{quote}


\subsection{\index{HELO}HELO}
\label{\detokenize{utl_smtp:helo}}
The \sphinxcode{HELO} procedure performs initial handshaking with the SMTP server
after establishing the connection. The \sphinxcode{HELO} procedure allows the client
to identify itself to the SMTP server according to RFC 821. The \sphinxstyleemphasis{EHLO}
procedure performs the equivalent functionality, but returns more
information about the server.
\begin{quote}

\sphinxcode{HELO(\textless{}c\textgreater{} IN OUT, \textless{}domain*\textgreater{} VARCHAR2)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}c\textgreater{}}
\begin{quote}

The connection to the SMTP server over which to perform handshaking.
\end{quote}

\sphinxcode{\textless{}domain\textgreater{}}
\begin{quote}

Domain name of the sending host.
\end{quote}


\subsection{\index{HELP}HELP}
\label{\detokenize{utl_smtp:help}}
The \sphinxcode{HELP} function provides the capability to send the \sphinxcode{HELP} command to
the SMTP server.
\begin{quote}

\sphinxcode{\textless{}replies\textgreater{} REPLIES HELP(\textless{}c\textgreater{} IN OUT CONNECTION {[}, \textless{}command\textgreater{} VARCHAR2}{]})
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}c\textgreater{}}
\begin{quote}

The SMTP connection to which the command is to be sent.
\end{quote}

\sphinxcode{\textless{}command\textgreater{}}
\begin{quote}

Command on which help is requested.
\end{quote}

\sphinxcode{\textless{}replies\textgreater{}}
\begin{quote}

SMTP reply lines to the command. See {\hyperref[\detokenize{utl_smtp:reply-replies}]{\sphinxcrossref{\DUrole{std,std-ref}{Reply/Replies}}}} for a description
of \sphinxcode{REPLY} and \sphinxcode{REPLIES}.
\end{quote}


\subsection{\index{MAIL}MAIL}
\label{\detokenize{utl_smtp:mail}}
The \sphinxcode{MAIL} procedure initiates a mail transaction.
\begin{quote}

\sphinxcode{MAIL(\textless{}c\textgreater{} IN OUT CONNECTION, \textless{}sender\textgreater{} VARCHAR2}

\sphinxcode{{[}, \textless{}parameters\textgreater{} VARCHAR2 {]})}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}c\textgreater{}}
\begin{quote}

Connection to SMTP server on which to start a mail transaction.
\end{quote}

\sphinxcode{\textless{}sender\textgreater{}}
\begin{quote}

The sender’s e-mail address.
\end{quote}

\sphinxcode{\textless{}parameters\textgreater{}}
\begin{quote}

Mail command parameters in the format, \sphinxcode{key=value} as defined in RFC 1869.
\end{quote}


\subsection{\index{NOOP}NOOP}
\label{\detokenize{utl_smtp:noop}}
The \sphinxcode{NOOP} function/procedure sends the null command to the SMTP server.
The \sphinxcode{NOOP} has no effect upon the server except to obtain a successful
response.
\begin{quote}

\sphinxcode{\textless{}reply\textgreater{} REPLY NOOP(\textless{}c\textgreater{} IN OUT CONNECTION)}

\sphinxcode{NOOP(\textless{}c\textgreater{} IN OUT CONNECTION)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}c\textgreater{}}
\begin{quote}

The SMTP connection on which to send the command.
\end{quote}

\sphinxcode{\textless{}reply\textgreater{}}
\begin{quote}

SMTP reply to the command. If SMTP returns multiple replies, only the
last one is returned in \sphinxcode{\textless{}reply\textgreater{}}. See {\hyperref[\detokenize{utl_smtp:reply-replies}]{\sphinxcrossref{\DUrole{std,std-ref}{Reply/Replies}}}} for a description
of \sphinxcode{REPLY} and \sphinxcode{REPLIES}.
\end{quote}


\subsection{\index{OPEN\_CONNECTION}OPEN\_CONNECTION}
\label{\detokenize{utl_smtp:open-connection}}
The \sphinxcode{OPEN\_CONNECTION} functions open a connection to an SMTP server.
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{\textless{}c\textgreater{} CONNECTION OPEN\_CONNECTION(\textless{}host\textgreater{} VARCHAR2 {[}, \textless{}port\textgreater{}}
\item[] \sphinxcode{PLS\_INTEGER {[}, \textless{}tx\_timeout\textgreater{} PLS\_INTEGER DEFAULT NULL{]}{]})}
\end{DUlineblock}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}host\textgreater{}}
\begin{quote}

Name of the SMTP server.
\end{quote}

\sphinxcode{\textless{}port\textgreater{}}
\begin{quote}

Port number on which the SMTP server is listening. The default is 25.
\end{quote}

\sphinxcode{\textless{}tx\_timeout\textgreater{}}
\begin{quote}

Time out value in seconds. Do not wait is indicated by specifying 0.
Wait indefinitely is indicated by setting timeout to null. The default
is null.
\end{quote}

\sphinxcode{\textless{}c\textgreater{}}
\begin{quote}

Connection handle returned by the SMTP server.
\end{quote}


\subsection{\index{OPEN\_DATA}OPEN\_DATA}
\label{\detokenize{utl_smtp:open-data}}
The \sphinxcode{OPEN\_DATA} procedure sends the \sphinxcode{DATA} command to the SMTP server.
\begin{quote}

\sphinxcode{OPEN\_DATA(\textless{}c\textgreater{} IN OUT CONNECTION)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}c\textgreater{}}
\begin{quote}

SMTP connection on which to send the command.
\end{quote}


\subsection{\index{QUIT}QUIT}
\label{\detokenize{utl_smtp:quit}}
The \sphinxcode{QUIT} procedure closes the session with an SMTP server.
\begin{quote}

\sphinxcode{QUIT(\textless{}c\textgreater{} IN OUT CONNECTION)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}c\textgreater{}}
\begin{quote}

SMTP connection to be terminated.
\end{quote}


\subsection{\index{RCPT}RCPT}
\label{\detokenize{utl_smtp:rcpt}}
The \sphinxcode{RCPT} procedure provides the e-mail address of the recipient. To
schedule multiple recipients, invoke \sphinxcode{RCPT} multiple times.
\begin{quote}

\sphinxcode{RCPT(\textless{}c\textgreater{} IN OUT CONNECTION, \textless{}recipient\textgreater{} VARCHAR2}

\sphinxcode{{[}, \textless{}parameters\textgreater{} VARCHAR2 {]})}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}c\textgreater{}}
\begin{quote}

Connection to SMTP server on which to add a recipient.
\end{quote}

\sphinxcode{\textless{}recipient\textgreater{}}
\begin{quote}

The recipient’s e-mail address.
\end{quote}

\sphinxcode{\textless{}parameters\textgreater{}}
\begin{quote}

Mail command parameters in the format, key=value as defined in RFC 1869.
\end{quote}


\subsection{\index{RSET}RSET}
\label{\detokenize{utl_smtp:rset}}
The \sphinxcode{RSET} procedure provides the capability to terminate the current mail
transaction.
\begin{quote}

\sphinxcode{RSET(\textless{}c\textgreater{} IN OUT CONNECTION)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}c\textgreater{}}
\begin{quote}

SMTP connection on which to cancel the mail transaction.
\end{quote}


\subsection{\index{VRFY}VRFY}
\label{\detokenize{utl_smtp:vrfy}}
The \sphinxcode{VRFY} function provides the capability to validate and verify the
recipient’s e-mail address. If valid, the recipient’s full name and
fully qualified mailbox is returned.
\begin{quote}

\sphinxcode{\textless{}reply\textgreater{} REPLY VRFY(\textless{}c\textgreater{} IN OUT CONNECTION, \textless{}recipient\textgreater{} VARCHAR2)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}c\textgreater{}}
\begin{quote}

The SMTP connection on which to verify the e-mail address.
\end{quote}

\sphinxcode{\textless{}recipient\textgreater{}}
\begin{quote}

The recipient’s e-mail address to be verified.
\end{quote}

\sphinxcode{\textless{}reply\textgreater{}}
\begin{quote}

SMTP reply to the command. If SMTP returns multiple replies, only the
last one is returned in \sphinxstyleemphasis{reply}. See {\hyperref[\detokenize{utl_smtp:reply-replies}]{\sphinxcrossref{\DUrole{std,std-ref}{Reply/Replies}}}} for a description
of \sphinxcode{REPLY} and \sphinxcode{REPLIES}.
\end{quote}


\subsection{\index{WRITE\_DATA}WRITE\_DATA}
\label{\detokenize{utl_smtp:write-data}}
The \sphinxcode{WRITE\_DATA} procedure provides the capability to add \sphinxcode{VARCHAR2} data
to an e-mail message. The \sphinxcode{WRITE\_DATA} procedure may be repetitively
called to add data.
\begin{quote}

\sphinxcode{WRITE\_DATA(\textless{}c\textgreater{} IN OUT CONNECTION, \textless{}data\textgreater{} VARCHAR2)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}c\textgreater{}}
\begin{quote}

The SMTP connection on which to add data.
\end{quote}

\sphinxcode{\textless{}data\textgreater{}}

Data to be added to the e-mail message. The data must conform to the RFC
822 specification.

\index{UTL\_SMTP\_Comprehensive\_example}\ignorespaces 

\subsection{Comprehensive Example}
\label{\detokenize{utl_smtp:comprehensive-example}}\label{\detokenize{utl_smtp:index-19}}
The following procedure constructs and sends a text e-mail message using
the \sphinxcode{UTL\_SMTP} package.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
CREATE OR REPLACE PROCEDURE send\PYGZus{}mail (
    p\PYGZus{}sender        VARCHAR2,
    p\PYGZus{}recipient     VARCHAR2,
    p\PYGZus{}subj          VARCHAR2,
    p\PYGZus{}msg           VARCHAR2,
    p\PYGZus{}mailhost      VARCHAR2
)
IS
    v\PYGZus{}conn          UTL\PYGZus{}SMTP.CONNECTION;
    v\PYGZus{}crlf          CONSTANT VARCHAR2(2) := CHR(13) \textbar{}\textbar{} CHR(10);
    v\PYGZus{}port          CONSTANT PLS\PYGZus{}INTEGER := 25;
BEGIN
    v\PYGZus{}conn := UTL\PYGZus{}SMTP.OPEN\PYGZus{}CONNECTION(p\PYGZus{}mailhost,v\PYGZus{}port);
    UTL\PYGZus{}SMTP.HELO(v\PYGZus{}conn,p\PYGZus{}mailhost);
    UTL\PYGZus{}SMTP.MAIL(v\PYGZus{}conn,p\PYGZus{}sender);
    UTL\PYGZus{}SMTP.RCPT(v\PYGZus{}conn,p\PYGZus{}recipient);
    UTL\PYGZus{}SMTP.DATA(v\PYGZus{}conn, SUBSTR(
        \PYGZsq{}Date: \PYGZsq{} \textbar{}\textbar{} TO\PYGZus{}CHAR(SYSDATE,
        \PYGZsq{}Dy, DD Mon YYYY HH24:MI:SS\PYGZsq{}) \textbar{}\textbar{} v\PYGZus{}crlf
        \textbar{}\textbar{} \PYGZsq{}From: \PYGZsq{} \textbar{}\textbar{} p\PYGZus{}sender \textbar{}\textbar{} v\PYGZus{}crlf
        \textbar{}\textbar{} \PYGZsq{}To: \PYGZsq{} \textbar{}\textbar{} p\PYGZus{}recipient \textbar{}\textbar{} v\PYGZus{}crlf
        \textbar{}\textbar{} \PYGZsq{}Subject: \PYGZsq{} \textbar{}\textbar{} p\PYGZus{}subj \textbar{}\textbar{} v\PYGZus{}crlf
        \textbar{}\textbar{} p\PYGZus{}msg
        , 1, 32767));
    UTL\PYGZus{}SMTP.QUIT(v\PYGZus{}conn);
END;

EXEC send\PYGZus{}mail(\PYGZsq{}asmith@enterprisedb.com\PYGZsq{},\PYGZsq{}pjones@enterprisedb.com\PYGZsq{},\PYGZsq{}Holiday Party\PYGZsq{},\PYGZsq{}Are you planning to attend?\PYGZsq{},\PYGZsq{}smtp.enterprisedb.com\PYGZsq{});
\end{sphinxVerbatim}

The following example uses the OPEN\_DATA, WRITE\_DATA, and CLOSE\_DATA procedures instead of the DATA procedure.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
CREATE OR REPLACE PROCEDURE send\PYGZus{}mail\PYGZus{}2 (
    p\PYGZus{}sender        VARCHAR2,
    p\PYGZus{}recipient     VARCHAR2,
    p\PYGZus{}subj          VARCHAR2,
    p\PYGZus{}msg           VARCHAR2,
    p\PYGZus{}mailhost      VARCHAR2
)
IS
    v\PYGZus{}conn          UTL\PYGZus{}SMTP.CONNECTION;
    v\PYGZus{}crlf          CONSTANT VARCHAR2(2) := CHR(13) \textbar{}\textbar{} CHR(10);
    v\PYGZus{}port          CONSTANT PLS\PYGZus{}INTEGER := 25;
BEGIN
    v\PYGZus{}conn := UTL\PYGZus{}SMTP.OPEN\PYGZus{}CONNECTION(p\PYGZus{}mailhost,v\PYGZus{}port);
    UTL\PYGZus{}SMTP.HELO(v\PYGZus{}conn,p\PYGZus{}mailhost);
    UTL\PYGZus{}SMTP.MAIL(v\PYGZus{}conn,p\PYGZus{}sender);
    UTL\PYGZus{}SMTP.RCPT(v\PYGZus{}conn,p\PYGZus{}recipient);
    UTL\PYGZus{}SMTP.OPEN\PYGZus{}DATA(v\PYGZus{}conn);
    UTL\PYGZus{}SMTP.WRITE\PYGZus{}DATA(v\PYGZus{}conn,\PYGZsq{}From: \PYGZsq{} \textbar{}\textbar{} p\PYGZus{}sender \textbar{}\textbar{} v\PYGZus{}crlf);
    UTL\PYGZus{}SMTP.WRITE\PYGZus{}DATA(v\PYGZus{}conn,\PYGZsq{}To: \PYGZsq{} \textbar{}\textbar{} p\PYGZus{}recipient \textbar{}\textbar{} v\PYGZus{}crlf);
    UTL\PYGZus{}SMTP.WRITE\PYGZus{}DATA(v\PYGZus{}conn,\PYGZsq{}Subject: \PYGZsq{} \textbar{}\textbar{} p\PYGZus{}subj \textbar{}\textbar{} v\PYGZus{}crlf);
    UTL\PYGZus{}SMTP.WRITE\PYGZus{}DATA(v\PYGZus{}conn,v\PYGZus{}crlf \textbar{}\textbar{} p\PYGZus{}msg);
    UTL\PYGZus{}SMTP.CLOSE\PYGZus{}DATA(v\PYGZus{}conn);
    UTL\PYGZus{}SMTP.QUIT(v\PYGZus{}conn);
END;

EXEC send\PYGZus{}mail\PYGZus{}2(\PYGZsq{}asmith@enterprisedb.com\PYGZsq{},\PYGZsq{}pjones@enterprisedb.com\PYGZsq{},\PYGZsq{}Holiday Party\PYGZsq{},\PYGZsq{}Are you planning to attend?\PYGZsq{},\PYGZsq{}smtp.enterprisedb.com\PYGZsq{});
\end{sphinxVerbatim}

\newpage


\section{\index{UTL\_URL}UTL\_URL}
\label{\detokenize{utl_url::doc}}\label{\detokenize{utl_url:utl-url}}
The \sphinxcode{UTL\_URL} package provides a way to escape illegal and reserved
characters within an URL.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

Function/Procedure
&
Return Type
&
Description
\\
\hline
ESCAPE(url, escape\_reserved\_chars, url\_charset)
&
VARCHAR2
&
Use the ESCAPE function to escape any illegal and reserved characters in a URL.
\\
\hline
UNESCAPE(url, url\_charset)
&
VARCHAR2
&
The UNESCAPE function to convert an URL to it’s original form.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

The \sphinxcode{UTL\_URL} package will return the \sphinxcode{BAD\_URL} exception if the call to a
function includes an incorrectly-formed URL.


\subsection{\index{ESCAPE}ESCAPE}
\label{\detokenize{utl_url:escape}}
Use the \sphinxcode{ESCAPE} function to escape illegal and reserved characters within
an URL. The signature is:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxcode{ESCAPE(\textless{}url\textgreater{} VARCHAR2, \textless{}escape\_reserved\_chars\textgreater{} BOOLEAN},
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \sphinxcode{\textless{}url\_charset\textgreater{} VARCHAR2)}
\end{DUlineblock}
\end{DUlineblock}
\end{quote}

Reserved characters are replaced with a percent sign, followed by the
two-digit hex code of the ascii value for the escaped character.

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}url\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}url\textgreater{}} specifies the Uniform Resource Locator that \sphinxcode{UTL\_URL} will
escape.
\end{quote}

\sphinxcode{\textless{}escape\_reserved\_chars\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}escape\_reserved\_chars\textgreater{}} is a \sphinxcode{BOOLEAN} value that instructs the
\sphinxcode{ESCAPE} function to escape reserved characters as well as illegal
characters:
\begin{itemize}
\item {} 
If \sphinxcode{\textless{}escaped\_reserved\_chars\textgreater{}} is \sphinxcode{FALSE}, \sphinxcode{ESCAPE} will escape
only the illegal characters in the specified URL.

\item {} 
If \sphinxcode{\textless{}escape\_reserved\_chars\textgreater{}} is \sphinxcode{TRUE}, \sphinxcode{ESCAPE} will escape
both the illegal characters and the reserved characters in the
specified URL.

\end{itemize}

By default, \sphinxcode{\textless{}escape\_reserved\_chars\textgreater{}} is \sphinxcode{FALSE}.

Within an URL, legal characters are:
\end{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Uppercase A through Z
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Lowercase a through z
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
0 through 9
\unskip}\relax \\
\hline
asterisk (*)
&
exclamation point (!)
&
hyphen (-)
\\
\hline
left parenthesis (()
&
period (.)
&
right parenthesis ())
\\
\hline
single-quote (‘)
&
tilde (\textasciitilde{})
&
underscore (\_)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}

Some characters are legal in some parts of an URL, while illegal in
others; to review comprehensive rules about illegal characters,
please refer to RFC 2396. Some \sphinxstyleemphasis{examples} of characters that are
considered illegal in any part of an URL are:
\end{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Illegal Character
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Escape Sequence
\unskip}\relax \\
\hline
a blank space ( )
&
\%20
\\
\hline
curly braces (\{ or \})
&
\%7b and \%7d
\\
\hline
hash mark (\#)
&
\%23
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}

The \sphinxcode{ESCAPE} function considers the following characters to be
reserved, and will escape them if \sphinxcode{\textless{}escape\_reserved\_chars\textgreater{}} is set to
\sphinxcode{TRUE}:
\end{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Reserved Character
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Escape Sequence
\unskip}\relax \\
\hline
ampersand (\&)
&
\%5C
\\
\hline
at sign (@)
&
\%25
\\
\hline
colon (:)
&
\%3a
\\
\hline
comma (,)
&
\%2c
\\
\hline
dollar sign (\$)
&
\%24
\\
\hline
equal sign (=)
&
\%3d
\\
\hline
plus sign (+)
&
\%2b
\\
\hline
question mark (?)
&
\%3f
\\
\hline
semi-colon (;)
&
\%3b
\\
\hline
slash (/)
&
\%2f
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxcode{\textless{}url\_charset\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}url\_charset\textgreater{}} specifies a character set to which a given character
will be converted before it is escaped. If \sphinxcode{\textless{}url\_charset\textgreater{}} is \sphinxcode{NULL},
the character will not be converted. The default value of
\sphinxcode{\textless{}url\_charset\textgreater{}} is \sphinxcode{ISO-8859-1}.
\end{quote}

\sphinxstylestrong{Examples}

The following anonymous block uses the \sphinxcode{ESCAPE} function to escape the
blank spaces in the URL:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
result varchar2(400);
BEGIN
result := UTL\PYGZus{}URL.ESCAPE(\PYGZsq{}http://www.example.com/Using the ESCAPE function.html\PYGZsq{});
DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(result);
END;
\end{sphinxVerbatim}

The resulting (escaped) URL is:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
http://www.example.com/Using\PYGZpc{}20the\PYGZpc{}20ESCAPE\PYGZpc{}20function.html
\end{sphinxVerbatim}

If you include a value of TRUE for the \sphinxcode{\textless{}escape\_reserved\_chars\textgreater{}} parameter when invoking the function:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DECLARE
result varchar2(400);
BEGIN
result := UTL\PYGZus{}URL.ESCAPE(\PYGZsq{}http://www.example.com/Using the ESCAPE function.html\PYGZsq{}, TRUE);
DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(result);
END;
\end{sphinxVerbatim}

The \sphinxcode{ESCAPE} function escapes the reserved characters as well as the illegal characters in the URL:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
http\PYGZpc{}3A\PYGZpc{}2F\PYGZpc{}2Fwww.example.com\PYGZpc{}2FUsing\PYGZpc{}20the\PYGZpc{}20ESCAPE\PYGZpc{}20function.html
\end{sphinxVerbatim}


\subsection{\index{UNESCAPE}UNESCAPE}
\label{\detokenize{utl_url:unescape}}
The \sphinxcode{UNESCAPE} function removes escape characters added to an URL by the
\sphinxcode{ESCAPE} function, converting the URL to it’s original form.

The signature is:
\begin{quote}

\sphinxcode{UNESCAPE(\textless{}url\textgreater{} VARCHAR2, \textless{}url\_charset\textgreater{} VARCHAR2)}
\end{quote}

\sphinxstylestrong{Parameters}

\sphinxcode{\textless{}url\textgreater{}}
\begin{quote}

\sphinxcode{\textless{}url\textgreater{}} specifies the Uniform Resource Locator that \sphinxcode{UTL\_URL} will
unescape.
\end{quote}

\sphinxcode{\textless{}url\_charset\textgreater{}}
\begin{quote}

After unescaping a character, the character is assumed to be in
\sphinxcode{\textless{}url\_charset\textgreater{}} encoding, and will be converted from that encoding to
database encoding before being returned. If \sphinxcode{\textless{}url\_charset\textgreater{}} is
\sphinxcode{NULL}, the character will not be converted. The default value of
\sphinxcode{\textless{}url\_charset\textgreater{}} is \sphinxcode{ISO-8859-1}.
\end{quote}

\sphinxstylestrong{Examples}

The following anonymous block uses the \sphinxcode{ESCAPE} function to escape the
blank spaces in the URL:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
   DECLARE
   result varchar2(400);
   BEGIN
result := UTL\PYGZus{}URL.UNESCAPE(\PYGZsq{}http://www.example.com/Using\PYGZpc{}20the\PYGZpc{}20UNESCAPE\PYGZpc{}20function.html\PYGZsq{});
   DBMS\PYGZus{}OUTPUT.PUT\PYGZus{}LINE(result);
   END;
\end{sphinxVerbatim}

The resulting (unescaped) URL is:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
http://www.example.com/Using the UNESCAPE function.htm
\end{sphinxVerbatim}


\chapter{Acknowledgements}
\label{\detokenize{acknowledgements:acknowledgements}}\label{\detokenize{acknowledgements::doc}}
The PostgreSQL 8.3, 8.4, 9.0, 9.1, 9.2, 9.3, 9.4, 9.5, 9.6, 10, 11, and
12 Documentation provided the baseline for the portions of this guide
that are common to PostgreSQL, and is hereby acknowledged:

Portions of this EnterpriseDB Software and Documentation may utilize the
following copyrighted material, the use of which is hereby acknowledged.

PostgreSQL Documentation, Database Management System

PostgreSQL is Copyright © 1996-2020 by the PostgreSQL Global Development
Group and is distributed under the terms of the license of the
University of California below.

Postgres95 is Copyright © 1994-5 by the Regents of the University of
California.

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose, without fee, and without a written
agreement is hereby granted, provided that the above copyright notice
and this paragraph and the following two paragraphs appear in all
copies.

\sphinxstylestrong{IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES,
INCLUDING LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS
DOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF
THE POSSIBILITY OF SUCH DAMAGE.}

\sphinxstylestrong{THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS
ON AN “AS-IS” BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS
TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
MODIFICATIONS.}


\chapter{\index{Conclusion}Conclusion}
\label{\detokenize{conclusion::doc}}\label{\detokenize{conclusion:id1}}\label{\detokenize{conclusion:conclusion}}
Database Compatibility for Oracle® Developers Built-in Packages Guide

Copyright © 2007 - 2020 EnterpriseDB Corporation. All rights reserved.

EnterpriseDB® Corporation
34 Crosby Drive, Suite 201, Bedford, MA 01730, USA

T +1 781 357 3390 F +1 978 467 1307 E
\sphinxhref{mailto:info@enterprisedb.com}{info@enterprisedb.com}
www.enterprisedb.com
\begin{itemize}
\item {} 
EnterpriseDB and Postgres Enterprise Manager are registered trademarks of EnterpriseDB Corporation. EDB and EDB Postgres are trademarks of EnterpriseDB Corporation. Oracle is a registered trademark of Oracle, Inc. Other trademarks may be trademarks of their respective owners.

\item {} 
EDB designs, establishes coding best practices, reviews, and verifies input validation for the logon UI for EDB Postgres Enterprise Manager where present. EDB follows the same approach for additional input components, however the nature of the product may require that it accepts freeform SQL, WMI or other strings to be entered and submitted by trusted users for which limited validation is possible. In such cases it is not possible to prevent users from entering incorrect or otherwise dangerous inputs.

\item {} 
EDB reserves the right to add features to products that accept freeform SQL, WMI or other potentially dangerous inputs from authenticated, trusted users in the future, but will ensure all such features are designed and tested to ensure they provide the minimum possible risk, and where possible, require superuser or equivalent privileges.

\item {} 
EDB does not warrant that we can or will anticipate all potential threats and therefore our process cannot fully guarantee that all potential vulnerabilities have been addressed or considered.

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}